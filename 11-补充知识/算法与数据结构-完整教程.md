# ç®—æ³•ä¸æ•°æ®ç»“æ„ å®Œæ•´æ•™ç¨‹

## ğŸ“‹ ç›®å½•
- [æŠ€æœ¯æ¦‚è¿°](#æŠ€æœ¯æ¦‚è¿°)
- [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
- [å¤æ‚åº¦åˆ†æ](#å¤æ‚åº¦åˆ†æ)
- [åŸºç¡€æ•°æ®ç»“æ„](#åŸºç¡€æ•°æ®ç»“æ„)
- [é«˜çº§æ•°æ®ç»“æ„](#é«˜çº§æ•°æ®ç»“æ„)
- [æ’åºç®—æ³•](#æ’åºç®—æ³•)
- [æŸ¥æ‰¾ç®—æ³•](#æŸ¥æ‰¾ç®—æ³•)
- [å¸¸ç”¨ç®—æ³•](#å¸¸ç”¨ç®—æ³•)
- [å®æˆ˜åº”ç”¨](#å®æˆ˜åº”ç”¨)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
- [å­¦ä¹ æ£€æŸ¥æ¸…å•](#å­¦ä¹ æ£€æŸ¥æ¸…å•)

## ğŸ“š æŠ€æœ¯æ¦‚è¿°
- **ç‰ˆæœ¬**: é€šç”¨
- **å‚è€ƒä¹¦ç±**: ã€Šç®—æ³•å¯¼è®ºã€‹ã€ã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹
- **å­¦ä¹ éš¾åº¦**: â­â­â­â­ (4æ˜Ÿ)
- **é‡è¦ç¨‹åº¦**: â­â­â­â­â­ (5æ˜Ÿ)
- **å‰ç½®çŸ¥è¯†**: JavaåŸºç¡€ã€æ•°å­¦åŸºç¡€
- **æ–‡æ¡£æ¥æº**: ç»å…¸ç®—æ³•æ•™æ + LeetCode
- **æ›´æ–°æ—¶é—´**: 2024-01-04
- **ä½œè€…**: @author erik.zhou

## ğŸ¯ å­¦ä¹ ç›®æ ‡
- [ ] ç†è§£æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
- [ ] æŒæ¡å¸¸ç”¨æ•°æ®ç»“æ„çš„å®ç°å’Œåº”ç”¨
- [ ] ç†Ÿç»ƒä½¿ç”¨å¸¸è§æ’åºå’ŒæŸ¥æ‰¾ç®—æ³•
- [ ] ç†è§£é€’å½’ã€åˆ†æ²»ã€åŠ¨æ€è§„åˆ’ç­‰ç®—æ³•æ€æƒ³
- [ ] èƒ½å¤Ÿåˆ†æç®—æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- [ ] èƒ½å¤Ÿé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„å’Œç®—æ³•è§£å†³é—®é¢˜

## ğŸ“– å¤æ‚åº¦åˆ†æ ğŸ”¥

### 1.1 æ—¶é—´å¤æ‚åº¦ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

**å®šä¹‰**: ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„è¶‹åŠ¿

**å¸¸è§æ—¶é—´å¤æ‚åº¦**ï¼ˆä»å¿«åˆ°æ…¢ï¼‰:
```
O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(nÂ³) < O(2â¿) < O(n!)
```

**ç¤ºä¾‹**:
```java
/**
 * æ—¶é—´å¤æ‚åº¦ç¤ºä¾‹
 * @author erik.zhou
 */
public class TimeComplexity {
    // O(1) - å¸¸æ•°æ—¶é—´
    public int constant(int n) {
        return n * 2;
    }
    
    // O(log n) - å¯¹æ•°æ—¶é—´
    public int logarithmic(int n) {
        int count = 0;
        while (n > 1) {
            n = n / 2;
            count++;
        }
        return count;
    }
    
    // O(n) - çº¿æ€§æ—¶é—´
    public int linear(int[] arr) {
        int sum = 0;
        for (int num : arr) {
            sum += num;
        }
        return sum;
    }
    
    // O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´
    public void nLogN(int[] arr) {
        // å½’å¹¶æ’åºã€å¿«é€Ÿæ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦
        Arrays.sort(arr);
    }
    
    // O(nÂ²) - å¹³æ–¹æ—¶é—´
    public void quadratic(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                // åµŒå¥—å¾ªç¯
            }
        }
    }
    
    // O(2â¿) - æŒ‡æ•°æ—¶é—´
    public int exponential(int n) {
        if (n <= 1) {
            return 1;
        }
        return exponential(n - 1) + exponential(n - 1);
    }
}
```

### 1.2 ç©ºé—´å¤æ‚åº¦

**å®šä¹‰**: ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€çš„é¢å¤–å­˜å‚¨ç©ºé—´

```java
/**
 * ç©ºé—´å¤æ‚åº¦ç¤ºä¾‹
 * @author erik.zhou
 */
public class SpaceComplexity {
    // O(1) - å¸¸æ•°ç©ºé—´
    public int constant(int n) {
        int result = n * 2;
        return result;
    }
    
    // O(n) - çº¿æ€§ç©ºé—´
    public int[] linear(int n) {
        int[] arr = new int[n];
        return arr;
    }
    
    // O(n) - é€’å½’è°ƒç”¨æ ˆ
    public int recursive(int n) {
        if (n <= 0) {
            return 0;
        }
        return n + recursive(n - 1);
    }
}
```


## ğŸ”¥ åŸºç¡€æ•°æ®ç»“æ„

### 2.1 æ•°ç»„ï¼ˆArrayï¼‰

**ç‰¹ç‚¹**:
- è¿ç»­å†…å­˜å­˜å‚¨
- éšæœºè®¿é—®O(1)
- æ’å…¥/åˆ é™¤O(n)

```java
/**
 * æ•°ç»„æ“ä½œ
 * @author erik.zhou
 */
public class ArrayOperations {
    // æŸ¥æ‰¾å…ƒç´ 
    public int find(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
    
    // æ’å…¥å…ƒç´ ï¼ˆéœ€è¦ç§»åŠ¨å…ƒç´ ï¼‰
    public int[] insert(int[] arr, int index, int value) {
        int[] newArr = new int[arr.length + 1];
        for (int i = 0; i < index; i++) {
            newArr[i] = arr[i];
        }
        newArr[index] = value;
        for (int i = index; i < arr.length; i++) {
            newArr[i + 1] = arr[i];
        }
        return newArr;
    }
    
    // åˆ é™¤å…ƒç´ 
    public int[] delete(int[] arr, int index) {
        int[] newArr = new int[arr.length - 1];
        for (int i = 0; i < index; i++) {
            newArr[i] = arr[i];
        }
        for (int i = index + 1; i < arr.length; i++) {
            newArr[i - 1] = arr[i];
        }
        return newArr;
    }
}
```

### 2.2 é“¾è¡¨ï¼ˆLinkedListï¼‰ğŸ”¥

**ç‰¹ç‚¹**:
- éè¿ç»­å†…å­˜å­˜å‚¨
- æ’å…¥/åˆ é™¤O(1)
- æŸ¥æ‰¾O(n)

```java
/**
 * å•é“¾è¡¨å®ç°
 * @author erik.zhou
 */
public class LinkedList {
    private Node head;
    
    private static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    // å¤´éƒ¨æ’å…¥
    public void addFirst(int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        head = newNode;
    }
    
    // å°¾éƒ¨æ’å…¥
    public void addLast(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
            return;
        }
        Node current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }
    
    // åˆ é™¤èŠ‚ç‚¹
    public void delete(int data) {
        if (head == null) {
            return;
        }
        if (head.data == data) {
            head = head.next;
            return;
        }
        Node current = head;
        while (current.next != null && current.next.data != data) {
            current = current.next;
        }
        if (current.next != null) {
            current.next = current.next.next;
        }
    }
    
    // åè½¬é“¾è¡¨ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰
    public void reverse() {
        Node prev = null;
        Node current = head;
        while (current != null) {
            Node next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        head = prev;
    }
}
```

### 2.3 æ ˆï¼ˆStackï¼‰

**ç‰¹ç‚¹**: åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰

```java
/**
 * æ ˆå®ç°
 * @author erik.zhou
 */
public class Stack {
    private int[] arr;
    private int top;
    private int capacity;
    
    public Stack(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.top = -1;
    }
    
    public void push(int data) {
        if (top == capacity - 1) {
            throw new RuntimeException("æ ˆå·²æ»¡");
        }
        arr[++top] = data;
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("æ ˆä¸ºç©º");
        }
        return arr[top--];
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("æ ˆä¸ºç©º");
        }
        return arr[top];
    }
    
    public boolean isEmpty() {
        return top == -1;
    }
}
```

### 2.4 é˜Ÿåˆ—ï¼ˆQueueï¼‰

**ç‰¹ç‚¹**: å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰

```java
/**
 * é˜Ÿåˆ—å®ç°
 * @author erik.zhou
 */
public class Queue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public Queue(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    public void enqueue(int data) {
        if (size == capacity) {
            throw new RuntimeException("é˜Ÿåˆ—å·²æ»¡");
        }
        rear = (rear + 1) % capacity;
        arr[rear] = data;
        size++;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("é˜Ÿåˆ—ä¸ºç©º");
        }
        int data = arr[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
}
```

### 2.5 å“ˆå¸Œè¡¨ï¼ˆHashMapï¼‰ğŸ”¥

**ç‰¹ç‚¹**:
- å¹³å‡æŸ¥æ‰¾/æ’å…¥/åˆ é™¤O(1)
- åŸºäºå“ˆå¸Œå‡½æ•°

```java
/**
 * ç®€å•å“ˆå¸Œè¡¨å®ç°
 * @author erik.zhou
 */
public class SimpleHashMap {
    private static class Entry {
        String key;
        int value;
        Entry next;
        
        Entry(String key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Entry[] table;
    private int capacity;
    
    public SimpleHashMap(int capacity) {
        this.capacity = capacity;
        this.table = new Entry[capacity];
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    public void put(String key, int value) {
        int index = hash(key);
        Entry entry = table[index];
        
        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
            entry = entry.next;
        }
        
        // å¤´éƒ¨æ’å…¥
        Entry newEntry = new Entry(key, value);
        newEntry.next = table[index];
        table[index] = newEntry;
    }
    
    public Integer get(String key) {
        int index = hash(key);
        Entry entry = table[index];
        
        while (entry != null) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
            entry = entry.next;
        }
        return null;
    }
}
```

## ğŸ”¥ é«˜çº§æ•°æ®ç»“æ„

### 3.1 äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰ğŸ”¥

```java
/**
 * äºŒå‰æ ‘å®ç°
 * @author erik.zhou
 */
public class BinaryTree {
    private static class Node {
        int data;
        Node left;
        Node right;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node root;
    
    // å‰åºéå†ï¼ˆæ ¹-å·¦-å³ï¼‰
    public void preOrder(Node node) {
        if (node == null) {
            return;
        }
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }
    
    // ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰
    public void inOrder(Node node) {
        if (node == null) {
            return;
        }
        inOrder(node.left);
        System.out.print(node.data + " ");
        inOrder(node.right);
    }
    
    // ååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰
    public void postOrder(Node node) {
        if (node == null) {
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.data + " ");
    }
    
    // å±‚åºéå†
    public void levelOrder() {
        if (root == null) {
            return;
        }
        java.util.Queue<Node> queue = new java.util.LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            System.out.print(node.data + " ");
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
}
```

### 3.2 äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

**ç‰¹ç‚¹**: å·¦å­æ ‘ < æ ¹ < å³å­æ ‘

```java
/**
 * äºŒå‰æœç´¢æ ‘å®ç°
 * @author erik.zhou
 */
public class BST {
    private static class Node {
        int data;
        Node left;
        Node right;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node root;
    
    // æ’å…¥
    public void insert(int data) {
        root = insertRec(root, data);
    }
    
    private Node insertRec(Node node, int data) {
        if (node == null) {
            return new Node(data);
        }
        if (data < node.data) {
            node.left = insertRec(node.left, data);
        } else if (data > node.data) {
            node.right = insertRec(node.right, data);
        }
        return node;
    }
    
    // æŸ¥æ‰¾
    public boolean search(int data) {
        return searchRec(root, data);
    }
    
    private boolean searchRec(Node node, int data) {
        if (node == null) {
            return false;
        }
        if (data == node.data) {
            return true;
        }
        if (data < node.data) {
            return searchRec(node.left, data);
        }
        return searchRec(node.right, data);
    }
    
    // åˆ é™¤
    public void delete(int data) {
        root = deleteRec(root, data);
    }
    
    private Node deleteRec(Node node, int data) {
        if (node == null) {
            return null;
        }
        
        if (data < node.data) {
            node.left = deleteRec(node.left, data);
        } else if (data > node.data) {
            node.right = deleteRec(node.right, data);
        } else {
            // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
            if (node.left == null) {
                return node.right;
            }
            if (node.right == null) {
                return node.left;
            }
            
            // æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼šæ‰¾å³å­æ ‘æœ€å°å€¼
            node.data = findMin(node.right);
            node.right = deleteRec(node.right, node.data);
        }
        return node;
    }
    
    private int findMin(Node node) {
        while (node.left != null) {
            node = node.left;
        }
        return node.data;
    }
}
```

### 3.3 å †ï¼ˆHeapï¼‰

**ç‰¹ç‚¹**: å®Œå…¨äºŒå‰æ ‘ï¼Œçˆ¶èŠ‚ç‚¹ â‰¥ å­èŠ‚ç‚¹ï¼ˆå¤§é¡¶å †ï¼‰

```java
/**
 * å¤§é¡¶å †å®ç°
 * @author erik.zhou
 */
public class MaxHeap {
    private int[] arr;
    private int size;
    private int capacity;
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.size = 0;
    }
    
    private int parent(int i) {
        return (i - 1) / 2;
    }
    
    private int leftChild(int i) {
        return 2 * i + 1;
    }
    
    private int rightChild(int i) {
        return 2 * i + 2;
    }
    
    // æ’å…¥
    public void insert(int data) {
        if (size == capacity) {
            throw new RuntimeException("å †å·²æ»¡");
        }
        arr[size] = data;
        int current = size;
        size++;
        
        // ä¸Šæµ®
        while (current > 0 && arr[current] > arr[parent(current)]) {
            swap(current, parent(current));
            current = parent(current);
        }
    }
    
    // åˆ é™¤æœ€å¤§å€¼
    public int extractMax() {
        if (size == 0) {
            throw new RuntimeException("å †ä¸ºç©º");
        }
        int max = arr[0];
        arr[0] = arr[size - 1];
        size--;
        
        // ä¸‹æ²‰
        heapify(0);
        return max;
    }
    
    private void heapify(int i) {
        int largest = i;
        int left = leftChild(i);
        int right = rightChild(i);
        
        if (left < size && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < size && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }
    
    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## ğŸ”¥ æ’åºç®—æ³•

### 4.1 å†’æ³¡æ’åºï¼ˆBubble Sortï¼‰

**æ—¶é—´å¤æ‚åº¦**: O(nÂ²)  
**ç©ºé—´å¤æ‚åº¦**: O(1)  
**ç¨³å®šæ€§**: ç¨³å®š

```java
/**
 * å†’æ³¡æ’åº
 * @author erik.zhou
 */
public class BubbleSort {
    public void sort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            if (!swapped) {
                break; // ä¼˜åŒ–ï¼šå·²æ’åº
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.2 å¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰ğŸ”¥

**æ—¶é—´å¤æ‚åº¦**: å¹³å‡O(n log n)ï¼Œæœ€åO(nÂ²)  
**ç©ºé—´å¤æ‚åº¦**: O(log n)  
**ç¨³å®šæ€§**: ä¸ç¨³å®š

```java
/**
 * å¿«é€Ÿæ’åº
 * @author erik.zhou
 */
public class QuickSort {
    public void sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.3 å½’å¹¶æ’åºï¼ˆMerge Sortï¼‰ğŸ”¥

**æ—¶é—´å¤æ‚åº¦**: O(n log n)  
**ç©ºé—´å¤æ‚åº¦**: O(n)  
**ç¨³å®šæ€§**: ç¨³å®š

```java
/**
 * å½’å¹¶æ’åº
 * @author erik.zhou
 */
public class MergeSort {
    public void sort(int[] arr) {
        mergeSort(arr, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    
    private void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0;
        int j = 0;
        int k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = leftArr[i++];
        }
        
        while (j < n2) {
            arr[k++] = rightArr[j++];
        }
    }
}
```

## ğŸ”¥ æŸ¥æ‰¾ç®—æ³•

### 5.1 äºŒåˆ†æŸ¥æ‰¾ï¼ˆBinary Searchï¼‰ğŸ”¥

**æ—¶é—´å¤æ‚åº¦**: O(log n)  
**å‰æ**: æ•°ç»„å·²æ’åº

```java
/**
 * äºŒåˆ†æŸ¥æ‰¾
 * @author erik.zhou
 */
public class BinarySearch {
    // è¿­ä»£å®ç°
    public int search(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
    // é€’å½’å®ç°
    public int searchRecursive(int[] arr, int target) {
        return binarySearchRec(arr, target, 0, arr.length - 1);
    }
    
    private int binarySearchRec(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        }
        if (arr[mid] < target) {
            return binarySearchRec(arr, target, mid + 1, right);
        }
        return binarySearchRec(arr, target, left, mid - 1);
    }
}
```

## ğŸ”¥ å¸¸ç”¨ç®—æ³•

### 6.1 é€’å½’

```java
/**
 * é€’å½’ç¤ºä¾‹
 * @author erik.zhou
 */
public class Recursion {
    // é˜¶ä¹˜
    public int factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    // æ–æ³¢é‚£å¥‘æ•°åˆ—
    public int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // æ–æ³¢é‚£å¥‘ä¼˜åŒ–ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰
    public int fibonacciDP(int n) {
        if (n <= 1) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

### 6.2 åŠ¨æ€è§„åˆ’ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

```java
/**
 * åŠ¨æ€è§„åˆ’ç¤ºä¾‹
 * @author erik.zhou
 */
public class DynamicProgramming {
    // çˆ¬æ¥¼æ¢¯é—®é¢˜
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
    
    // æœ€é•¿å…¬å…±å­åºåˆ—
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

## âœ¨ æœ€ä½³å®è·µ

### 1. æ•°æ®ç»“æ„é€‰æ‹©

| åœºæ™¯ | æ¨èæ•°æ®ç»“æ„ |
|------|-------------|
| é¢‘ç¹æŸ¥æ‰¾ | HashMapã€HashSet |
| æœ‰åºæ•°æ® | TreeMapã€TreeSet |
| å…ˆè¿›å…ˆå‡º | Queue |
| åè¿›å…ˆå‡º | Stack |
| ä¼˜å…ˆçº§é˜Ÿåˆ— | PriorityQueueï¼ˆå †ï¼‰ |
| é¢‘ç¹æ’å…¥åˆ é™¤ | LinkedList |
| éšæœºè®¿é—® | ArrayList |

### 2. ç®—æ³•é€‰æ‹©

| åœºæ™¯ | æ¨èç®—æ³• |
|------|---------|
| å°è§„æ¨¡æ•°æ®æ’åº | æ’å…¥æ’åº |
| å¤§è§„æ¨¡æ•°æ®æ’åº | å¿«é€Ÿæ’åºã€å½’å¹¶æ’åº |
| ç¨³å®šæ’åº | å½’å¹¶æ’åº |
| æœ‰åºæ•°ç»„æŸ¥æ‰¾ | äºŒåˆ†æŸ¥æ‰¾ |
| æœ€çŸ­è·¯å¾„ | Dijkstraã€Floyd |
| æœ€ä¼˜è§£é—®é¢˜ | åŠ¨æ€è§„åˆ’ |

## â“ å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„ï¼Ÿ
A: æ ¹æ®æ“ä½œé¢‘ç‡é€‰æ‹©ï¼šé¢‘ç¹æŸ¥æ‰¾ç”¨HashMapï¼Œé¢‘ç¹æ’å…¥åˆ é™¤ç”¨LinkedListï¼Œéœ€è¦æ’åºç”¨TreeMapã€‚

### Q2: é€’å½’å’Œè¿­ä»£å¦‚ä½•é€‰æ‹©ï¼Ÿ
A: é€’å½’ä»£ç ç®€æ´ä½†å¯èƒ½æ ˆæº¢å‡ºï¼Œè¿­ä»£æ€§èƒ½æ›´å¥½ã€‚ç®€å•é—®é¢˜ç”¨é€’å½’ï¼Œå¤æ‚é—®é¢˜ç”¨è¿­ä»£ã€‚

### Q3: å¦‚ä½•ä¼˜åŒ–ç®—æ³•æ€§èƒ½ï¼Ÿ
A: 
1. å‡å°‘æ—¶é—´å¤æ‚åº¦ï¼ˆä½¿ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•ï¼‰
2. å‡å°‘ç©ºé—´å¤æ‚åº¦ï¼ˆå¤ç”¨å˜é‡ï¼‰
3. ä½¿ç”¨ç¼“å­˜ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰
4. æå‰ç»ˆæ­¢ï¼ˆå‰ªæï¼‰

## ğŸ”— ç›¸å…³èµ„æº

- [ã€Šç®—æ³•å¯¼è®ºã€‹](https://book.douban.com/subject/20432061/)
- [ã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹](https://book.douban.com/subject/1139426/)
- [LeetCode](https://leetcode.cn/)
- [ç‰›å®¢ç½‘](https://www.nowcoder.com/)

## ğŸ“ å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
- [ ] æŒæ¡æ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—
- [ ] æŒæ¡å“ˆå¸Œè¡¨ã€æ ‘ã€å †
- [ ] ç†Ÿç»ƒä½¿ç”¨å¸¸è§æ’åºç®—æ³•
- [ ] æŒæ¡äºŒåˆ†æŸ¥æ‰¾
- [ ] ç†è§£é€’å½’å’ŒåŠ¨æ€è§„åˆ’
- [ ] èƒ½å¤Ÿåˆ†æç®—æ³•å¤æ‚åº¦
- [ ] èƒ½å¤Ÿé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„å’Œç®—æ³•

---

**å­¦ä¹ å»ºè®®**ï¼š
1. å…ˆç†è§£æ•°æ®ç»“æ„ï¼Œå†å­¦ä¹ ç®—æ³•
2. å¤šåˆ·LeetCodeé¢˜ç›®
3. ç†è§£ç®—æ³•æ€æƒ³æ¯”è®°ä½ä»£ç æ›´é‡è¦
4. å…³æ³¨æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
5. åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨æ‰€å­¦çŸ¥è¯†
