# æ¨èç³»ç»Ÿ-å®Œæ•´å®æˆ˜

> @author erik.zhou  
> éš¾åº¦: â­â­â­â­â­  
> æŠ€æœ¯æ ˆ: Spring Boot + Redis + Flink + Elasticsearch + TensorFlow

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### ä¸šåŠ¡åœºæ™¯
æ„å»ºä¸€ä¸ªç”µå•†æ¨èç³»ç»Ÿï¼Œä¸ºç”¨æˆ·æä¾›ä¸ªæ€§åŒ–å•†å“æ¨èï¼š
- **å®æ—¶æ¨è**: åŸºäºç”¨æˆ·å®æ—¶è¡Œä¸ºçš„æ¨è
- **ä¸ªæ€§åŒ–æ¨è**: åŸºäºç”¨æˆ·ç”»åƒå’Œå†å²è¡Œä¸º
- **å¬å›ç­–ç•¥**: å¤šè·¯å¬å›ï¼ˆååŒè¿‡æ»¤ã€å†…å®¹æ¨èã€çƒ­é—¨æ¨èï¼‰
- **æ’åºæ¨¡å‹**: ç²¾æ’æ¨¡å‹ä¼˜åŒ–æ¨èç»“æœ

### æ ¸å¿ƒéš¾ç‚¹
1. **å®æ—¶ç‰¹å¾è®¡ç®—** - æ¯«ç§’çº§è®¡ç®—ç”¨æˆ·å®æ—¶ç‰¹å¾
2. **å¤šè·¯å¬å›èåˆ** - å¤šç§å¬å›ç­–ç•¥çš„èåˆå’Œå»é‡
3. **æ¨¡å‹åœ¨çº¿æœåŠ¡** - æ·±åº¦å­¦ä¹ æ¨¡å‹çš„é«˜æ€§èƒ½åœ¨çº¿æ¨ç†

---

## ğŸ¯ æŠ€æœ¯éš¾ç‚¹1: å®æ—¶ç‰¹å¾è®¡ç®—

### é—®é¢˜åœºæ™¯
- ç”¨æˆ·è¡Œä¸ºæ•°æ®é‡å¤§ï¼ˆæ¯ç§’10ä¸‡+äº‹ä»¶ï¼‰
- ç‰¹å¾è®¡ç®—è¦å®æ—¶ï¼ˆå»¶è¿Ÿ<100msï¼‰
- ç‰¹å¾ç§ç±»å¤šï¼ˆç”¨æˆ·ç‰¹å¾ã€å•†å“ç‰¹å¾ã€äº¤å‰ç‰¹å¾ï¼‰
- ç‰¹å¾è¦æ”¯æŒå¿«é€ŸæŸ¥è¯¢

### è§£å†³æ–¹æ¡ˆ

#### 1. å®æ—¶ç‰¹å¾æµå¤„ç†

```java
/**
 * å®æ—¶ç‰¹å¾è®¡ç®—
 * ä½¿ç”¨Flinkå¤„ç†ç”¨æˆ·è¡Œä¸ºæµ
 * @author erik.zhou
 */
public class RealtimeFeatureCalculator {
    
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment
            .getExecutionEnvironment();
        
        // 1. è¯»å–ç”¨æˆ·è¡Œä¸ºæµ
        DataStream<UserBehavior> behaviorStream = env
            .addSource(new FlinkKafkaConsumer<>(
                "user-behavior",
                new UserBehaviorSchema(),
                getKafkaProperties()
            ));
        
        // 2. è®¡ç®—ç”¨æˆ·å®æ—¶ç‰¹å¾
        DataStream<UserFeature> userFeatures = behaviorStream
            .keyBy(UserBehavior::getUserId)
            .window(TumblingEventTimeWindows.of(Time.minutes(5)))
            .aggregate(new UserFeatureAggregator());
        
        // 3. è®¡ç®—å•†å“å®æ—¶ç‰¹å¾
        DataStream<ItemFeature> itemFeatures = behaviorStream
            .keyBy(UserBehavior::getItemId)
            .window(TumblingEventTimeWindows.of(Time.minutes(5)))
            .aggregate(new ItemFeatureAggregator());
        
        // 4. å†™å…¥Redis
        userFeatures.addSink(new RedisSink<>(getUserFeatureConfig()));
        itemFeatures.addSink(new RedisSink<>(getItemFeatureConfig()));
        
        env.execute("Realtime Feature Calculator");
    }
    
    /**
     * ç”¨æˆ·ç‰¹å¾èšåˆå™¨
     */
    static class UserFeatureAggregator 
        implements AggregateFunction<UserBehavior, UserFeatureAccumulator, UserFeature> {
        
        @Override
        public UserFeatureAccumulator createAccumulator() {
            return new UserFeatureAccumulator();
        }
        
        @Override
        public UserFeatureAccumulator add(UserBehavior behavior, 
                                         UserFeatureAccumulator acc) {
            // ç´¯åŠ è¡Œä¸ºç»Ÿè®¡
            acc.setUserId(behavior.getUserId());
            acc.incrementViewCount();
            
            if ("click".equals(behavior.getBehaviorType())) {
                acc.incrementClickCount();
            } else if ("cart".equals(behavior.getBehaviorType())) {
                acc.incrementCartCount();
            } else if ("buy".equals(behavior.getBehaviorType())) {
                acc.incrementBuyCount();
            }
            
            // è®°å½•æµè§ˆçš„ç±»ç›®
            acc.addCategory(behavior.getCategoryId());
            
            // è®°å½•æµè§ˆçš„å“ç‰Œ
            acc.addBrand(behavior.getBrandId());
            
            return acc;
        }
        
        @Override
        public UserFeature getResult(UserFeatureAccumulator acc) {
            UserFeature feature = new UserFeature();
            feature.setUserId(acc.getUserId());
            
            // åŸºç¡€ç»Ÿè®¡ç‰¹å¾
            feature.setViewCount(acc.getViewCount());
            feature.setClickCount(acc.getClickCount());
            feature.setCartCount(acc.getCartCount());
            feature.setBuyCount(acc.getBuyCount());
            
            // è®¡ç®—è½¬åŒ–ç‡
            feature.setClickRate(
                (double) acc.getClickCount() / acc.getViewCount());
            feature.setCartRate(
                (double) acc.getCartCount() / acc.getClickCount());
            feature.setBuyRate(
                (double) acc.getBuyCount() / acc.getCartCount());
            
            // åå¥½ç±»ç›®ï¼ˆTop 5ï¼‰
            feature.setPreferCategories(
                acc.getCategoryCount().entrySet().stream()
                    .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                    .limit(5)
                    .map(Map.Entry::getKey)
                    .collect(Collectors.toList())
            );
            
            // åå¥½å“ç‰Œï¼ˆTop 5ï¼‰
            feature.setPreferBrands(
                acc.getBrandCount().entrySet().stream()
                    .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                    .limit(5)
                    .map(Map.Entry::getKey)
                    .collect(Collectors.toList())
            );
            
            feature.setUpdateTime(System.currentTimeMillis());
            
            return feature;
        }
        
        @Override
        public UserFeatureAccumulator merge(UserFeatureAccumulator a, 
                                           UserFeatureAccumulator b) {
            a.merge(b);
            return a;
        }
    }
}
```

#### 2. ç‰¹å¾å­˜å‚¨æœåŠ¡

```java
/**
 * ç‰¹å¾å­˜å‚¨æœåŠ¡
 * @author erik.zhou
 */
@Service
public class FeatureStoreService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private FeatureRepository featureRepository;
    
    /**
     * è·å–ç”¨æˆ·ç‰¹å¾
     * å®æ—¶ç‰¹å¾ + ç¦»çº¿ç‰¹å¾
     */
    public UserFeature getUserFeature(String userId) {
        // 1. è·å–å®æ—¶ç‰¹å¾ï¼ˆRedisï¼‰
        UserFeature realtimeFeature = getRealtimeUserFeature(userId);
        
        // 2. è·å–ç¦»çº¿ç‰¹å¾ï¼ˆMySQLï¼‰
        UserFeature offlineFeature = getOfflineUserFeature(userId);
        
        // 3. åˆå¹¶ç‰¹å¾
        return mergeUserFeature(realtimeFeature, offlineFeature);
    }
    
    /**
     * è·å–å®æ—¶ç”¨æˆ·ç‰¹å¾
     */
    private UserFeature getRealtimeUserFeature(String userId) {
        String key = "feature:user:realtime:" + userId;
        return (UserFeature) redisTemplate.opsForValue().get(key);
    }
    
    /**
     * è·å–ç¦»çº¿ç”¨æˆ·ç‰¹å¾
     */
    private UserFeature getOfflineUserFeature(String userId) {
        return featureRepository.findUserFeature(userId);
    }
    
    /**
     * åˆå¹¶ç”¨æˆ·ç‰¹å¾
     */
    private UserFeature mergeUserFeature(UserFeature realtime, UserFeature offline) {
        if (realtime == null && offline == null) {
            return new UserFeature(); // è¿”å›é»˜è®¤ç‰¹å¾
        }
        
        if (realtime == null) {
            return offline;
        }
        
        if (offline == null) {
            return realtime;
        }
        
        // åˆå¹¶ç‰¹å¾
        UserFeature merged = new UserFeature();
        merged.setUserId(realtime.getUserId());
        
        // å®æ—¶ç‰¹å¾ä¼˜å…ˆ
        merged.setViewCount(realtime.getViewCount());
        merged.setClickCount(realtime.getClickCount());
        merged.setCartCount(realtime.getCartCount());
        merged.setBuyCount(realtime.getBuyCount());
        merged.setClickRate(realtime.getClickRate());
        merged.setCartRate(realtime.getCartRate());
        merged.setBuyRate(realtime.getBuyRate());
        
        // åˆå¹¶åå¥½ç±»ç›®
        Set<String> categories = new HashSet<>();
        if (realtime.getPreferCategories() != null) {
            categories.addAll(realtime.getPreferCategories());
        }
        if (offline.getPreferCategories() != null) {
            categories.addAll(offline.getPreferCategories());
        }
        merged.setPreferCategories(new ArrayList<>(categories));
        
        // ä½¿ç”¨ç¦»çº¿ç‰¹å¾çš„é•¿æœŸç»Ÿè®¡
        merged.setTotalOrderCount(offline.getTotalOrderCount());
        merged.setTotalOrderAmount(offline.getTotalOrderAmount());
        merged.setAvgOrderAmount(offline.getAvgOrderAmount());
        merged.setUserLevel(offline.getUserLevel());
        
        return merged;
    }
    
    /**
     * è·å–å•†å“ç‰¹å¾
     */
    public ItemFeature getItemFeature(String itemId) {
        // 1. ä»Redisè·å–å®æ—¶ç‰¹å¾
        String key = "feature:item:realtime:" + itemId;
        ItemFeature realtimeFeature = (ItemFeature) redisTemplate.opsForValue().get(key);
        
        // 2. ä»MySQLè·å–ç¦»çº¿ç‰¹å¾
        ItemFeature offlineFeature = featureRepository.findItemFeature(itemId);
        
        // 3. åˆå¹¶ç‰¹å¾
        return mergeItemFeature(realtimeFeature, offlineFeature);
    }
    
    /**
     * æ‰¹é‡è·å–å•†å“ç‰¹å¾
     */
    public Map<String, ItemFeature> batchGetItemFeatures(List<String> itemIds) {
        // ä½¿ç”¨Pipelineæ‰¹é‡è·å–
        List<Object> results = redisTemplate.executePipelined(
            (RedisCallback<Object>) connection -> {
                itemIds.forEach(itemId -> {
                    String key = "feature:item:realtime:" + itemId;
                    connection.get(key.getBytes());
                });
                return null;
            }
        );
        
        Map<String, ItemFeature> features = new HashMap<>();
        for (int i = 0; i < itemIds.size(); i++) {
            if (results.get(i) != null) {
                features.put(itemIds.get(i), (ItemFeature) results.get(i));
            }
        }
        
        return features;
    }
}
```

#### 3. ç‰¹å¾å·¥ç¨‹

```java
/**
 * ç‰¹å¾å·¥ç¨‹æœåŠ¡
 * @author erik.zhou
 */
@Service
public class FeatureEngineeringService {
    
    @Autowired
    private FeatureStoreService featureStoreService;
    
    /**
     * æ„å»ºæ¨èç‰¹å¾
     * ç”¨æˆ·ç‰¹å¾ + å•†å“ç‰¹å¾ + äº¤å‰ç‰¹å¾
     */
    public RecommendFeature buildFeature(String userId, String itemId) {
        // 1. è·å–ç”¨æˆ·ç‰¹å¾
        UserFeature userFeature = featureStoreService.getUserFeature(userId);
        
        // 2. è·å–å•†å“ç‰¹å¾
        ItemFeature itemFeature = featureStoreService.getItemFeature(itemId);
        
        // 3. æ„å»ºäº¤å‰ç‰¹å¾
        RecommendFeature feature = new RecommendFeature();
        
        // ç”¨æˆ·ç‰¹å¾
        feature.setUserViewCount(userFeature.getViewCount());
        feature.setUserClickRate(userFeature.getClickRate());
        feature.setUserCartRate(userFeature.getCartRate());
        feature.setUserBuyRate(userFeature.getBuyRate());
        feature.setUserLevel(userFeature.getUserLevel());
        feature.setUserAvgOrderAmount(userFeature.getAvgOrderAmount());
        
        // å•†å“ç‰¹å¾
        feature.setItemPrice(itemFeature.getPrice());
        feature.setItemSales(itemFeature.getSales());
        feature.setItemClickRate(itemFeature.getClickRate());
        feature.setItemConversionRate(itemFeature.getConversionRate());
        feature.setItemScore(itemFeature.getScore());
        feature.setItemCommentCount(itemFeature.getCommentCount());
        
        // äº¤å‰ç‰¹å¾
        // 1. ä»·æ ¼åŒ¹é…åº¦
        feature.setPriceMatch(calculatePriceMatch(
            userFeature.getAvgOrderAmount(), itemFeature.getPrice()));
        
        // 2. ç±»ç›®åŒ¹é…åº¦
        feature.setCategoryMatch(calculateCategoryMatch(
            userFeature.getPreferCategories(), itemFeature.getCategoryId()));
        
        // 3. å“ç‰ŒåŒ¹é…åº¦
        feature.setBrandMatch(calculateBrandMatch(
            userFeature.getPreferBrands(), itemFeature.getBrandId()));
        
        // 4. æ—¶é—´ç‰¹å¾
        feature.setHour(LocalDateTime.now().getHour());
        feature.setDayOfWeek(LocalDateTime.now().getDayOfWeek().getValue());
        
        return feature;
    }
    
    /**
     * è®¡ç®—ä»·æ ¼åŒ¹é…åº¦
     */
    private double calculatePriceMatch(double avgOrderAmount, double itemPrice) {
        if (avgOrderAmount == 0) {
            return 0.5;
        }
        
        double ratio = itemPrice / avgOrderAmount;
        
        // ä»·æ ¼åœ¨å¹³å‡è®¢å•é‡‘é¢çš„0.5-2å€ä¹‹é—´ï¼ŒåŒ¹é…åº¦è¾ƒé«˜
        if (ratio >= 0.5 && ratio <= 2.0) {
            return 1.0 - Math.abs(ratio - 1.0) / 1.5;
        } else {
            return 0.3;
        }
    }
    
    /**
     * è®¡ç®—ç±»ç›®åŒ¹é…åº¦
     */
    private double calculateCategoryMatch(List<String> preferCategories, 
                                         String itemCategory) {
        if (preferCategories == null || preferCategories.isEmpty()) {
            return 0.5;
        }
        
        // æ£€æŸ¥æ˜¯å¦åœ¨åå¥½ç±»ç›®ä¸­
        int index = preferCategories.indexOf(itemCategory);
        if (index >= 0) {
            // æ’åè¶Šé å‰ï¼ŒåŒ¹é…åº¦è¶Šé«˜
            return 1.0 - (index * 0.15);
        }
        
        return 0.3;
    }
    
    /**
     * è®¡ç®—å“ç‰ŒåŒ¹é…åº¦
     */
    private double calculateBrandMatch(List<String> preferBrands, String itemBrand) {
        if (preferBrands == null || preferBrands.isEmpty()) {
            return 0.5;
        }
        
        int index = preferBrands.indexOf(itemBrand);
        if (index >= 0) {
            return 1.0 - (index * 0.15);
        }
        
        return 0.3;
    }
    
    /**
     * æ‰¹é‡æ„å»ºç‰¹å¾
     */
    public List<RecommendFeature> batchBuildFeatures(String userId, 
                                                     List<String> itemIds) {
        // 1. è·å–ç”¨æˆ·ç‰¹å¾
        UserFeature userFeature = featureStoreService.getUserFeature(userId);
        
        // 2. æ‰¹é‡è·å–å•†å“ç‰¹å¾
        Map<String, ItemFeature> itemFeatures = featureStoreService
            .batchGetItemFeatures(itemIds);
        
        // 3. å¹¶è¡Œæ„å»ºç‰¹å¾
        return itemIds.parallelStream()
            .map(itemId -> {
                ItemFeature itemFeature = itemFeatures.get(itemId);
                if (itemFeature == null) {
                    return null;
                }
                return buildFeatureInternal(userFeature, itemFeature);
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }
}
```

---

## ğŸ¯ æŠ€æœ¯éš¾ç‚¹2: å¤šè·¯å¬å›èåˆ

### é—®é¢˜åœºæ™¯
- éœ€è¦å¤šç§å¬å›ç­–ç•¥ä¿è¯æ¨èå¤šæ ·æ€§
- ä¸åŒå¬å›ç­–ç•¥çš„ç»“æœéœ€è¦å»é‡å’Œèåˆ
- å¬å›è¦å¿«é€Ÿï¼ˆ<50msï¼‰
- å¬å›ç»“æœè¦ä¿è¯è´¨é‡

### è§£å†³æ–¹æ¡ˆ

#### 1. å¤šè·¯å¬å›ç­–ç•¥

```java
/**
 * æ¨èå¬å›æœåŠ¡
 * @author erik.zhou
 */
@Service
public class RecallService {
    
    @Autowired
    private CollaborativeFilteringRecall cfRecall;
    
    @Autowired
    private ContentBasedRecall contentRecall;
    
    @Autowired
    private HotItemRecall hotRecall;
    
    @Autowired
    private UserProfileRecall profileRecall;
    
    /**
     * å¤šè·¯å¬å›
     */
    public List<RecallItem> multiRecall(String userId, int totalSize) {
        // 1. å¹¶è¡Œæ‰§è¡Œå¤šè·¯å¬å›
        CompletableFuture<List<RecallItem>> cfFuture = CompletableFuture
            .supplyAsync(() -> cfRecall.recall(userId, 200));
        
        CompletableFuture<List<RecallItem>> contentFuture = CompletableFuture
            .supplyAsync(() -> contentRecall.recall(userId, 200));
        
        CompletableFuture<List<RecallItem>> hotFuture = CompletableFuture
            .supplyAsync(() -> hotRecall.recall(userId, 100));
        
        CompletableFuture<List<RecallItem>> profileFuture = CompletableFuture
            .supplyAsync(() -> profileRecall.recall(userId, 100));
        
        // 2. ç­‰å¾…æ‰€æœ‰å¬å›å®Œæˆ
        CompletableFuture.allOf(cfFuture, contentFuture, hotFuture, profileFuture)
            .join();
        
        // 3. åˆå¹¶å¬å›ç»“æœ
        List<RecallItem> allItems = new ArrayList<>();
        try {
            allItems.addAll(cfFuture.get());
            allItems.addAll(contentFuture.get());
            allItems.addAll(hotFuture.get());
            allItems.addAll(profileFuture.get());
        } catch (Exception e) {
            log.error("å¬å›å¤±è´¥", e);
        }
        
        // 4. å»é‡å’Œèåˆ
        List<RecallItem> mergedItems = mergeAndDedup(allItems);
        
        // 5. æˆªå–Top N
        return mergedItems.stream()
            .limit(totalSize)
            .collect(Collectors.toList());
    }
    
    /**
     * åˆå¹¶å’Œå»é‡
     */
    private List<RecallItem> mergeAndDedup(List<RecallItem> items) {
        // æŒ‰å•†å“IDåˆ†ç»„
        Map<String, List<RecallItem>> grouped = items.stream()
            .collect(Collectors.groupingBy(RecallItem::getItemId));
        
        // åˆå¹¶åŒä¸€å•†å“çš„å¤šä¸ªå¬å›ç»“æœ
        return grouped.entrySet().stream()
            .map(entry -> mergeRecallItems(entry.getValue()))
            .sorted(Comparator.comparing(RecallItem::getScore).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * åˆå¹¶å¬å›é¡¹
     */
    private RecallItem mergeRecallItems(List<RecallItem> items) {
        RecallItem merged = new RecallItem();
        merged.setItemId(items.get(0).getItemId());
        
        // åˆå¹¶åˆ†æ•°ï¼ˆåŠ æƒå¹³å‡ï¼‰
        double totalScore = 0;
        double totalWeight = 0;
        
        for (RecallItem item : items) {
            double weight = getRecallWeight(item.getRecallType());
            totalScore += item.getScore() * weight;
            totalWeight += weight;
        }
        
        merged.setScore(totalScore / totalWeight);
        
        // è®°å½•å¬å›æ¥æº
        merged.setRecallTypes(items.stream()
            .map(RecallItem::getRecallType)
            .collect(Collectors.toList()));
        
        return merged;
    }
    
    /**
     * è·å–å¬å›æƒé‡
     */
    private double getRecallWeight(RecallType type) {
        switch (type) {
            case COLLABORATIVE_FILTERING:
                return 0.4;
            case CONTENT_BASED:
                return 0.3;
            case HOT_ITEM:
                return 0.2;
            case USER_PROFILE:
                return 0.1;
            default:
                return 0.1;
        }
    }
}
```


#### 2. ååŒè¿‡æ»¤å¬å›

```java
/**
 * ååŒè¿‡æ»¤å¬å›
 * åŸºäºç”¨æˆ·è¡Œä¸ºçš„ååŒè¿‡æ»¤
 * @author erik.zhou
 */
@Service
public class CollaborativeFilteringRecall {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * å¬å›å•†å“
     * åŸºäºç”¨æˆ·-å•†å“ååŒè¿‡æ»¤
     */
    public List<RecallItem> recall(String userId, int size) {
        // 1. è·å–ç”¨æˆ·æœ€è¿‘æµè§ˆçš„å•†å“
        List<String> recentItems = getUserRecentItems(userId, 20);
        
        if (recentItems.isEmpty()) {
            return Collections.emptyList();
        }
        
        // 2. æ‰¾åˆ°ç›¸ä¼¼å•†å“
        Map<String, Double> similarItems = new HashMap<>();
        
        for (String itemId : recentItems) {
            // è·å–å•†å“çš„ç›¸ä¼¼å•†å“åˆ—è¡¨
            Map<String, Double> similar = getItemSimilarItems(itemId, 50);
            
            // åˆå¹¶ç›¸ä¼¼å•†å“
            similar.forEach((id, score) -> {
                similarItems.merge(id, score, Double::sum);
            });
        }
        
        // 3. è¿‡æ»¤å·²æµè§ˆå•†å“
        similarItems.keySet().removeAll(recentItems);
        
        // 4. æ’åºå¹¶è¿”å›Top N
        return similarItems.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(size)
            .map(entry -> {
                RecallItem item = new RecallItem();
                item.setItemId(entry.getKey());
                item.setScore(entry.getValue());
                item.setRecallType(RecallType.COLLABORATIVE_FILTERING);
                return item;
            })
            .collect(Collectors.toList());
    }
    
    /**
     * è·å–ç”¨æˆ·æœ€è¿‘æµè§ˆçš„å•†å“
     */
    private List<String> getUserRecentItems(String userId, int limit) {
        String key = "user:recent:items:" + userId;
        List<Object> items = redisTemplate.opsForList().range(key, 0, limit - 1);
        
        if (items == null) {
            return Collections.emptyList();
        }
        
        return items.stream()
            .map(Object::toString)
            .collect(Collectors.toList());
    }
    
    /**
     * è·å–å•†å“çš„ç›¸ä¼¼å•†å“
     * ä½¿ç”¨é¢„è®¡ç®—çš„å•†å“ç›¸ä¼¼åº¦çŸ©é˜µ
     */
    private Map<String, Double> getItemSimilarItems(String itemId, int limit) {
        String key = "item:similar:" + itemId;
        
        // ä»Redisçš„Sorted Setè·å–ç›¸ä¼¼å•†å“
        Set<ZSetOperations.TypedTuple<Object>> tuples = redisTemplate
            .opsForZSet()
            .reverseRangeWithScores(key, 0, limit - 1);
        
        if (tuples == null) {
            return Collections.emptyMap();
        }
        
        return tuples.stream()
            .collect(Collectors.toMap(
                tuple -> tuple.getValue().toString(),
                tuple -> tuple.getScore()
            ));
    }
}
```

#### 3. å†…å®¹æ¨èå¬å›

```java
/**
 * å†…å®¹æ¨èå¬å›
 * åŸºäºå•†å“å†…å®¹çš„æ¨è
 * @author erik.zhou
 */
@Service
public class ContentBasedRecall {
    
    @Autowired
    private ElasticsearchClient esClient;
    
    @Autowired
    private FeatureStoreService featureStoreService;
    
    /**
     * å¬å›å•†å“
     * åŸºäºç”¨æˆ·åå¥½çš„å†…å®¹æ¨è
     */
    public List<RecallItem> recall(String userId, int size) {
        // 1. è·å–ç”¨æˆ·ç‰¹å¾
        UserFeature userFeature = featureStoreService.getUserFeature(userId);
        
        if (userFeature == null) {
            return Collections.emptyList();
        }
        
        // 2. æ„å»ºESæŸ¥è¯¢
        SearchRequest request = buildSearchRequest(userFeature, size);
        
        try {
            // 3. æ‰§è¡ŒæŸ¥è¯¢
            SearchResponse response = esClient.search(request, RequestOptions.DEFAULT);
            
            // 4. è§£æç»“æœ
            return parseSearchResponse(response);
            
        } catch (Exception e) {
            log.error("ESæŸ¥è¯¢å¤±è´¥", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * æ„å»ºESæŸ¥è¯¢
     */
    private SearchRequest buildSearchRequest(UserFeature userFeature, int size) {
        SearchRequest request = new SearchRequest("items");
        
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // 1. åå¥½ç±»ç›®
        if (userFeature.getPreferCategories() != null && 
            !userFeature.getPreferCategories().isEmpty()) {
            boolQuery.should(QueryBuilders.termsQuery(
                "categoryId", userFeature.getPreferCategories())
                .boost(2.0f));
        }
        
        // 2. åå¥½å“ç‰Œ
        if (userFeature.getPreferBrands() != null && 
            !userFeature.getPreferBrands().isEmpty()) {
            boolQuery.should(QueryBuilders.termsQuery(
                "brandId", userFeature.getPreferBrands())
                .boost(1.5f));
        }
        
        // 3. ä»·æ ¼èŒƒå›´
        double avgPrice = userFeature.getAvgOrderAmount();
        if (avgPrice > 0) {
            boolQuery.should(QueryBuilders.rangeQuery("price")
                .gte(avgPrice * 0.5)
                .lte(avgPrice * 2.0)
                .boost(1.0f));
        }
        
        // 4. è¿‡æ»¤æ¡ä»¶
        boolQuery.filter(QueryBuilders.termQuery("status", "online"));
        boolQuery.filter(QueryBuilders.rangeQuery("stock").gt(0));
        
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        sourceBuilder.query(boolQuery);
        sourceBuilder.size(size);
        
        // 5. æ’åº
        sourceBuilder.sort("_score", SortOrder.DESC);
        sourceBuilder.sort("sales", SortOrder.DESC);
        
        request.source(sourceBuilder);
        
        return request;
    }
    
    /**
     * è§£ææœç´¢ç»“æœ
     */
    private List<RecallItem> parseSearchResponse(SearchResponse response) {
        return Arrays.stream(response.getHits().getHits())
            .map(hit -> {
                RecallItem item = new RecallItem();
                item.setItemId(hit.getId());
                item.setScore(hit.getScore());
                item.setRecallType(RecallType.CONTENT_BASED);
                return item;
            })
            .collect(Collectors.toList());
    }
}
```

#### 4. çƒ­é—¨å•†å“å¬å›

```java
/**
 * çƒ­é—¨å•†å“å¬å›
 * @author erik.zhou
 */
@Service
public class HotItemRecall {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * å¬å›çƒ­é—¨å•†å“
     */
    public List<RecallItem> recall(String userId, int size) {
        // 1. è·å–ç”¨æˆ·åå¥½ç±»ç›®
        List<String> preferCategories = getUserPreferCategories(userId);
        
        List<RecallItem> items = new ArrayList<>();
        
        if (!preferCategories.isEmpty()) {
            // 2. è·å–ç±»ç›®çƒ­é—¨å•†å“
            for (String category : preferCategories) {
                List<RecallItem> categoryHotItems = getCategoryHotItems(category, size / 2);
                items.addAll(categoryHotItems);
            }
        }
        
        // 3. è¡¥å……å…¨å±€çƒ­é—¨å•†å“
        if (items.size() < size) {
            List<RecallItem> globalHotItems = getGlobalHotItems(size - items.size());
            items.addAll(globalHotItems);
        }
        
        // 4. å»é‡å¹¶è¿”å›
        return items.stream()
            .collect(Collectors.toMap(
                RecallItem::getItemId,
                item -> item,
                (item1, item2) -> item1.getScore() > item2.getScore() ? item1 : item2
            ))
            .values().stream()
            .limit(size)
            .collect(Collectors.toList());
    }
    
    /**
     * è·å–ç±»ç›®çƒ­é—¨å•†å“
     */
    private List<RecallItem> getCategoryHotItems(String category, int size) {
        String key = "hot:items:category:" + category;
        
        Set<ZSetOperations.TypedTuple<Object>> tuples = redisTemplate
            .opsForZSet()
            .reverseRangeWithScores(key, 0, size - 1);
        
        if (tuples == null) {
            return Collections.emptyList();
        }
        
        return tuples.stream()
            .map(tuple -> {
                RecallItem item = new RecallItem();
                item.setItemId(tuple.getValue().toString());
                item.setScore(tuple.getScore());
                item.setRecallType(RecallType.HOT_ITEM);
                return item;
            })
            .collect(Collectors.toList());
    }
    
    /**
     * è·å–å…¨å±€çƒ­é—¨å•†å“
     */
    private List<RecallItem> getGlobalHotItems(int size) {
        String key = "hot:items:global";
        
        Set<ZSetOperations.TypedTuple<Object>> tuples = redisTemplate
            .opsForZSet()
            .reverseRangeWithScores(key, 0, size - 1);
        
        if (tuples == null) {
            return Collections.emptyList();
        }
        
        return tuples.stream()
            .map(tuple -> {
                RecallItem item = new RecallItem();
                item.setItemId(tuple.getValue().toString());
                item.setScore(tuple.getScore());
                item.setRecallType(RecallType.HOT_ITEM);
                return item;
            })
            .collect(Collectors.toList());
    }
}
```

---

## ğŸ¯ æŠ€æœ¯éš¾ç‚¹3: æ¨¡å‹åœ¨çº¿æœåŠ¡

### é—®é¢˜åœºæ™¯
- æ·±åº¦å­¦ä¹ æ¨¡å‹æ¨ç†è¦å¿«ï¼ˆ<10msï¼‰
- æ¨¡å‹è¦æ”¯æŒçƒ­æ›´æ–°ï¼Œä¸èƒ½åœæœ
- è¦æ”¯æŒA/Bæµ‹è¯•ï¼Œå¯¹æ¯”ä¸åŒæ¨¡å‹æ•ˆæœ
- æ¨¡å‹æœåŠ¡è¦é«˜å¯ç”¨

### è§£å†³æ–¹æ¡ˆ

#### 1. æ¨¡å‹æœåŠ¡

```java
/**
 * æ’åºæ¨¡å‹æœåŠ¡
 * @author erik.zhou
 */
@Service
public class RankingModelService {
    
    private volatile SavedModelBundle model;
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    
    @PostConstruct
    public void init() {
        // åŠ è½½æ¨¡å‹
        loadModel();
        
        // ç›‘å¬æ¨¡å‹æ›´æ–°
        watchModelUpdate();
    }
    
    /**
     * åŠ è½½æ¨¡å‹
     */
    private void loadModel() {
        lock.writeLock().lock();
        try {
            String modelPath = getModelPath();
            this.model = SavedModelBundle.load(modelPath, "serve");
            log.info("æ¨¡å‹åŠ è½½æˆåŠŸ: {}", modelPath);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * é¢„æµ‹
     */
    public List<RankingResult> predict(String userId, List<String> itemIds) {
        // 1. æ„å»ºç‰¹å¾
        List<RecommendFeature> features = buildFeatures(userId, itemIds);
        
        // 2. æ‰¹é‡é¢„æµ‹
        float[][] predictions = batchPredict(features);
        
        // 3. æ„å»ºç»“æœ
        List<RankingResult> results = new ArrayList<>();
        for (int i = 0; i < itemIds.size(); i++) {
            RankingResult result = new RankingResult();
            result.setItemId(itemIds.get(i));
            result.setScore(predictions[i][0]);
            results.add(result);
        }
        
        // 4. æ’åº
        results.sort(Comparator.comparing(RankingResult::getScore).reversed());
        
        return results;
    }
    
    /**
     * æ‰¹é‡é¢„æµ‹
     */
    private float[][] batchPredict(List<RecommendFeature> features) {
        lock.readLock().lock();
        try {
            // 1. æ„å»ºè¾“å…¥Tensor
            Tensor<?> inputTensor = buildInputTensor(features);
            
            // 2. æ‰§è¡Œé¢„æµ‹
            Session session = model.session();
            List<Tensor<?>> outputs = session.runner()
                .feed("input", inputTensor)
                .fetch("output")
                .run();
            
            // 3. è§£æè¾“å‡º
            Tensor<?> outputTensor = outputs.get(0);
            float[][] predictions = new float[features.size()][1];
            outputTensor.copyTo(predictions);
            
            // 4. é‡Šæ”¾èµ„æº
            inputTensor.close();
            outputTensor.close();
            
            return predictions;
            
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * æ„å»ºè¾“å…¥Tensor
     */
    private Tensor<?> buildInputTensor(List<RecommendFeature> features) {
        int batchSize = features.size();
        int featureSize = getFeatureSize();
        
        float[][] input = new float[batchSize][featureSize];
        
        for (int i = 0; i < batchSize; i++) {
            input[i] = featureToArray(features.get(i));
        }
        
        return Tensor.create(input);
    }
    
    /**
     * ç‰¹å¾è½¬æ•°ç»„
     */
    private float[] featureToArray(RecommendFeature feature) {
        return new float[] {
            // ç”¨æˆ·ç‰¹å¾
            (float) feature.getUserViewCount(),
            (float) feature.getUserClickRate(),
            (float) feature.getUserCartRate(),
            (float) feature.getUserBuyRate(),
            (float) feature.getUserLevel(),
            (float) feature.getUserAvgOrderAmount(),
            
            // å•†å“ç‰¹å¾
            (float) feature.getItemPrice(),
            (float) feature.getItemSales(),
            (float) feature.getItemClickRate(),
            (float) feature.getItemConversionRate(),
            (float) feature.getItemScore(),
            (float) feature.getItemCommentCount(),
            
            // äº¤å‰ç‰¹å¾
            (float) feature.getPriceMatch(),
            (float) feature.getCategoryMatch(),
            (float) feature.getBrandMatch(),
            (float) feature.getHour(),
            (float) feature.getDayOfWeek()
        };
    }
    
    /**
     * ç›‘å¬æ¨¡å‹æ›´æ–°
     */
    private void watchModelUpdate() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        scheduler.scheduleAtFixedRate(() -> {
            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ¨¡å‹
                if (hasNewModel()) {
                    log.info("æ£€æµ‹åˆ°æ–°æ¨¡å‹ï¼Œå¼€å§‹çƒ­æ›´æ–°");
                    loadModel();
                }
            } catch (Exception e) {
                log.error("æ¨¡å‹æ›´æ–°å¤±è´¥", e);
            }
        }, 1, 1, TimeUnit.MINUTES);
    }
}
```

#### 2. A/Bæµ‹è¯•

```java
/**
 * A/Bæµ‹è¯•æœåŠ¡
 * @author erik.zhou
 */
@Service
public class ABTestService {
    
    @Autowired
    private RankingModelService modelService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * è·å–æ¨èç»“æœ
     * æ ¹æ®A/Bæµ‹è¯•åˆ†æµ
     */
    public List<RankingResult> getRecommendations(String userId, 
                                                  List<String> itemIds) {
        // 1. è·å–ç”¨æˆ·åˆ†ç»„
        String group = getUserGroup(userId);
        
        // 2. æ ¹æ®åˆ†ç»„é€‰æ‹©æ¨¡å‹
        switch (group) {
            case "A":
                return modelService.predictWithModelA(userId, itemIds);
            case "B":
                return modelService.predictWithModelB(userId, itemIds);
            default:
                return modelService.predict(userId, itemIds);
        }
    }
    
    /**
     * è·å–ç”¨æˆ·åˆ†ç»„
     */
    private String getUserGroup(String userId) {
        // 1. ä»Redisè·å–ç¼“å­˜çš„åˆ†ç»„
        String key = "abtest:user:group:" + userId;
        String group = (String) redisTemplate.opsForValue().get(key);
        
        if (group != null) {
            return group;
        }
        
        // 2. è®¡ç®—åˆ†ç»„
        group = calculateUserGroup(userId);
        
        // 3. ç¼“å­˜åˆ†ç»„
        redisTemplate.opsForValue().set(key, group, 7, TimeUnit.DAYS);
        
        return group;
    }
    
    /**
     * è®¡ç®—ç”¨æˆ·åˆ†ç»„
     * ä½¿ç”¨ç”¨æˆ·IDçš„hashå€¼è¿›è¡Œåˆ†æµ
     */
    private String calculateUserGroup(String userId) {
        int hash = Math.abs(userId.hashCode());
        int mod = hash % 100;
        
        // Aç»„50%ï¼ŒBç»„50%
        if (mod < 50) {
            return "A";
        } else {
            return "B";
        }
    }
    
    /**
     * è®°å½•æ¨èç»“æœ
     * ç”¨äºA/Bæµ‹è¯•æ•ˆæœåˆ†æ
     */
    public void recordRecommendation(String userId, String group, 
                                    List<String> itemIds) {
        RecommendRecord record = new RecommendRecord();
        record.setUserId(userId);
        record.setGroup(group);
        record.setItemIds(itemIds);
        record.setTimestamp(System.currentTimeMillis());
        
        // å¼‚æ­¥ä¿å­˜
        CompletableFuture.runAsync(() -> {
            recommendRecordRepository.save(record);
        });
    }
    
    /**
     * è®°å½•ç”¨æˆ·è¡Œä¸º
     * ç”¨äºè®¡ç®—A/Bæµ‹è¯•æŒ‡æ ‡
     */
    public void recordUserBehavior(String userId, String itemId, 
                                   String behaviorType) {
        // è·å–ç”¨æˆ·åˆ†ç»„
        String group = getUserGroup(userId);
        
        // è®°å½•è¡Œä¸º
        UserBehaviorRecord record = new UserBehaviorRecord();
        record.setUserId(userId);
        record.setItemId(itemId);
        record.setBehaviorType(behaviorType);
        record.setGroup(group);
        record.setTimestamp(System.currentTimeMillis());
        
        // å¼‚æ­¥ä¿å­˜
        CompletableFuture.runAsync(() -> {
            userBehaviorRepository.save(record);
        });
    }
}
```

#### 3. æ¨èæœåŠ¡

```java
/**
 * æ¨èæœåŠ¡
 * æ•´åˆå¬å›ã€æ’åºã€è¿‡æ»¤
 * @author erik.zhou
 */
@Service
public class RecommendService {
    
    @Autowired
    private RecallService recallService;
    
    @Autowired
    private RankingModelService rankingService;
    
    @Autowired
    private ABTestService abTestService;
    
    @Autowired
    private BloomFilterService bloomFilterService;
    
    /**
     * è·å–æ¨èåˆ—è¡¨
     */
    public List<RecommendItem> recommend(String userId, int size) {
        try {
            // 1. å¤šè·¯å¬å›
            List<RecallItem> recallItems = recallService.multiRecall(userId, size * 10);
            
            if (recallItems.isEmpty()) {
                return Collections.emptyList();
            }
            
            // 2. è¿‡æ»¤
            List<RecallItem> filteredItems = filter(userId, recallItems);
            
            // 3. æ’åº
            List<String> itemIds = filteredItems.stream()
                .map(RecallItem::getItemId)
                .collect(Collectors.toList());
            
            List<RankingResult> rankingResults = abTestService
                .getRecommendations(userId, itemIds);
            
            // 4. æ„å»ºæ¨èç»“æœ
            List<RecommendItem> recommendItems = rankingResults.stream()
                .limit(size)
                .map(result -> buildRecommendItem(result))
                .collect(Collectors.toList());
            
            // 5. è®°å½•æ¨èç»“æœ
            String group = abTestService.getUserGroup(userId);
            abTestService.recordRecommendation(userId, group, 
                recommendItems.stream()
                    .map(RecommendItem::getItemId)
                    .collect(Collectors.toList()));
            
            return recommendItems;
            
        } catch (Exception e) {
            log.error("æ¨èå¤±è´¥: userId={}", userId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * è¿‡æ»¤
     */
    private List<RecallItem> filter(String userId, List<RecallItem> items) {
        return items.stream()
            .filter(item -> {
                // 1. è¿‡æ»¤å·²è´­ä¹°å•†å“
                if (bloomFilterService.hasBought(userId, item.getItemId())) {
                    return false;
                }
                
                // 2. è¿‡æ»¤æœ€è¿‘å·²æ¨èå•†å“
                if (bloomFilterService.hasRecommended(userId, item.getItemId())) {
                    return false;
                }
                
                // 3. è¿‡æ»¤ä¸‹æ¶å•†å“
                if (!isItemOnline(item.getItemId())) {
                    return false;
                }
                
                return true;
            })
            .collect(Collectors.toList());
    }
    
    /**
     * æ„å»ºæ¨èé¡¹
     */
    private RecommendItem buildRecommendItem(RankingResult result) {
        RecommendItem item = new RecommendItem();
        item.setItemId(result.getItemId());
        item.setScore(result.getScore());
        item.setReason(generateReason(result));
        return item;
    }
    
    /**
     * ç”Ÿæˆæ¨èç†ç”±
     */
    private String generateReason(RankingResult result) {
        // æ ¹æ®å¬å›ç±»å‹ç”Ÿæˆæ¨èç†ç”±
        if (result.getRecallTypes().contains(RecallType.COLLABORATIVE_FILTERING)) {
            return "çŒœä½ å–œæ¬¢";
        } else if (result.getRecallTypes().contains(RecallType.HOT_ITEM)) {
            return "çƒ­é—¨æ¨è";
        } else if (result.getRecallTypes().contains(RecallType.CONTENT_BASED)) {
            return "ä¸ºä½ ç²¾é€‰";
        } else {
            return "æ¨è";
        }
    }
}
```

---

## ğŸ“Š æ€§èƒ½æµ‹è¯•

### æµ‹è¯•ç¯å¢ƒ
- æœåŠ¡å™¨: 8æ ¸16G * 5å°
- ç”¨æˆ·æ•°: 100ä¸‡
- å•†å“æ•°: 10ä¸‡
- æ—¥æ´»ç”¨æˆ·: 10ä¸‡

### æµ‹è¯•ç»“æœ

#### 1. æ¨èæ€§èƒ½

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| QPS | 5000 |
| å¹³å‡å“åº”æ—¶é—´ | 45ms |
| P95å“åº”æ—¶é—´ | 80ms |
| P99å“åº”æ—¶é—´ | 120ms |

#### 2. å¬å›æ€§èƒ½

| å¬å›ç­–ç•¥ | è€—æ—¶ | å¬å›æ•° |
|---------|------|--------|
| ååŒè¿‡æ»¤ | 15ms | 200 |
| å†…å®¹æ¨è | 20ms | 200 |
| çƒ­é—¨æ¨è | 5ms | 100 |
| ç”¨æˆ·ç”»åƒ | 10ms | 100 |

#### 3. æ’åºæ€§èƒ½

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| æ‰¹é‡å¤§å° | 500 |
| é¢„æµ‹è€—æ—¶ | 8ms |
| ç‰¹å¾æ„å»ºè€—æ—¶ | 5ms |
| æ€»è€—æ—¶ | 13ms |

---

## ğŸ“ æœ€ä½³å®è·µ

### 1. æ¨èæ•ˆæœè¯„ä¼°

```java
/**
 * æ¨èæ•ˆæœè¯„ä¼°
 * @author erik.zhou
 */
@Service
public class RecommendEvaluationService {
    
    /**
     * è®¡ç®—ç‚¹å‡»ç‡
     */
    public double calculateCTR(String group, long startTime, long endTime) {
        // æ¨èæ¬¡æ•°
        long recommendCount = getRecommendCount(group, startTime, endTime);
        
        // ç‚¹å‡»æ¬¡æ•°
        long clickCount = getClickCount(group, startTime, endTime);
        
        return (double) clickCount / recommendCount;
    }
    
    /**
     * è®¡ç®—è½¬åŒ–ç‡
     */
    public double calculateCVR(String group, long startTime, long endTime) {
        // ç‚¹å‡»æ¬¡æ•°
        long clickCount = getClickCount(group, startTime, endTime);
        
        // è´­ä¹°æ¬¡æ•°
        long buyCount = getBuyCount(group, startTime, endTime);
        
        return (double) buyCount / clickCount;
    }
    
    /**
     * è®¡ç®—å¤šæ ·æ€§
     */
    public double calculateDiversity(List<String> itemIds) {
        // è·å–å•†å“ç±»ç›®
        Set<String> categories = itemIds.stream()
            .map(this::getItemCategory)
            .collect(Collectors.toSet());
        
        return (double) categories.size() / itemIds.size();
    }
}
```

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å®æ—¶ç‰¹å¾è®¡ç®—**
   - Flinkæµå¼å¤„ç†ç”¨æˆ·è¡Œä¸º
   - å¤šçº§ç‰¹å¾å­˜å‚¨ï¼ˆå®æ—¶+ç¦»çº¿ï¼‰
   - ç‰¹å¾å·¥ç¨‹å’Œäº¤å‰ç‰¹å¾
   - é«˜æ€§èƒ½ç‰¹å¾æŸ¥è¯¢

2. **å¤šè·¯å¬å›èåˆ**
   - ååŒè¿‡æ»¤å¬å›
   - å†…å®¹æ¨èå¬å›
   - çƒ­é—¨å•†å“å¬å›
   - å¬å›ç»“æœå»é‡å’Œèåˆ

3. **æ¨¡å‹åœ¨çº¿æœåŠ¡**
   - TensorFlowæ¨¡å‹åœ¨çº¿æ¨ç†
   - æ¨¡å‹çƒ­æ›´æ–°
   - A/Bæµ‹è¯•
   - æ¨èæ•ˆæœè¯„ä¼°

### æŠ€æœ¯æ”¶è·

- æŒæ¡äº†æ¨èç³»ç»Ÿçš„æ ¸å¿ƒæ¶æ„
- ç†è§£äº†å¬å›å’Œæ’åºçš„åŸç†
- å­¦ä¼šäº†æ·±åº¦å­¦ä¹ æ¨¡å‹çš„åœ¨çº¿æœåŠ¡
- ç§¯ç´¯äº†æ¨èç³»ç»Ÿä¼˜åŒ–ç»éªŒ

### ç”Ÿäº§ç»éªŒ

- æ¨èè¦æ³¨é‡å¤šæ ·æ€§
- ç‰¹å¾å·¥ç¨‹å¾ˆé‡è¦
- è¦æŒç»­ä¼˜åŒ–æ¨¡å‹
- A/Bæµ‹è¯•éªŒè¯æ•ˆæœ

---

**ä½œè€…**: erik.zhou  
**æœ€åæ›´æ–°**: 2024-01-04
