# Javaå¹¶å‘ç¼–ç¨‹ å®Œæ•´æ•™ç¨‹

## ğŸ“‹ ç›®å½•
- [æŠ€æœ¯æ¦‚è¿°](#æŠ€æœ¯æ¦‚è¿°)
- [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
- [åŸºç¡€æ¦‚å¿µ](#åŸºç¡€æ¦‚å¿µ)
- [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [å®æˆ˜åº”ç”¨](#å®æˆ˜åº”ç”¨)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
- [å­¦ä¹ æ£€æŸ¥æ¸…å•](#å­¦ä¹ æ£€æŸ¥æ¸…å•)

## ğŸ“š æŠ€æœ¯æ¦‚è¿°
- **ç‰ˆæœ¬**: Java 8+
- **å®˜æ–¹æ–‡æ¡£**: https://docs.oracle.com/javase/tutorial/essential/concurrency/
- **å­¦ä¹ éš¾åº¦**: â­â­â­â­â­ (5æ˜Ÿ)
- **é‡è¦ç¨‹åº¦**: â­â­â­â­â­ (5æ˜Ÿ)
- **å‰ç½®çŸ¥è¯†**: JavaåŸºç¡€ã€JVMå†…å­˜æ¨¡å‹
- **æ–‡æ¡£æ¥æº**: Oracleå®˜æ–¹æ–‡æ¡£ + ã€ŠJavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹
- **æ›´æ–°æ—¶é—´**: 2024-01-04
- **ä½œè€…**: @author erik.zhou

## ğŸ¯ å­¦ä¹ ç›®æ ‡
- [ ] ç†è§£Javaå†…å­˜æ¨¡å‹ï¼ˆJMMï¼‰å’Œhappens-beforeåŸåˆ™
- [ ] æŒæ¡çº¿ç¨‹çš„åˆ›å»ºã€ç”Ÿå‘½å‘¨æœŸå’ŒçŠ¶æ€è½¬æ¢
- [ ] ç†Ÿç»ƒä½¿ç”¨synchronizedå’Œvolatileå…³é”®å­—
- [ ] ç†è§£å¹¶ä½¿ç”¨Lockæ¥å£å’ŒAQSæ¡†æ¶
- [ ] æŒæ¡çº¿ç¨‹æ± çš„åŸç†å’Œä½¿ç”¨
- [ ] ç†Ÿæ‚‰å¸¸ç”¨å¹¶å‘å®¹å™¨å’Œå·¥å…·ç±»
- [ ] èƒ½å¤Ÿè¯†åˆ«å’Œè§£å†³å¸¸è§å¹¶å‘é—®é¢˜

## ğŸ“– åŸºç¡€æ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯å¹¶å‘ç¼–ç¨‹
å¹¶å‘ç¼–ç¨‹æ˜¯æŒ‡åœ¨åŒä¸€æ—¶é—´æ®µå†…æ‰§è¡Œå¤šä¸ªä»»åŠ¡çš„ç¼–ç¨‹æ–¹å¼ã€‚åœ¨Javaä¸­ï¼Œå¹¶å‘ä¸»è¦é€šè¿‡å¤šçº¿ç¨‹å®ç°ï¼Œå…è®¸ç¨‹åºåŒæ—¶æ‰§è¡Œå¤šä¸ªæ“ä½œï¼Œæé«˜ç³»ç»Ÿèµ„æºåˆ©ç”¨ç‡å’Œå“åº”é€Ÿåº¦ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- **å¹¶å‘ï¼ˆConcurrencyï¼‰**: å¤šä¸ªä»»åŠ¡åœ¨åŒä¸€æ—¶é—´æ®µå†…äº¤æ›¿æ‰§è¡Œ
- **å¹¶è¡Œï¼ˆParallelismï¼‰**: å¤šä¸ªä»»åŠ¡åœ¨åŒä¸€æ—¶åˆ»åŒæ—¶æ‰§è¡Œ
- **çº¿ç¨‹å®‰å…¨**: å¤šä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œç¨‹åºèƒ½å¤Ÿæ­£ç¡®æ‰§è¡Œ

### 1.2 Javaå†…å­˜æ¨¡å‹ï¼ˆJMMï¼‰ğŸ”¥
Javaå†…å­˜æ¨¡å‹å®šä¹‰äº†çº¿ç¨‹å¦‚ä½•ä¸ä¸»å†…å­˜äº¤äº’ï¼Œä»¥åŠçº¿ç¨‹ä¹‹é—´å¦‚ä½•é€šè¿‡å…±äº«å˜é‡è¿›è¡Œé€šä¿¡ã€‚

**å†…å­˜æ¨¡å‹ç»“æ„**ï¼š

```
ä¸»å†…å­˜ï¼ˆMain Memoryï¼‰
    â†‘â†“
å·¥ä½œå†…å­˜ï¼ˆWorking Memoryï¼‰- çº¿ç¨‹1
å·¥ä½œå†…å­˜ï¼ˆWorking Memoryï¼‰- çº¿ç¨‹2
å·¥ä½œå†…å­˜ï¼ˆWorking Memoryï¼‰- çº¿ç¨‹3
```

**happens-beforeåŸåˆ™**ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰ï¼š
1. **ç¨‹åºé¡ºåºè§„åˆ™**: å•çº¿ç¨‹å†…ï¼ŒæŒ‰ä»£ç é¡ºåºæ‰§è¡Œ
2. **ç›‘è§†å™¨é”è§„åˆ™**: unlockæ“ä½œhappens-beforeåç»­çš„lockæ“ä½œ
3. **volatileå˜é‡è§„åˆ™**: å†™æ“ä½œhappens-beforeåç»­çš„è¯»æ“ä½œ
4. **çº¿ç¨‹å¯åŠ¨è§„åˆ™**: Thread.start() happens-beforeçº¿ç¨‹å†…çš„æ‰€æœ‰æ“ä½œ
5. **çº¿ç¨‹ç»ˆæ­¢è§„åˆ™**: çº¿ç¨‹å†…æ‰€æœ‰æ“ä½œhappens-before Thread.join()è¿”å›
6. **ä¼ é€’æ€§**: A happens-before Bï¼ŒB happens-before Cï¼Œåˆ™A happens-before C

### 1.3 çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸ
çº¿ç¨‹åœ¨å…¶ç”Ÿå‘½å‘¨æœŸä¸­ä¼šç»å†ä»¥ä¸‹çŠ¶æ€ï¼š

```
NEWï¼ˆæ–°å»ºï¼‰
  â†“ start()
RUNNABLEï¼ˆå¯è¿è¡Œï¼‰
  â†“ è·å–é”å¤±è´¥ / wait() / sleep() / join()
BLOCKEDï¼ˆé˜»å¡ï¼‰/ WAITINGï¼ˆç­‰å¾…ï¼‰/ TIMED_WAITINGï¼ˆè¶…æ—¶ç­‰å¾…ï¼‰
  â†“ è·å–é” / notify() / è¶…æ—¶
RUNNABLEï¼ˆå¯è¿è¡Œï¼‰
  â†“ æ‰§è¡Œå®Œæˆ
TERMINATEDï¼ˆç»ˆæ­¢ï¼‰
```

## ğŸ”¥ æ ¸å¿ƒç‰¹æ€§

### 2.1 çº¿ç¨‹çš„åˆ›å»ºæ–¹å¼

#### æ–¹å¼1ï¼šç»§æ‰¿Threadç±»
```java
/**
 * ç»§æ‰¿Threadç±»åˆ›å»ºçº¿ç¨‹
 * @author erik.zhou
 */
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("çº¿ç¨‹æ‰§è¡Œï¼š" + Thread.currentThread().getName());
    }
    
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // å¯åŠ¨çº¿ç¨‹
    }
}
```

#### æ–¹å¼2ï¼šå®ç°Runnableæ¥å£ï¼ˆæ¨èï¼‰
```java
/**
 * å®ç°Runnableæ¥å£åˆ›å»ºçº¿ç¨‹
 * @author erik.zhou
 */
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("çº¿ç¨‹æ‰§è¡Œï¼š" + Thread.currentThread().getName());
    }
    
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
```

#### æ–¹å¼3ï¼šå®ç°Callableæ¥å£ï¼ˆæœ‰è¿”å›å€¼ï¼‰
```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

/**
 * å®ç°Callableæ¥å£åˆ›å»ºçº¿ç¨‹
 * @author erik.zhou
 */
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        return "ä»»åŠ¡æ‰§è¡Œç»“æœ";
    }
    
    public static void main(String[] args) throws Exception {
        FutureTask<String> futureTask = new FutureTask<>(new MyCallable());
        Thread thread = new Thread(futureTask);
        thread.start();
        
        // è·å–è¿”å›å€¼ï¼ˆä¼šé˜»å¡ï¼‰
        String result = futureTask.get();
        System.out.println("ç»“æœï¼š" + result);
    }
}
```

#### æ–¹å¼4ï¼šä½¿ç”¨çº¿ç¨‹æ± ï¼ˆç”Ÿäº§ç¯å¢ƒæ¨èï¼‰ğŸ”¥
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * ä½¿ç”¨çº¿ç¨‹æ± åˆ›å»ºçº¿ç¨‹
 * @author erik.zhou
 */
public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("æ‰§è¡Œä»»åŠ¡ï¼š" + taskId);
            });
        }
        
        executor.shutdown();
    }
}
```

### 2.2 synchronizedå…³é”®å­— ğŸ”¥

synchronizedæ˜¯Javaä¸­æœ€åŸºæœ¬çš„åŒæ­¥æœºåˆ¶ï¼Œç”¨äºä¿è¯çº¿ç¨‹å®‰å…¨ã€‚

#### ä½¿ç”¨æ–¹å¼

**1. åŒæ­¥æ–¹æ³•**
```java
/**
 * åŒæ­¥æ–¹æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class SynchronizedMethod {
    private int count = 0;
    
    // åŒæ­¥å®ä¾‹æ–¹æ³•ï¼ˆé”å¯¹è±¡æ˜¯thisï¼‰
    public synchronized void increment() {
        count++;
    }
    
    // åŒæ­¥é™æ€æ–¹æ³•ï¼ˆé”å¯¹è±¡æ˜¯ç±»çš„Classå¯¹è±¡ï¼‰
    public static synchronized void staticMethod() {
        System.out.println("é™æ€åŒæ­¥æ–¹æ³•");
    }
}
```

**2. åŒæ­¥ä»£ç å—**
```java
/**
 * åŒæ­¥ä»£ç å—ç¤ºä¾‹
 * @author erik.zhou
 */
public class SynchronizedBlock {
    private final Object lock = new Object();
    private int count = 0;
    
    public void increment() {
        synchronized (lock) {
            count++;
        }
    }
    
    // åŒæ­¥thiså¯¹è±¡
    public void method1() {
        synchronized (this) {
            // ä¸´ç•ŒåŒºä»£ç 
        }
    }
    
    // åŒæ­¥ç±»å¯¹è±¡
    public void method2() {
        synchronized (SynchronizedBlock.class) {
            // ä¸´ç•ŒåŒºä»£ç 
        }
    }
}
```

#### synchronizedåŸç†ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰


synchronizedåŸºäºJVMçš„ç›‘è§†å™¨é”ï¼ˆMonitorï¼‰å®ç°ï¼š
- **å¯¹è±¡å¤´**: æ¯ä¸ªJavaå¯¹è±¡éƒ½æœ‰å¯¹è±¡å¤´ï¼ŒåŒ…å«Mark Wordï¼ˆå­˜å‚¨é”ä¿¡æ¯ï¼‰
- **Monitor**: æ¯ä¸ªå¯¹è±¡éƒ½å…³è”ä¸€ä¸ªMonitorï¼ŒåŒ…å«Ownerã€EntryListã€WaitSet
- **é”å‡çº§**: æ— é” â†’ åå‘é” â†’ è½»é‡çº§é” â†’ é‡é‡çº§é”ï¼ˆä¸å¯é™çº§ï¼‰

```java
/**
 * synchronizedé”å‡çº§ç¤ºä¾‹
 * @author erik.zhou
 */
public class LockUpgrade {
    private static final Object LOCK = new Object();
    
    public static void main(String[] args) {
        // åå‘é”ï¼šåªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®
        synchronized (LOCK) {
            System.out.println("åå‘é”");
        }
        
        // è½»é‡çº§é”ï¼šå¤šä¸ªçº¿ç¨‹äº¤æ›¿è®¿é—®
        new Thread(() -> {
            synchronized (LOCK) {
                System.out.println("è½»é‡çº§é”-çº¿ç¨‹1");
            }
        }).start();
        
        // é‡é‡çº§é”ï¼šå¤šä¸ªçº¿ç¨‹ç«äº‰è®¿é—®
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                synchronized (LOCK) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}
```

### 2.3 volatileå…³é”®å­— ğŸ”¥

volatileä¿è¯å˜é‡çš„å¯è§æ€§å’Œæœ‰åºæ€§ï¼Œä½†ä¸ä¿è¯åŸå­æ€§ã€‚

#### ç‰¹æ€§
1. **å¯è§æ€§**: ä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹volatileå˜é‡ï¼Œå…¶ä»–çº¿ç¨‹ç«‹å³å¯è§
2. **æœ‰åºæ€§**: ç¦æ­¢æŒ‡ä»¤é‡æ’åº
3. **ä¸ä¿è¯åŸå­æ€§**: count++ä¸æ˜¯åŸå­æ“ä½œ

```java
/**
 * volatileä½¿ç”¨ç¤ºä¾‹
 * @author erik.zhou
 */
public class VolatileExample {
    // ä¸ä½¿ç”¨volatileï¼Œå¯èƒ½å¯¼è‡´çº¿ç¨‹æ— æ³•åœæ­¢
    private static boolean flag = false;
    
    // ä½¿ç”¨volatileä¿è¯å¯è§æ€§
    private static volatile boolean volatileFlag = false;
    
    public static void main(String[] args) throws InterruptedException {
        // é”™è¯¯ç¤ºä¾‹ï¼šå¯èƒ½æ— æ³•åœæ­¢
        Thread thread1 = new Thread(() -> {
            while (!flag) {
                // çº¿ç¨‹å¯èƒ½ä¸€ç›´å¾ªç¯
            }
            System.out.println("çº¿ç¨‹1åœæ­¢");
        });
        thread1.start();
        
        Thread.sleep(1000);
        flag = true; // å¯èƒ½ä¸å¯è§
        
        // æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨volatile
        Thread thread2 = new Thread(() -> {
            while (!volatileFlag) {
                // èƒ½å¤ŸåŠæ—¶çœ‹åˆ°å˜åŒ–
            }
            System.out.println("çº¿ç¨‹2åœæ­¢");
        });
        thread2.start();
        
        Thread.sleep(1000);
        volatileFlag = true; // ç«‹å³å¯è§
    }
}
```

#### volatile vs synchronizedï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

| ç‰¹æ€§ | volatile | synchronized |
|------|----------|--------------|
| åŸå­æ€§ | âŒ ä¸ä¿è¯ | âœ… ä¿è¯ |
| å¯è§æ€§ | âœ… ä¿è¯ | âœ… ä¿è¯ |
| æœ‰åºæ€§ | âœ… ç¦æ­¢é‡æ’åº | âœ… ä¿è¯ |
| æ€§èƒ½ | é«˜ï¼ˆæ— é”ï¼‰ | ä½ï¼ˆæœ‰é”ï¼‰ |
| é€‚ç”¨åœºæ™¯ | çŠ¶æ€æ ‡å¿—ã€åŒé‡æ£€æŸ¥é” | å¤åˆæ“ä½œã€ä¸´ç•ŒåŒº |

### 2.4 Lockæ¥å£å’ŒAQSæ¡†æ¶ ğŸ”¥

#### ReentrantLockï¼ˆå¯é‡å…¥é”ï¼‰
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * ReentrantLockä½¿ç”¨ç¤ºä¾‹
 * @author erik.zhou
 */
public class ReentrantLockExample {
    private final Lock lock = new ReentrantLock();
    private int count = 0;
    
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // å¿…é¡»åœ¨finallyä¸­é‡Šæ”¾é”
        }
    }
    
    // å°è¯•è·å–é”ï¼ˆéé˜»å¡ï¼‰
    public void tryLockExample() {
        if (lock.tryLock()) {
            try {
                // è·å–é”æˆåŠŸï¼Œæ‰§è¡Œä¸šåŠ¡é€»è¾‘
                System.out.println("è·å–é”æˆåŠŸ");
            } finally {
                lock.unlock();
            }
        } else {
            // è·å–é”å¤±è´¥ï¼Œæ‰§è¡Œå…¶ä»–é€»è¾‘
            System.out.println("è·å–é”å¤±è´¥");
        }
    }
}
```

#### ReentrantReadWriteLockï¼ˆè¯»å†™é”ï¼‰
```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * è¯»å†™é”ç¤ºä¾‹
 * @author erik.zhou
 */
public class ReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private String data = "";
    
    // è¯»æ“ä½œï¼ˆå…±äº«é”ï¼‰
    public String read() {
        rwLock.readLock().lock();
        try {
            Thread.sleep(100);
            return data;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    // å†™æ“ä½œï¼ˆæ’ä»–é”ï¼‰
    public void write(String newData) {
        rwLock.writeLock().lock();
        try {
            Thread.sleep(100);
            this.data = newData;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
```

#### AQSåŸç†ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰
AbstractQueuedSynchronizerï¼ˆAQSï¼‰æ˜¯Javaå¹¶å‘åŒ…çš„åŸºç¡€æ¡†æ¶ï¼š
- **æ ¸å¿ƒæ€æƒ³**: ä½¿ç”¨ä¸€ä¸ªintç±»å‹çš„stateè¡¨ç¤ºåŒæ­¥çŠ¶æ€ï¼Œé€šè¿‡FIFOé˜Ÿåˆ—ç®¡ç†ç­‰å¾…çº¿ç¨‹
- **å®ç°ç±»**: ReentrantLockã€Semaphoreã€CountDownLatchã€ReentrantReadWriteLockç­‰
- **å…³é”®æ–¹æ³•**: acquire()ã€release()ã€tryAcquire()ã€tryRelease()

```java
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

/**
 * è‡ªå®šä¹‰åŒæ­¥å™¨ç¤ºä¾‹
 * @author erik.zhou
 */
public class CustomLock {
    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        
        @Override
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
    }
    
    private final Sync sync = new Sync();
    
    public void lock() {
        sync.acquire(1);
    }
    
    public void unlock() {
        sync.release(1);
    }
}
```

### 2.5 çº¿ç¨‹æ±  ğŸ”¥

#### ThreadPoolExecutoræ ¸å¿ƒå‚æ•°


```java
import java.util.concurrent.*;

/**
 * çº¿ç¨‹æ± æ ¸å¿ƒå‚æ•°ç¤ºä¾‹
 * @author erik.zhou
 */
public class ThreadPoolExample {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5,                      // corePoolSize: æ ¸å¿ƒçº¿ç¨‹æ•°
            10,                     // maximumPoolSize: æœ€å¤§çº¿ç¨‹æ•°
            60L,                    // keepAliveTime: ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
            TimeUnit.SECONDS,       // unit: æ—¶é—´å•ä½
            new LinkedBlockingQueue<>(100),  // workQueue: ä»»åŠ¡é˜Ÿåˆ—
            Executors.defaultThreadFactory(), // threadFactory: çº¿ç¨‹å·¥å‚
            new ThreadPoolExecutor.CallerRunsPolicy() // handler: æ‹’ç»ç­–ç•¥
        );
        
        // æäº¤ä»»åŠ¡
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("æ‰§è¡Œä»»åŠ¡ï¼š" + taskId + 
                    "ï¼Œçº¿ç¨‹ï¼š" + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        executor.shutdown();
    }
}
```

#### çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰
```
æäº¤ä»»åŠ¡
  â†“
æ ¸å¿ƒçº¿ç¨‹æ•°æœªæ»¡ï¼Ÿ
  â”œâ”€ æ˜¯ â†’ åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
  â””â”€ å¦ â†’ ä»»åŠ¡é˜Ÿåˆ—æœªæ»¡ï¼Ÿ
           â”œâ”€ æ˜¯ â†’ åŠ å…¥é˜Ÿåˆ—ç­‰å¾…
           â””â”€ å¦ â†’ æœ€å¤§çº¿ç¨‹æ•°æœªæ»¡ï¼Ÿ
                    â”œâ”€ æ˜¯ â†’ åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
                    â””â”€ å¦ â†’ æ‰§è¡Œæ‹’ç»ç­–ç•¥
```

#### å››ç§æ‹’ç»ç­–ç•¥
```java
/**
 * æ‹’ç»ç­–ç•¥ç¤ºä¾‹
 * @author erik.zhou
 */
public class RejectedPolicyExample {
    public static void main(String[] args) {
        // 1. AbortPolicyï¼ˆé»˜è®¤ï¼‰ï¼šæŠ›å‡ºå¼‚å¸¸
        ThreadPoolExecutor executor1 = new ThreadPoolExecutor(
            1, 1, 0L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1),
            new ThreadPoolExecutor.AbortPolicy()
        );
        
        // 2. CallerRunsPolicyï¼šè°ƒç”¨è€…çº¿ç¨‹æ‰§è¡Œ
        ThreadPoolExecutor executor2 = new ThreadPoolExecutor(
            1, 1, 0L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        // 3. DiscardPolicyï¼šç›´æ¥ä¸¢å¼ƒ
        ThreadPoolExecutor executor3 = new ThreadPoolExecutor(
            1, 1, 0L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1),
            new ThreadPoolExecutor.DiscardPolicy()
        );
        
        // 4. DiscardOldestPolicyï¼šä¸¢å¼ƒæœ€è€çš„ä»»åŠ¡
        ThreadPoolExecutor executor4 = new ThreadPoolExecutor(
            1, 1, 0L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1),
            new ThreadPoolExecutor.DiscardOldestPolicy()
        );
    }
}
```

#### å¸¸ç”¨çº¿ç¨‹æ± ç±»å‹
```java
import java.util.concurrent.*;

/**
 * å¸¸ç”¨çº¿ç¨‹æ± ç±»å‹
 * @author erik.zhou
 */
public class CommonThreadPools {
    public static void main(String[] args) {
        // 1. FixedThreadPoolï¼šå›ºå®šå¤§å°çº¿ç¨‹æ± 
        ExecutorService fixedPool = Executors.newFixedThreadPool(5);
        
        // 2. CachedThreadPoolï¼šç¼“å­˜çº¿ç¨‹æ± ï¼ˆçº¿ç¨‹æ•°ä¸å›ºå®šï¼‰
        ExecutorService cachedPool = Executors.newCachedThreadPool();
        
        // 3. SingleThreadExecutorï¼šå•çº¿ç¨‹çº¿ç¨‹æ± 
        ExecutorService singlePool = Executors.newSingleThreadExecutor();
        
        // 4. ScheduledThreadPoolï¼šå®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 
        ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(5);
        
        // å®šæ—¶ä»»åŠ¡ç¤ºä¾‹
        scheduledPool.scheduleAtFixedRate(() -> {
            System.out.println("å®šæ—¶ä»»åŠ¡æ‰§è¡Œ");
        }, 0, 1, TimeUnit.SECONDS);
    }
}
```

âš ï¸ **æ³¨æ„**: é˜¿é‡Œå·´å·´å¼€å‘è§„èŒƒç¦æ­¢ä½¿ç”¨Executorsåˆ›å»ºçº¿ç¨‹æ± ï¼Œåº”ä½¿ç”¨ThreadPoolExecutoræ‰‹åŠ¨åˆ›å»ºï¼Œä»¥ä¾¿æ›´å¥½åœ°æ§åˆ¶å‚æ•°ã€‚

### 2.6 å¹¶å‘å®¹å™¨ ğŸ”¥

#### ConcurrentHashMap
```java
import java.util.concurrent.ConcurrentHashMap;

/**
 * ConcurrentHashMapä½¿ç”¨ç¤ºä¾‹
 * @author erik.zhou
 */
public class ConcurrentHashMapExample {
    private static final ConcurrentHashMap<String, Integer> MAP = new ConcurrentHashMap<>();
    
    public static void main(String[] args) {
        // çº¿ç¨‹å®‰å…¨çš„putæ“ä½œ
        MAP.put("key1", 1);
        
        // putIfAbsentï¼šä¸å­˜åœ¨æ‰put
        MAP.putIfAbsent("key2", 2);
        
        // computeIfAbsentï¼šä¸å­˜åœ¨æ‰è®¡ç®—å¹¶put
        MAP.computeIfAbsent("key3", k -> 3);
        
        // mergeï¼šåˆå¹¶å€¼
        MAP.merge("key1", 10, Integer::sum); // key1çš„å€¼å˜ä¸º11
        
        System.out.println(MAP);
    }
}
```

#### CopyOnWriteArrayList
```java
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * CopyOnWriteArrayListä½¿ç”¨ç¤ºä¾‹
 * é€‚ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯
 * @author erik.zhou
 */
public class CopyOnWriteArrayListExample {
    private static final CopyOnWriteArrayList<String> LIST = new CopyOnWriteArrayList<>();
    
    public static void main(String[] args) {
        // å†™æ“ä½œï¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„
        LIST.add("item1");
        LIST.add("item2");
        
        // è¯»æ“ä½œï¼šä¸åŠ é”ï¼Œç›´æ¥è¯»å–
        for (String item : LIST) {
            System.out.println(item);
        }
    }
}
```

#### BlockingQueueï¼ˆé˜»å¡é˜Ÿåˆ—ï¼‰
```java
import java.util.concurrent.*;

/**
 * é˜»å¡é˜Ÿåˆ—ç¤ºä¾‹
 * @author erik.zhou
 */
public class BlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        // 1. ArrayBlockingQueueï¼šæœ‰ç•Œé˜»å¡é˜Ÿåˆ—
        BlockingQueue<String> arrayQueue = new ArrayBlockingQueue<>(10);
        
        // 2. LinkedBlockingQueueï¼šå¯é€‰æœ‰ç•Œé˜»å¡é˜Ÿåˆ—
        BlockingQueue<String> linkedQueue = new LinkedBlockingQueue<>(100);
        
        // 3. PriorityBlockingQueueï¼šä¼˜å…ˆçº§é˜»å¡é˜Ÿåˆ—
        BlockingQueue<Integer> priorityQueue = new PriorityBlockingQueue<>();
        
        // 4. SynchronousQueueï¼šä¸å­˜å‚¨å…ƒç´ çš„é˜»å¡é˜Ÿåˆ—
        BlockingQueue<String> syncQueue = new SynchronousQueue<>();
        
        // ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç¤ºä¾‹
        BlockingQueue<String> queue = new LinkedBlockingQueue<>(10);
        
        // ç”Ÿäº§è€…
        new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    queue.put("ä»»åŠ¡" + i); // é˜Ÿåˆ—æ»¡æ—¶é˜»å¡
                    System.out.println("ç”Ÿäº§ï¼šä»»åŠ¡" + i);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        
        // æ¶ˆè´¹è€…
        new Thread(() -> {
            try {
                while (true) {
                    String task = queue.take(); // é˜Ÿåˆ—ç©ºæ—¶é˜»å¡
                    System.out.println("æ¶ˆè´¹ï¼š" + task);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

### 2.7 å¹¶å‘å·¥å…·ç±»

#### CountDownLatchï¼ˆå€’è®¡æ—¶é—¨æ “ï¼‰
```java
import java.util.concurrent.CountDownLatch;

/**
 * CountDownLatchä½¿ç”¨ç¤ºä¾‹
 * ç­‰å¾…å¤šä¸ªçº¿ç¨‹å®Œæˆåå†ç»§ç»­æ‰§è¡Œ
 * @author erik.zhou
 */
public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int threadCount = 5;
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    Thread.sleep(1000);
                    System.out.println("ä»»åŠ¡" + taskId + "å®Œæˆ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown(); // è®¡æ•°å‡1
                }
            }).start();
        }
        
        latch.await(); // ç­‰å¾…è®¡æ•°å½’é›¶
        System.out.println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ");
    }
}
```

#### CyclicBarrierï¼ˆå¾ªç¯æ …æ ï¼‰


```java
import java.util.concurrent.CyclicBarrier;

/**
 * CyclicBarrierä½¿ç”¨ç¤ºä¾‹
 * è®©ä¸€ç»„çº¿ç¨‹åˆ°è¾¾å±éšœæ—¶è¢«é˜»å¡ï¼Œç›´åˆ°æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°è¾¾
 * @author erik.zhou
 */
public class CyclicBarrierExample {
    public static void main(String[] args) {
        int threadCount = 5;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            System.out.println("æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾å±éšœï¼Œå¼€å§‹æ‰§è¡Œæ±‡æ€»ä»»åŠ¡");
        });
        
        for (int i = 0; i < threadCount; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    System.out.println("çº¿ç¨‹" + taskId + "å‡†å¤‡ä¸­...");
                    Thread.sleep(1000);
                    System.out.println("çº¿ç¨‹" + taskId + "åˆ°è¾¾å±éšœ");
                    barrier.await(); // ç­‰å¾…å…¶ä»–çº¿ç¨‹
                    System.out.println("çº¿ç¨‹" + taskId + "ç»§ç»­æ‰§è¡Œ");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

#### Semaphoreï¼ˆä¿¡å·é‡ï¼‰
```java
import java.util.concurrent.Semaphore;

/**
 * Semaphoreä½¿ç”¨ç¤ºä¾‹
 * æ§åˆ¶åŒæ—¶è®¿é—®èµ„æºçš„çº¿ç¨‹æ•°é‡
 * @author erik.zhou
 */
public class SemaphoreExample {
    public static void main(String[] args) {
        // å…è®¸3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
        Semaphore semaphore = new Semaphore(3);
        
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    semaphore.acquire(); // è·å–è®¸å¯
                    System.out.println("çº¿ç¨‹" + taskId + "è·å¾—è®¸å¯ï¼Œå¼€å§‹æ‰§è¡Œ");
                    Thread.sleep(2000);
                    System.out.println("çº¿ç¨‹" + taskId + "æ‰§è¡Œå®Œæˆï¼Œé‡Šæ”¾è®¸å¯");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // é‡Šæ”¾è®¸å¯
                }
            }).start();
        }
    }
}
```

#### Exchangerï¼ˆäº¤æ¢å™¨ï¼‰
```java
import java.util.concurrent.Exchanger;

/**
 * Exchangerä½¿ç”¨ç¤ºä¾‹
 * ä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´äº¤æ¢æ•°æ®
 * @author erik.zhou
 */
public class ExchangerExample {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();
        
        // çº¿ç¨‹1
        new Thread(() -> {
            try {
                String data1 = "çº¿ç¨‹1çš„æ•°æ®";
                System.out.println("çº¿ç¨‹1å‡†å¤‡äº¤æ¢ï¼š" + data1);
                String data2 = exchanger.exchange(data1);
                System.out.println("çº¿ç¨‹1æ”¶åˆ°ï¼š" + data2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        
        // çº¿ç¨‹2
        new Thread(() -> {
            try {
                String data1 = "çº¿ç¨‹2çš„æ•°æ®";
                System.out.println("çº¿ç¨‹2å‡†å¤‡äº¤æ¢ï¼š" + data1);
                String data2 = exchanger.exchange(data1);
                System.out.println("çº¿ç¨‹2æ”¶åˆ°ï¼š" + data2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

## ğŸ’» å®æˆ˜åº”ç”¨

### 3.1 å•ä¾‹æ¨¡å¼çš„çº¿ç¨‹å®‰å…¨å®ç°

#### åŒé‡æ£€æŸ¥é”ï¼ˆDCLï¼‰ğŸ”¥
```java
/**
 * åŒé‡æ£€æŸ¥é”å•ä¾‹æ¨¡å¼
 * @author erik.zhou
 */
public class Singleton {
    // volatileä¿è¯å¯è§æ€§å’Œç¦æ­¢æŒ‡ä»¤é‡æ’åº
    private static volatile Singleton instance;
    
    private Singleton() {
        // ç§æœ‰æ„é€ å‡½æ•°
    }
    
    public static Singleton getInstance() {
        if (instance == null) { // ç¬¬ä¸€æ¬¡æ£€æŸ¥
            synchronized (Singleton.class) {
                if (instance == null) { // ç¬¬äºŒæ¬¡æ£€æŸ¥
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### é™æ€å†…éƒ¨ç±»ï¼ˆæ¨èï¼‰
```java
/**
 * é™æ€å†…éƒ¨ç±»å•ä¾‹æ¨¡å¼ï¼ˆæ¨èï¼‰
 * @author erik.zhou
 */
public class Singleton {
    private Singleton() {
    }
    
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

### 3.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

#### ä½¿ç”¨wait/notifyå®ç°
```java
import java.util.LinkedList;
import java.util.Queue;

/**
 * ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ï¼ˆwait/notifyï¼‰
 * @author erik.zhou
 */
public class ProducerConsumer {
    private static final int MAX_SIZE = 10;
    private final Queue<Integer> queue = new LinkedList<>();
    
    // ç”Ÿäº§è€…
    public void produce() throws InterruptedException {
        synchronized (queue) {
            while (queue.size() == MAX_SIZE) {
                queue.wait(); // é˜Ÿåˆ—æ»¡ï¼Œç­‰å¾…
            }
            int value = (int) (Math.random() * 100);
            queue.offer(value);
            System.out.println("ç”Ÿäº§ï¼š" + value + "ï¼Œé˜Ÿåˆ—å¤§å°ï¼š" + queue.size());
            queue.notifyAll(); // å”¤é†’æ¶ˆè´¹è€…
        }
    }
    
    // æ¶ˆè´¹è€…
    public void consume() throws InterruptedException {
        synchronized (queue) {
            while (queue.isEmpty()) {
                queue.wait(); // é˜Ÿåˆ—ç©ºï¼Œç­‰å¾…
            }
            int value = queue.poll();
            System.out.println("æ¶ˆè´¹ï¼š" + value + "ï¼Œé˜Ÿåˆ—å¤§å°ï¼š" + queue.size());
            queue.notifyAll(); // å”¤é†’ç”Ÿäº§è€…
        }
    }
    
    public static void main(String[] args) {
        ProducerConsumer pc = new ProducerConsumer();
        
        // å¯åŠ¨ç”Ÿäº§è€…
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    while (true) {
                        pc.produce();
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        
        // å¯åŠ¨æ¶ˆè´¹è€…
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    while (true) {
                        pc.consume();
                        Thread.sleep(200);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### 3.3 çº¿ç¨‹å®‰å…¨çš„ç¼“å­˜å®ç°
```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * çº¿ç¨‹å®‰å…¨çš„ç¼“å­˜å®ç°
 * @author erik.zhou
 */
public class ThreadSafeCache<K, V> {
    private final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    // è·å–ç¼“å­˜
    public V get(K key) {
        return cache.get(key);
    }
    
    // è®¾ç½®ç¼“å­˜
    public void put(K key, V value) {
        cache.put(key, value);
    }
    
    // å¸¦è¿‡æœŸæ—¶é—´çš„ç¼“å­˜
    public V getWithExpire(K key, long expireMillis, ValueLoader<K, V> loader) {
        V value = cache.get(key);
        if (value == null) {
            lock.writeLock().lock();
            try {
                value = cache.get(key);
                if (value == null) {
                    value = loader.load(key);
                    cache.put(key, value);
                }
            } finally {
                lock.writeLock().unlock();
            }
        }
        return value;
    }
    
    @FunctionalInterface
    interface ValueLoader<K, V> {
        V load(K key);
    }
}
```

### 3.4 å¹¶å‘ä»»åŠ¡æ‰¹å¤„ç†
```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/**
 * å¹¶å‘ä»»åŠ¡æ‰¹å¤„ç†
 * @author erik.zhou
 */
public class BatchProcessor {
    private final ExecutorService executor;
    
    public BatchProcessor(int threadCount) {
        this.executor = new ThreadPoolExecutor(
            threadCount,
            threadCount,
            0L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
    
    /**
     * æ‰¹é‡å¤„ç†ä»»åŠ¡
     */
    public <T, R> List<R> processBatch(List<T> items, Function<T, R> processor) 
            throws InterruptedException, ExecutionException {
        List<Future<R>> futures = new ArrayList<>(items.size());
        
        // æäº¤æ‰€æœ‰ä»»åŠ¡
        for (T item : items) {
            Future<R> future = executor.submit(() -> processor.apply(item));
            futures.add(future);
        }
        
        // æ”¶é›†ç»“æœ
        List<R> results = new ArrayList<>(items.size());
        for (Future<R> future : futures) {
            results.add(future.get());
        }
        
        return results;
    }
    
    @FunctionalInterface
    interface Function<T, R> {
        R apply(T t);
    }
    
    public void shutdown() {
        executor.shutdown();
    }
}
```

## âœ¨ æœ€ä½³å®è·µ

### 4.1 çº¿ç¨‹æ± é…ç½®å»ºè®®

**CPUå¯†é›†å‹ä»»åŠ¡**ï¼š
```java
int coreCount = Runtime.getRuntime().availableProcessors();
int threadCount = coreCount + 1;
```

**IOå¯†é›†å‹ä»»åŠ¡**ï¼š
```java
int coreCount = Runtime.getRuntime().availableProcessors();
int threadCount = coreCount * 2;
```

**æ··åˆå‹ä»»åŠ¡**ï¼š
```java
// æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
int threadCount = (int) (coreCount / (1 - blockingCoefficient));
// blockingCoefficient: é˜»å¡ç³»æ•°ï¼ˆ0-1ä¹‹é—´ï¼‰
```

### 4.2 é¿å…æ­»é”çš„å››ä¸ªæ¡ä»¶

1. **äº’æ–¥æ¡ä»¶**: èµ„æºä¸èƒ½è¢«å¤šä¸ªçº¿ç¨‹å…±äº«
2. **è¯·æ±‚ä¸ä¿æŒ**: æŒæœ‰èµ„æºçš„åŒæ—¶è¯·æ±‚æ–°èµ„æº
3. **ä¸å‰¥å¤ºæ¡ä»¶**: èµ„æºä¸èƒ½è¢«å¼ºåˆ¶å‰¥å¤º
4. **å¾ªç¯ç­‰å¾…**: å­˜åœ¨èµ„æºçš„å¾ªç¯ç­‰å¾…é“¾

**é¢„é˜²æ­»é”**ï¼š
```java
/**
 * é¿å…æ­»é”ç¤ºä¾‹
 * @author erik.zhou
 */
public class DeadlockPrevention {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    // é”™è¯¯ï¼šå¯èƒ½æ­»é”
    public void badMethod1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // ä¸šåŠ¡é€»è¾‘
            }
        }
    }
    
    public void badMethod2() {
        synchronized (lock2) {
            synchronized (lock1) {
                // ä¸šåŠ¡é€»è¾‘
            }
        }
    }
    
    // æ­£ç¡®ï¼šç»Ÿä¸€åŠ é”é¡ºåº
    public void goodMethod1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // ä¸šåŠ¡é€»è¾‘
            }
        }
    }
    
    public void goodMethod2() {
        synchronized (lock1) { // ä¸method1ç›¸åŒçš„é¡ºåº
            synchronized (lock2) {
                // ä¸šåŠ¡é€»è¾‘
            }
        }
    }
}
```

### 4.3 ThreadLocalä½¿ç”¨è§„èŒƒ âš ï¸

```java
/**
 * ThreadLocalä½¿ç”¨è§„èŒƒ
 * @author erik.zhou
 */
public class ThreadLocalExample {
    private static final ThreadLocal<String> THREAD_LOCAL = new ThreadLocal<>();
    
    // é”™è¯¯ï¼šæœªæ¸…ç†ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
    public void badMethod() {
        THREAD_LOCAL.set("value");
        // ä½¿ç”¨value
        // æœªè°ƒç”¨remove()
    }
    
    // æ­£ç¡®ï¼šä½¿ç”¨åæ¸…ç†
    public void goodMethod() {
        try {
            THREAD_LOCAL.set("value");
            // ä½¿ç”¨value
        } finally {
            THREAD_LOCAL.remove(); // å¿…é¡»æ¸…ç†
        }
    }
}
```

### 4.4 å¸¸è§é™·é˜±

âš ï¸ **é™·é˜±1ï¼šå¾ªç¯ä¸­åˆ›å»ºçº¿ç¨‹**
```java
// é”™è¯¯
for (int i = 0; i < 1000; i++) {
    new Thread(() -> {
        // ä»»åŠ¡
    }).start();
}

// æ­£ç¡®ï¼šä½¿ç”¨çº¿ç¨‹æ± 
ExecutorService executor = Executors.newFixedThreadPool(10);
for (int i = 0; i < 1000; i++) {
    executor.submit(() -> {
        // ä»»åŠ¡
    });
}
executor.shutdown();
```

âš ï¸ **é™·é˜±2ï¼šsynchronizedé”ç²—åŒ–**
```java
// é”™è¯¯ï¼šé”èŒƒå›´è¿‡å¤§
public synchronized void method() {
    // å¤§é‡éä¸´ç•ŒåŒºä»£ç 
    // ä¸´ç•ŒåŒºä»£ç 
    // å¤§é‡éä¸´ç•ŒåŒºä»£ç 
}

// æ­£ç¡®ï¼šç¼©å°é”èŒƒå›´
public void method() {
    // éä¸´ç•ŒåŒºä»£ç 
    synchronized (this) {
        // ä¸´ç•ŒåŒºä»£ç 
    }
    // éä¸´ç•ŒåŒºä»£ç 
}
```

âš ï¸ **é™·é˜±3ï¼švolatileä¸ä¿è¯åŸå­æ€§**
```java
// é”™è¯¯
private volatile int count = 0;
public void increment() {
    count++; // éåŸå­æ“ä½œ
}

// æ­£ç¡®
private final AtomicInteger count = new AtomicInteger(0);
public void increment() {
    count.incrementAndGet();
}
```

## â“ å¸¸è§é—®é¢˜

### Q1: synchronizedå’ŒLockçš„åŒºåˆ«ï¼Ÿ
A: 
- synchronizedæ˜¯å…³é”®å­—ï¼ŒLockæ˜¯æ¥å£
- synchronizedè‡ªåŠ¨é‡Šæ”¾é”ï¼ŒLockéœ€è¦æ‰‹åŠ¨é‡Šæ”¾
- Lockæ”¯æŒå°è¯•è·å–é”ã€è¶…æ—¶è·å–é”ã€å¯ä¸­æ–­
- Lockæ”¯æŒå…¬å¹³é”å’Œéå…¬å¹³é”
- Lockæ”¯æŒè¯»å†™é”åˆ†ç¦»

### Q2: å¦‚ä½•é€‰æ‹©çº¿ç¨‹æ± ç±»å‹ï¼Ÿ
A:
- CPUå¯†é›†å‹ï¼šFixedThreadPoolï¼Œçº¿ç¨‹æ•°=CPUæ ¸å¿ƒæ•°+1
- IOå¯†é›†å‹ï¼šCachedThreadPoolæˆ–è‡ªå®šä¹‰çº¿ç¨‹æ± 
- å®šæ—¶ä»»åŠ¡ï¼šScheduledThreadPool
- å•çº¿ç¨‹é¡ºåºæ‰§è¡Œï¼šSingleThreadExecutor

### Q3: ConcurrentHashMapçš„åŸç†ï¼Ÿ
A:
- JDK 1.7ï¼šåˆ†æ®µé”ï¼ˆSegmentï¼‰ï¼Œé»˜è®¤16ä¸ªæ®µ
- JDK 1.8+ï¼šCAS + synchronizedï¼Œé”ç²’åº¦æ›´ç»†ï¼ˆé”å•ä¸ªèŠ‚ç‚¹ï¼‰
- ä¸å…è®¸nullé”®å’Œnullå€¼

### Q4: å¦‚ä½•æ’æŸ¥æ­»é”ï¼Ÿ
A:
1. ä½¿ç”¨jstackå‘½ä»¤ï¼š`jstack <pid>`
2. ä½¿ç”¨JConsoleæˆ–VisualVMå·¥å…·
3. æŸ¥çœ‹çº¿ç¨‹dumpï¼Œæ‰¾åˆ°"Found one Java-level deadlock"

### Q5: volatileçš„ä½¿ç”¨åœºæ™¯ï¼Ÿ
A:
- çŠ¶æ€æ ‡å¿—ï¼ˆå¦‚çº¿ç¨‹åœæ­¢æ ‡å¿—ï¼‰
- åŒé‡æ£€æŸ¥é”ï¼ˆDCLï¼‰
- è¯»å¤šå†™å°‘çš„åœºæ™¯
- ä¸é€‚åˆå¤åˆæ“ä½œï¼ˆå¦‚count++ï¼‰

## ğŸ”— ç›¸å…³èµ„æº

- [Javaå¹¶å‘ç¼–ç¨‹å®æˆ˜](https://book.douban.com/subject/10484692/)
- [æ·±å…¥ç†è§£Javaè™šæ‹Ÿæœº](https://book.douban.com/subject/34907497/)
- [Oracleå¹¶å‘æ•™ç¨‹](https://docs.oracle.com/javase/tutorial/essential/concurrency/)
- [Doug Leaçš„å¹¶å‘ç¼–ç¨‹æ–‡ç« ](http://gee.cs.oswego.edu/dl/cpj/)
- [é˜¿é‡Œå·´å·´å¼€å‘è§„èŒƒ](https://github.com/alibaba/p3c)

## ğŸ“ å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£Javaå†…å­˜æ¨¡å‹å’Œhappens-beforeåŸåˆ™
- [ ] æŒæ¡çº¿ç¨‹çš„åˆ›å»ºæ–¹å¼å’Œç”Ÿå‘½å‘¨æœŸ
- [ ] ç†Ÿç»ƒä½¿ç”¨synchronizedå’Œvolatile
- [ ] ç†è§£é”å‡çº§æœºåˆ¶ï¼ˆåå‘é”ã€è½»é‡çº§é”ã€é‡é‡çº§é”ï¼‰
- [ ] æŒæ¡Lockæ¥å£å’ŒAQSæ¡†æ¶
- [ ] ç†è§£çº¿ç¨‹æ± çš„æ ¸å¿ƒå‚æ•°å’Œæ‰§è¡Œæµç¨‹
- [ ] ç†Ÿæ‚‰å¸¸ç”¨å¹¶å‘å®¹å™¨ï¼ˆConcurrentHashMapã€CopyOnWriteArrayListç­‰ï¼‰
- [ ] æŒæ¡å¹¶å‘å·¥å…·ç±»ï¼ˆCountDownLatchã€CyclicBarrierã€Semaphoreï¼‰
- [ ] èƒ½å¤Ÿå®ç°çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼
- [ ] èƒ½å¤Ÿè¯†åˆ«å’Œé¿å…æ­»é”
- [ ] ç†è§£ThreadLocalçš„åŸç†å’Œä½¿ç”¨è§„èŒƒ
- [ ] æŒæ¡å¹¶å‘ç¼–ç¨‹çš„æœ€ä½³å®è·µ

---

**å­¦ä¹ å»ºè®®**ï¼š
1. å…ˆç†è§£ç†è®ºï¼ˆJMMã€happens-beforeï¼‰ï¼Œå†å­¦ä¹ å·¥å…·
2. å¤šå†™ä»£ç å®è·µï¼Œç†è§£å¹¶å‘é—®é¢˜çš„æœ¬è´¨
3. ä½¿ç”¨JConsoleã€VisualVMç­‰å·¥å…·åˆ†æçº¿ç¨‹çŠ¶æ€
4. é˜…è¯»JDKå¹¶å‘åŒ…çš„æºç ï¼ˆå¦‚ReentrantLockã€ThreadPoolExecutorï¼‰
5. å…³æ³¨é˜¿é‡Œå·´å·´å¼€å‘è§„èŒƒä¸­çš„å¹¶å‘ç¼–ç¨‹è§„èŒƒ
