# ç®—æ³•ä¸æ•°æ®ç»“æ„ å®Œæ•´æ•™ç¨‹

## ğŸ“‹ ç›®å½•
- [æŠ€æœ¯æ¦‚è¿°](#æŠ€æœ¯æ¦‚è¿°)
- [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
- [å¤æ‚åº¦åˆ†æ](#å¤æ‚åº¦åˆ†æ)
- [åŸºç¡€æ•°æ®ç»“æ„](#åŸºç¡€æ•°æ®ç»“æ„)
- [é«˜çº§æ•°æ®ç»“æ„](#é«˜çº§æ•°æ®ç»“æ„)
- [æ’åºç®—æ³•](#æ’åºç®—æ³•)
- [æŸ¥æ‰¾ç®—æ³•](#æŸ¥æ‰¾ç®—æ³•)
- [å¸¸ç”¨ç®—æ³•](#å¸¸ç”¨ç®—æ³•)
- [å®æˆ˜åº”ç”¨](#å®æˆ˜åº”ç”¨)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
- [å­¦ä¹ æ£€æŸ¥æ¸…å•](#å­¦ä¹ æ£€æŸ¥æ¸…å•)

## ğŸ“š æŠ€æœ¯æ¦‚è¿°
- **ç‰ˆæœ¬**: é€šç”¨
- **å‚è€ƒä¹¦ç±**: ã€Šç®—æ³•å¯¼è®ºã€‹ã€ã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹
- **å­¦ä¹ éš¾åº¦**: â­â­â­â­ (4æ˜Ÿ)
- **é‡è¦ç¨‹åº¦**: â­â­â­â­â­ (5æ˜Ÿ)
- **å‰ç½®çŸ¥è¯†**: JavaåŸºç¡€ã€æ•°å­¦åŸºç¡€
- **æ–‡æ¡£æ¥æº**: ç»å…¸ç®—æ³•æ•™æ + LeetCode
- **æ›´æ–°æ—¶é—´**: 2024-01-04
- **ä½œè€…**: @author erik.zhou

## ğŸ¯ å­¦ä¹ ç›®æ ‡
- [ ] ç†è§£æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
- [ ] æŒæ¡å¸¸ç”¨æ•°æ®ç»“æ„çš„å®ç°å’Œåº”ç”¨
- [ ] ç†Ÿç»ƒä½¿ç”¨å¸¸è§æ’åºå’ŒæŸ¥æ‰¾ç®—æ³•
- [ ] ç†è§£é€’å½’ã€åˆ†æ²»ã€åŠ¨æ€è§„åˆ’ç­‰ç®—æ³•æ€æƒ³
- [ ] èƒ½å¤Ÿåˆ†æç®—æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- [ ] èƒ½å¤Ÿé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„å’Œç®—æ³•è§£å†³é—®é¢˜

## ğŸ“– å¤æ‚åº¦åˆ†æ ğŸ”¥

### 1.1 æ—¶é—´å¤æ‚åº¦ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

**å®šä¹‰**: ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„è¶‹åŠ¿

**å¸¸è§æ—¶é—´å¤æ‚åº¦**ï¼ˆä»å¿«åˆ°æ…¢ï¼‰:
```
O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(nÂ³) < O(2â¿) < O(n!)
```

**ç¤ºä¾‹**:
```java
/**
 * æ—¶é—´å¤æ‚åº¦ç¤ºä¾‹
 * @author erik.zhou
 */
public class TimeComplexity {
    // O(1) - å¸¸æ•°æ—¶é—´
    public int constant(int n) {
        return n * 2;
    }
    
    // O(log n) - å¯¹æ•°æ—¶é—´
    public int logarithmic(int n) {
        int count = 0;
        while (n > 1) {
            n = n / 2;
            count++;
        }
        return count;
    }
    
    // O(n) - çº¿æ€§æ—¶é—´
    public int linear(int[] arr) {
        int sum = 0;
        for (int num : arr) {
            sum += num;
        }
        return sum;
    }
    
    // O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´
    public void nLogN(int[] arr) {
        // å½’å¹¶æ’åºã€å¿«é€Ÿæ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦
        Arrays.sort(arr);
    }
    
    // O(nÂ²) - å¹³æ–¹æ—¶é—´
    public void quadratic(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                // åµŒå¥—å¾ªç¯
            }
        }
    }
    
    // O(2â¿) - æŒ‡æ•°æ—¶é—´
    public int exponential(int n) {
        if (n <= 1) {
            return 1;
        }
        return exponential(n - 1) + exponential(n - 1);
    }
}
```

### 1.2 ç©ºé—´å¤æ‚åº¦

**å®šä¹‰**: ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€çš„é¢å¤–å­˜å‚¨ç©ºé—´

```java
/**
 * ç©ºé—´å¤æ‚åº¦ç¤ºä¾‹
 * @author erik.zhou
 */
public class SpaceComplexity {
    // O(1) - å¸¸æ•°ç©ºé—´
    public int constant(int n) {
        int result = n * 2;
        return result;
    }
    
    // O(n) - çº¿æ€§ç©ºé—´
    public int[] linear(int n) {
        int[] arr = new int[n];
        return arr;
    }
    
    // O(n) - é€’å½’è°ƒç”¨æ ˆ
    public int recursive(int n) {
        if (n <= 0) {
            return 0;
        }
        return n + recursive(n - 1);
    }
}
```


## ğŸ”¥ åŸºç¡€æ•°æ®ç»“æ„

### 2.1 æ•°ç»„ï¼ˆArrayï¼‰

**ç‰¹ç‚¹**:
- è¿ç»­å†…å­˜å­˜å‚¨
- éšæœºè®¿é—®O(1)
- æ’å…¥/åˆ é™¤O(n)

```java
/**
 * æ•°ç»„æ“ä½œ
 * @author erik.zhou
 */
public class ArrayOperations {
    // æŸ¥æ‰¾å…ƒç´ 
    public int find(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
    
    // æ’å…¥å…ƒç´ ï¼ˆéœ€è¦ç§»åŠ¨å…ƒç´ ï¼‰
    public int[] insert(int[] arr, int index, int value) {
        int[] newArr = new int[arr.length + 1];
        for (int i = 0; i < index; i++) {
            newArr[i] = arr[i];
        }
        newArr[index] = value;
        for (int i = index; i < arr.length; i++) {
            newArr[i + 1] = arr[i];
        }
        return newArr;
    }
    
    // åˆ é™¤å…ƒç´ 
    public int[] delete(int[] arr, int index) {
        int[] newArr = new int[arr.length - 1];
        for (int i = 0; i < index; i++) {
            newArr[i] = arr[i];
        }
        for (int i = index + 1; i < arr.length; i++) {
            newArr[i - 1] = arr[i];
        }
        return newArr;
    }
}
```

### 2.2 é“¾è¡¨ï¼ˆLinkedListï¼‰ğŸ”¥

**ç‰¹ç‚¹**:
- éè¿ç»­å†…å­˜å­˜å‚¨
- æ’å…¥/åˆ é™¤O(1)
- æŸ¥æ‰¾O(n)

```java
/**
 * å•é“¾è¡¨å®ç°
 * @author erik.zhou
 */
public class LinkedList {
    private Node head;
    
    private static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    // å¤´éƒ¨æ’å…¥
    public void addFirst(int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        head = newNode;
    }
    
    // å°¾éƒ¨æ’å…¥
    public void addLast(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
            return;
        }
        Node current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }
    
    // åˆ é™¤èŠ‚ç‚¹
    public void delete(int data) {
        if (head == null) {
            return;
        }
        if (head.data == data) {
            head = head.next;
            return;
        }
        Node current = head;
        while (current.next != null && current.next.data != data) {
            current = current.next;
        }
        if (current.next != null) {
            current.next = current.next.next;
        }
    }
    
    // åè½¬é“¾è¡¨ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰
    public void reverse() {
        Node prev = null;
        Node current = head;
        while (current != null) {
            Node next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        head = prev;
    }
}
```

### 2.3 æ ˆï¼ˆStackï¼‰

**ç‰¹ç‚¹**: åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰

```java
/**
 * æ ˆå®ç°
 * @author erik.zhou
 */
public class Stack {
    private int[] arr;
    private int top;
    private int capacity;
    
    public Stack(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.top = -1;
    }
    
    public void push(int data) {
        if (top == capacity - 1) {
            throw new RuntimeException("æ ˆå·²æ»¡");
        }
        arr[++top] = data;
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("æ ˆä¸ºç©º");
        }
        return arr[top--];
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("æ ˆä¸ºç©º");
        }
        return arr[top];
    }
    
    public boolean isEmpty() {
        return top == -1;
    }
}
```

### 2.4 é˜Ÿåˆ—ï¼ˆQueueï¼‰

**ç‰¹ç‚¹**: å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰

```java
/**
 * é˜Ÿåˆ—å®ç°
 * @author erik.zhou
 */
public class Queue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public Queue(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    public void enqueue(int data) {
        if (size == capacity) {
            throw new RuntimeException("é˜Ÿåˆ—å·²æ»¡");
        }
        rear = (rear + 1) % capacity;
        arr[rear] = data;
        size++;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("é˜Ÿåˆ—ä¸ºç©º");
        }
        int data = arr[front];
        front = (front + 1) % capacity;
        size--;
        return data;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
}
```

### 2.5 å“ˆå¸Œè¡¨ï¼ˆHashMapï¼‰ğŸ”¥

**ç‰¹ç‚¹**:
- å¹³å‡æŸ¥æ‰¾/æ’å…¥/åˆ é™¤O(1)
- åŸºäºå“ˆå¸Œå‡½æ•°

```java
/**
 * ç®€å•å“ˆå¸Œè¡¨å®ç°
 * @author erik.zhou
 */
public class SimpleHashMap {
    private static class Entry {
        String key;
        int value;
        Entry next;
        
        Entry(String key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Entry[] table;
    private int capacity;
    
    public SimpleHashMap(int capacity) {
        this.capacity = capacity;
        this.table = new Entry[capacity];
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    public void put(String key, int value) {
        int index = hash(key);
        Entry entry = table[index];
        
        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
            entry = entry.next;
        }
        
        // å¤´éƒ¨æ’å…¥
        Entry newEntry = new Entry(key, value);
        newEntry.next = table[index];
        table[index] = newEntry;
    }
    
    public Integer get(String key) {
        int index = hash(key);
        Entry entry = table[index];
        
        while (entry != null) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
            entry = entry.next;
        }
        return null;
    }
}
```

## ğŸ”¥ é«˜çº§æ•°æ®ç»“æ„

### 3.1 äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰ğŸ”¥

```java
/**
 * äºŒå‰æ ‘å®ç°
 * @author erik.zhou
 */
public class BinaryTree {
    private static class Node {
        int data;
        Node left;
        Node right;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node root;
    
    // å‰åºéå†ï¼ˆæ ¹-å·¦-å³ï¼‰
    public void preOrder(Node node) {
        if (node == null) {
            return;
        }
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }
    
    // ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰
    public void inOrder(Node node) {
        if (node == null) {
            return;
        }
        inOrder(node.left);
        System.out.print(node.data + " ");
        inOrder(node.right);
    }
    
    // ååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰
    public void postOrder(Node node) {
        if (node == null) {
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.print(node.data + " ");
    }
    
    // å±‚åºéå†
    public void levelOrder() {
        if (root == null) {
            return;
        }
        java.util.Queue<Node> queue = new java.util.LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            System.out.print(node.data + " ");
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
}
```

### 3.2 äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

**ç‰¹ç‚¹**: å·¦å­æ ‘ < æ ¹ < å³å­æ ‘

```java
/**
 * äºŒå‰æœç´¢æ ‘å®ç°
 * @author erik.zhou
 */
public class BST {
    private static class Node {
        int data;
        Node left;
        Node right;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node root;
    
    // æ’å…¥
    public void insert(int data) {
        root = insertRec(root, data);
    }
    
    private Node insertRec(Node node, int data) {
        if (node == null) {
            return new Node(data);
        }
        if (data < node.data) {
            node.left = insertRec(node.left, data);
        } else if (data > node.data) {
            node.right = insertRec(node.right, data);
        }
        return node;
    }
    
    // æŸ¥æ‰¾
    public boolean search(int data) {
        return searchRec(root, data);
    }
    
    private boolean searchRec(Node node, int data) {
        if (node == null) {
            return false;
        }
        if (data == node.data) {
            return true;
        }
        if (data < node.data) {
            return searchRec(node.left, data);
        }
        return searchRec(node.right, data);
    }
    
    // åˆ é™¤
    public void delete(int data) {
        root = deleteRec(root, data);
    }
    
    private Node deleteRec(Node node, int data) {
        if (node == null) {
            return null;
        }
        
        if (data < node.data) {
            node.left = deleteRec(node.left, data);
        } else if (data > node.data) {
            node.right = deleteRec(node.right, data);
        } else {
            // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
            if (node.left == null) {
                return node.right;
            }
            if (node.right == null) {
                return node.left;
            }
            
            // æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼šæ‰¾å³å­æ ‘æœ€å°å€¼
            node.data = findMin(node.right);
            node.right = deleteRec(node.right, node.data);
        }
        return node;
    }
    
    private int findMin(Node node) {
        while (node.left != null) {
            node = node.left;
        }
        return node.data;
    }
}
```

### 3.3 å †ï¼ˆHeapï¼‰

**ç‰¹ç‚¹**: å®Œå…¨äºŒå‰æ ‘ï¼Œçˆ¶èŠ‚ç‚¹ â‰¥ å­èŠ‚ç‚¹ï¼ˆå¤§é¡¶å †ï¼‰

```java
/**
 * å¤§é¡¶å †å®ç°
 * @author erik.zhou
 */
public class MaxHeap {
    private int[] arr;
    private int size;
    private int capacity;
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.size = 0;
    }
    
    private int parent(int i) {
        return (i - 1) / 2;
    }
    
    private int leftChild(int i) {
        return 2 * i + 1;
    }
    
    private int rightChild(int i) {
        return 2 * i + 2;
    }
    
    // æ’å…¥
    public void insert(int data) {
        if (size == capacity) {
            throw new RuntimeException("å †å·²æ»¡");
        }
        arr[size] = data;
        int current = size;
        size++;
        
        // ä¸Šæµ®
        while (current > 0 && arr[current] > arr[parent(current)]) {
            swap(current, parent(current));
            current = parent(current);
        }
    }
    
    // åˆ é™¤æœ€å¤§å€¼
    public int extractMax() {
        if (size == 0) {
            throw new RuntimeException("å †ä¸ºç©º");
        }
        int max = arr[0];
        arr[0] = arr[size - 1];
        size--;
        
        // ä¸‹æ²‰
        heapify(0);
        return max;
    }
    
    private void heapify(int i) {
        int largest = i;
        int left = leftChild(i);
        int right = rightChild(i);
        
        if (left < size && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < size && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }
    
    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## ğŸ”¥ æ’åºç®—æ³•

### 4.1 å†’æ³¡æ’åºï¼ˆBubble Sortï¼‰

**æ—¶é—´å¤æ‚åº¦**: O(nÂ²)  
**ç©ºé—´å¤æ‚åº¦**: O(1)  
**ç¨³å®šæ€§**: ç¨³å®š

```java
/**
 * å†’æ³¡æ’åº
 * @author erik.zhou
 */
public class BubbleSort {
    public void sort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            if (!swapped) {
                break; // ä¼˜åŒ–ï¼šå·²æ’åº
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.2 å¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰ğŸ”¥

**æ—¶é—´å¤æ‚åº¦**: å¹³å‡O(n log n)ï¼Œæœ€åO(nÂ²)  
**ç©ºé—´å¤æ‚åº¦**: O(log n)  
**ç¨³å®šæ€§**: ä¸ç¨³å®š

```java
/**
 * å¿«é€Ÿæ’åº
 * @author erik.zhou
 */
public class QuickSort {
    public void sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.3 å½’å¹¶æ’åºï¼ˆMerge Sortï¼‰ğŸ”¥

**æ—¶é—´å¤æ‚åº¦**: O(n log n)  
**ç©ºé—´å¤æ‚åº¦**: O(n)  
**ç¨³å®šæ€§**: ç¨³å®š

```java
/**
 * å½’å¹¶æ’åº
 * @author erik.zhou
 */
public class MergeSort {
    public void sort(int[] arr) {
        mergeSort(arr, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    
    private void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0;
        int j = 0;
        int k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = leftArr[i++];
        }
        
        while (j < n2) {
            arr[k++] = rightArr[j++];
        }
    }
}
```

## ğŸ”¥ æŸ¥æ‰¾ç®—æ³•

### 5.1 äºŒåˆ†æŸ¥æ‰¾ï¼ˆBinary Searchï¼‰ğŸ”¥

**æ—¶é—´å¤æ‚åº¦**: O(log n)  
**å‰æ**: æ•°ç»„å·²æ’åº

```java
/**
 * äºŒåˆ†æŸ¥æ‰¾
 * @author erik.zhou
 */
public class BinarySearch {
    // è¿­ä»£å®ç°
    public int search(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
    // é€’å½’å®ç°
    public int searchRecursive(int[] arr, int target) {
        return binarySearchRec(arr, target, 0, arr.length - 1);
    }
    
    private int binarySearchRec(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        }
        if (arr[mid] < target) {
            return binarySearchRec(arr, target, mid + 1, right);
        }
        return binarySearchRec(arr, target, left, mid - 1);
    }
}
```

## ğŸ”¥ å¸¸ç”¨ç®—æ³•

### 6.1 é€’å½’

```java
/**
 * é€’å½’ç¤ºä¾‹
 * @author erik.zhou
 */
public class Recursion {
    // é˜¶ä¹˜
    public int factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    // æ–æ³¢é‚£å¥‘æ•°åˆ—
    public int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // æ–æ³¢é‚£å¥‘ä¼˜åŒ–ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰
    public int fibonacciDP(int n) {
        if (n <= 1) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

### 6.2 åŠ¨æ€è§„åˆ’ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

```java
/**
 * åŠ¨æ€è§„åˆ’ç¤ºä¾‹
 * @author erik.zhou
 */
public class DynamicProgramming {
    // çˆ¬æ¥¼æ¢¯é—®é¢˜
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
    
    // æœ€é•¿å…¬å…±å­åºåˆ—
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
    
    // 0-1èƒŒåŒ…é—®é¢˜
    public int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(
                        dp[i - 1][w],
                        dp[i - 1][w - weights[i - 1]] + values[i - 1]
                    );
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][capacity];
    }
    
    // æœ€é•¿é€’å¢å­åºåˆ—
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        return maxLen;
    }
    
    // ç¼–è¾‘è·ç¦»
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j], dp[i][j - 1]),
                        dp[i - 1][j - 1]
                    ) + 1;
                }
            }
        }
        return dp[m][n];
    }
}
```

### 6.3 è´ªå¿ƒç®—æ³•

```java
/**
 * è´ªå¿ƒç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class GreedyAlgorithm {
    // æ´»åŠ¨é€‰æ‹©é—®é¢˜
    public int activitySelection(int[] start, int[] finish) {
        int n = start.length;
        // æŒ‰ç»“æŸæ—¶é—´æ’åº
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        Arrays.sort(indices, (a, b) -> finish[a] - finish[b]);
        
        int count = 1;
        int lastFinish = finish[indices[0]];
        
        for (int i = 1; i < n; i++) {
            if (start[indices[i]] >= lastFinish) {
                count++;
                lastFinish = finish[indices[i]];
            }
        }
        return count;
    }
    
    // æ‰¾é›¶é’±é—®é¢˜ï¼ˆè´ªå¿ƒï¼‰
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int count = 0;
        
        for (int i = coins.length - 1; i >= 0; i--) {
            while (amount >= coins[i]) {
                amount -= coins[i];
                count++;
            }
        }
        return amount == 0 ? count : -1;
    }
    
    // è·³è·ƒæ¸¸æˆ
    public boolean canJump(int[] nums) {
        int maxReach = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > maxReach) {
                return false;
            }
            maxReach = Math.max(maxReach, i + nums[i]);
        }
        return true;
    }
}
```

### 6.4 å›æº¯ç®—æ³•ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰

```java
/**
 * å›æº¯ç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class Backtracking {
    // å…¨æ’åˆ—
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), nums, new boolean[nums.length]);
        return result;
    }
    
    private void backtrack(List<List<Integer>> result, List<Integer> temp, 
                          int[] nums, boolean[] used) {
        if (temp.size() == nums.length) {
            result.add(new ArrayList<>(temp));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            temp.add(nums[i]);
            used[i] = true;
            backtrack(result, temp, nums, used);
            temp.remove(temp.size() - 1);
            used[i] = false;
        }
    }
    
    // Nçš‡åé—®é¢˜
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        backtrackQueens(result, board, 0);
        return result;
    }
    
    private void backtrackQueens(List<List<String>> result, char[][] board, int row) {
        if (row == board.length) {
            result.add(construct(board));
            return;
        }
        
        for (int col = 0; col < board.length; col++) {
            if (isValid(board, row, col)) {
                board[row][col] = 'Q';
                backtrackQueens(result, board, row + 1);
                board[row][col] = '.';
            }
        }
    }
    
    private boolean isValid(char[][] board, int row, int col) {
        // æ£€æŸ¥åˆ—
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }
        
        // æ£€æŸ¥å·¦ä¸Šå¯¹è§’çº¿
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        // æ£€æŸ¥å³ä¸Šå¯¹è§’çº¿
        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        return true;
    }
    
    private List<String> construct(char[][] board) {
        List<String> result = new ArrayList<>();
        for (char[] row : board) {
            result.add(new String(row));
        }
        return result;
    }
    
    // å­é›†é—®é¢˜
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrackSubsets(result, new ArrayList<>(), nums, 0);
        return result;
    }
    
    private void backtrackSubsets(List<List<Integer>> result, List<Integer> temp, 
                                 int[] nums, int start) {
        result.add(new ArrayList<>(temp));
        
        for (int i = start; i < nums.length; i++) {
            temp.add(nums[i]);
            backtrackSubsets(result, temp, nums, i + 1);
            temp.remove(temp.size() - 1);
        }
    }
}
```

### 6.5 åˆ†æ²»ç®—æ³•

```java
/**
 * åˆ†æ²»ç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class DivideAndConquer {
    // æœ€å¤§å­æ•°ç»„å’Œï¼ˆåˆ†æ²»æ³•ï¼‰
    public int maxSubArray(int[] nums) {
        return maxSubArrayHelper(nums, 0, nums.length - 1);
    }
    
    private int maxSubArrayHelper(int[] nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        
        int mid = left + (right - left) / 2;
        int leftMax = maxSubArrayHelper(nums, left, mid);
        int rightMax = maxSubArrayHelper(nums, mid + 1, right);
        int crossMax = maxCrossingSum(nums, left, mid, right);
        
        return Math.max(Math.max(leftMax, rightMax), crossMax);
    }
    
    private int maxCrossingSum(int[] nums, int left, int mid, int right) {
        int leftSum = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = mid; i >= left; i--) {
            sum += nums[i];
            leftSum = Math.max(leftSum, sum);
        }
        
        int rightSum = Integer.MIN_VALUE;
        sum = 0;
        for (int i = mid + 1; i <= right; i++) {
            sum += nums[i];
            rightSum = Math.max(rightSum, sum);
        }
        
        return leftSum + rightSum;
    }
    
    // å¤§æ•°ä¹˜æ³•ï¼ˆKaratsubaç®—æ³•ï¼‰
    public long multiply(long x, long y) {
        if (x < 10 || y < 10) {
            return x * y;
        }
        
        int n = Math.max(String.valueOf(x).length(), String.valueOf(y).length());
        int half = n / 2;
        long power = (long) Math.pow(10, half);
        
        long a = x / power;
        long b = x % power;
        long c = y / power;
        long d = y % power;
        
        long ac = multiply(a, c);
        long bd = multiply(b, d);
        long abcd = multiply(a + b, c + d);
        
        return ac * power * power + (abcd - ac - bd) * power + bd;
    }
}
```

### 6.6 å›¾ç®—æ³•ï¼ˆâš ï¸ éš¾ç‚¹ï¼‰ğŸ”¥

```java
/**
 * å›¾ç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class GraphAlgorithms {
    // æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰
    public void dfs(int[][] graph, int start) {
        boolean[] visited = new boolean[graph.length];
        dfsHelper(graph, start, visited);
    }
    
    private void dfsHelper(int[][] graph, int node, boolean[] visited) {
        visited[node] = true;
        System.out.print(node + " ");
        
        for (int i = 0; i < graph[node].length; i++) {
            if (graph[node][i] == 1 && !visited[i]) {
                dfsHelper(graph, i, visited);
            }
        }
    }
    
    // å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰
    public void bfs(int[][] graph, int start) {
        boolean[] visited = new boolean[graph.length];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            System.out.print(node + " ");
            
            for (int i = 0; i < graph[node].length; i++) {
                if (graph[node][i] == 1 && !visited[i]) {
                    visited[i] = true;
                    queue.offer(i);
                }
            }
        }
    }
    
    // Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•
    public int[] dijkstra(int[][] graph, int start) {
        int n = graph.length;
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;
        
        for (int i = 0; i < n; i++) {
            int u = minDistance(dist, visited);
            visited[u] = true;
            
            for (int v = 0; v < n; v++) {
                if (!visited[v] && graph[u][v] != 0 && 
                    dist[u] != Integer.MAX_VALUE &&
                    dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
        return dist;
    }
    
    private int minDistance(int[] dist, boolean[] visited) {
        int min = Integer.MAX_VALUE;
        int minIndex = -1;
        
        for (int i = 0; i < dist.length; i++) {
            if (!visited[i] && dist[i] < min) {
                min = dist[i];
                minIndex = i;
            }
        }
        return minIndex;
    }
    
    // æ‹“æ‰‘æ’åº
    public List<Integer> topologicalSort(int n, int[][] edges) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[n];
        
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            inDegree[edge[1]]++;
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        while (!queue.isEmpty()) {
            int node = queue.poll();
            result.add(node);
            
            for (int neighbor : graph.get(node)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        return result.size() == n ? result : new ArrayList<>();
    }
    
    // å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // è·¯å¾„å‹ç¼©
            }
            return parent[x];
        }
        
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        }
        
        public boolean connected(int x, int y) {
            return find(x) == find(y);
        }
    }
}
```

### 6.7 å­—ç¬¦ä¸²ç®—æ³•

```java
/**
 * å­—ç¬¦ä¸²ç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class StringAlgorithms {
    // KMPå­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
    public int kmpSearch(String text, String pattern) {
        int[] lps = computeLPS(pattern);
        int i = 0; // textçš„ç´¢å¼•
        int j = 0; // patternçš„ç´¢å¼•
        
        while (i < text.length()) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == pattern.length()) {
                return i - j; // æ‰¾åˆ°åŒ¹é…
            } else if (i < text.length() && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        return -1;
    }
    
    private int[] computeLPS(String pattern) {
        int[] lps = new int[pattern.length()];
        int len = 0;
        int i = 1;
        
        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
    
    // æœ€é•¿å›æ–‡å­ä¸²ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 2) {
            return s;
        }
        
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int start = 0;
        int maxLen = 1;
        
        // å•ä¸ªå­—ç¬¦éƒ½æ˜¯å›æ–‡
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        
        // æ£€æŸ¥é•¿åº¦ä¸º2çš„å­ä¸²
        for (int i = 0; i < n - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                start = i;
                maxLen = 2;
            }
        }
        
        // æ£€æŸ¥é•¿åº¦å¤§äº2çš„å­ä¸²
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    start = i;
                    maxLen = len;
                }
            }
        }
        
        return s.substring(start, start + maxLen);
    }
}
```

### 6.8 ä½è¿ç®—ç®—æ³•

```java
/**
 * ä½è¿ç®—ç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class BitManipulation {
    // åˆ¤æ–­æ˜¯å¦ä¸º2çš„å¹‚
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
    
    // è®¡ç®—äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n &= (n - 1); // æ¸…é™¤æœ€å³è¾¹çš„1
            count++;
        }
        return count;
    }
    
    // åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼ˆå…¶ä»–æ•°å­—å‡ºç°ä¸¤æ¬¡ï¼‰
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num; // å¼‚æˆ–è¿ç®—
        }
        return result;
    }
    
    // äº¤æ¢ä¸¤ä¸ªæ•°ï¼ˆä¸ä½¿ç”¨ä¸´æ—¶å˜é‡ï¼‰
    public void swap(int[] arr, int i, int j) {
        if (i != j) {
            arr[i] ^= arr[j];
            arr[j] ^= arr[i];
            arr[i] ^= arr[j];
        }
    }
    
    // è·å–ç¬¬kä½
    public boolean getBit(int num, int k) {
        return ((num >> k) & 1) == 1;
    }
    
    // è®¾ç½®ç¬¬kä½ä¸º1
    public int setBit(int num, int k) {
        return num | (1 << k);
    }
    
    // æ¸…é™¤ç¬¬kä½
    public int clearBit(int num, int k) {
        return num & ~(1 << k);
    }
}
```

## ğŸ”¥ é«˜çº§ç®—æ³•ä¸“é¢˜

### 7.1 æ»‘åŠ¨çª—å£ç®—æ³•

```java
/**
 * æ»‘åŠ¨çª—å£ç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class SlidingWindow {
    // æœ€å°è¦†ç›–å­ä¸²
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) {
            return "";
        }
        
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        
        int left = 0;
        int right = 0;
        int valid = 0;
        int start = 0;
        int len = Integer.MAX_VALUE;
        
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }
            
            while (valid == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                
                char d = s.charAt(left);
                left++;
                
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        
        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
    }
    
    // æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> window = new HashMap<>();
        int left = 0;
        int right = 0;
        int maxLen = 0;
        
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            window.put(c, window.getOrDefault(c, 0) + 1);
            
            while (window.get(c) > 1) {
                char d = s.charAt(left);
                left++;
                window.put(d, window.get(d) - 1);
            }
            
            maxLen = Math.max(maxLen, right - left);
        }
        
        return maxLen;
    }
}
```

### 7.2 åŒæŒ‡é’ˆç®—æ³•

```java
/**
 * åŒæŒ‡é’ˆç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class TwoPointers {
    // ä¸¤æ•°ä¹‹å’Œï¼ˆæœ‰åºæ•°ç»„ï¼‰
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return new int[]{left + 1, right + 1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return new int[]{-1, -1};
    }
    
    // ä¸‰æ•°ä¹‹å’Œ
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        
        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue; // è·³è¿‡é‡å¤
            }
            
            int left = i + 1;
            int right = nums.length - 1;
            
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return result;
    }
    
    // æ¥é›¨æ°´
    public int trap(int[] height) {
        if (height.length == 0) {
            return 0;
        }
        
        int left = 0;
        int right = height.length - 1;
        int leftMax = 0;
        int rightMax = 0;
        int result = 0;
        
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    result += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    result += rightMax - height[right];
                }
                right--;
            }
        }
        
        return result;
    }
}
```

### 7.3 å•è°ƒæ ˆç®—æ³•

```java
/**
 * å•è°ƒæ ˆç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class MonotonicStack {
    // ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
    public int[] nextGreaterElement(int[] nums) {
        int[] result = new int[nums.length];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = nums.length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && stack.peek() <= nums[i]) {
                stack.pop();
            }
            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(nums[i]);
        }
        
        return result;
    }
    
    // æ¯æ—¥æ¸©åº¦
    public int[] dailyTemperatures(int[] temperatures) {
        int[] result = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int prevIndex = stack.pop();
                result[prevIndex] = i - prevIndex;
            }
            stack.push(i);
        }
        
        return result;
    }
    
    // æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        
        for (int i = 0; i <= heights.length; i++) {
            int h = (i == heights.length) ? 0 : heights[i];
            
            while (!stack.isEmpty() && h < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            
            stack.push(i);
        }
        
        return maxArea;
    }
}
```

### 7.4 å‰ç¼€å’Œç®—æ³•

```java
/**
 * å‰ç¼€å’Œç®—æ³•ç¤ºä¾‹
 * @author erik.zhou
 */
public class PrefixSum {
    // åŒºé—´å’ŒæŸ¥è¯¢
    static class NumArray {
        private int[] prefixSum;
        
        public NumArray(int[] nums) {
            prefixSum = new int[nums.length + 1];
            for (int i = 0; i < nums.length; i++) {
                prefixSum[i + 1] = prefixSum[i] + nums[i];
            }
        }
        
        public int sumRange(int left, int right) {
            return prefixSum[right + 1] - prefixSum[left];
        }
    }
    
    // å’Œä¸ºKçš„å­æ•°ç»„
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSumCount = new HashMap<>();
        prefixSumCount.put(0, 1);
        
        int sum = 0;
        int count = 0;
        
        for (int num : nums) {
            sum += num;
            if (prefixSumCount.containsKey(sum - k)) {
                count += prefixSumCount.get(sum - k);
            }
            prefixSumCount.put(sum, prefixSumCount.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
    
    // äºŒç»´åŒºåŸŸå’Œæ£€ç´¢
    static class NumMatrix {
        private int[][] prefixSum;
        
        public NumMatrix(int[][] matrix) {
            if (matrix.length == 0 || matrix[0].length == 0) {
                return;
            }
            
            int m = matrix.length;
            int n = matrix[0].length;
            prefixSum = new int[m + 1][n + 1];
            
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1]
                                    - prefixSum[i - 1][j - 1] + matrix[i - 1][j - 1];
                }
            }
        }
        
        public int sumRegion(int row1, int col1, int row2, int col2) {
            return prefixSum[row2 + 1][col2 + 1] - prefixSum[row1][col2 + 1]
                 - prefixSum[row2 + 1][col1] + prefixSum[row1][col1];
        }
    }
}
```

### 7.5 Trieæ ‘ï¼ˆå­—å…¸æ ‘ï¼‰

```java
/**
 * Trieæ ‘å®ç°
 * @author erik.zhou
 */
public class Trie {
    private static class TrieNode {
        TrieNode[] children;
        boolean isEnd;
        
        TrieNode() {
            children = new TrieNode[26];
            isEnd = false;
        }
    }
    
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    // æ’å…¥å•è¯
    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    // æœç´¢å•è¯
    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    // æœç´¢å‰ç¼€
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private TrieNode searchPrefix(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}
```

## âœ¨ æœ€ä½³å®è·µ

### 1. æ•°æ®ç»“æ„é€‰æ‹©

| åœºæ™¯ | æ¨èæ•°æ®ç»“æ„ | æ—¶é—´å¤æ‚åº¦ |
|------|-------------|-----------|
| é¢‘ç¹æŸ¥æ‰¾ | HashMapã€HashSet | O(1) |
| æœ‰åºæ•°æ® | TreeMapã€TreeSet | O(log n) |
| å…ˆè¿›å…ˆå‡º | Queue | O(1) |
| åè¿›å…ˆå‡º | Stack | O(1) |
| ä¼˜å…ˆçº§é˜Ÿåˆ— | PriorityQueueï¼ˆå †ï¼‰ | O(log n) |
| é¢‘ç¹æ’å…¥åˆ é™¤ | LinkedList | O(1) |
| éšæœºè®¿é—® | ArrayList | O(1) |
| å‰ç¼€åŒ¹é… | Trieæ ‘ | O(m) |
| åŒºé—´æŸ¥è¯¢ | çº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„ | O(log n) |

### 2. ç®—æ³•é€‰æ‹©

| åœºæ™¯ | æ¨èç®—æ³• | æ—¶é—´å¤æ‚åº¦ |
|------|---------|-----------|
| å°è§„æ¨¡æ•°æ®æ’åº | æ’å…¥æ’åº | O(nÂ²) |
| å¤§è§„æ¨¡æ•°æ®æ’åº | å¿«é€Ÿæ’åºã€å½’å¹¶æ’åº | O(n log n) |
| ç¨³å®šæ’åº | å½’å¹¶æ’åº | O(n log n) |
| æœ‰åºæ•°ç»„æŸ¥æ‰¾ | äºŒåˆ†æŸ¥æ‰¾ | O(log n) |
| æœ€çŸ­è·¯å¾„ | Dijkstraã€Floyd | O(nÂ²) |
| æœ€ä¼˜è§£é—®é¢˜ | åŠ¨æ€è§„åˆ’ | è§†æƒ…å†µè€Œå®š |
| æ’åˆ—ç»„åˆ | å›æº¯ç®—æ³• | O(n!) |
| å­ä¸²åŒ¹é… | KMPç®—æ³• | O(m+n) |
| å›¾çš„éå† | DFSã€BFS | O(V+E) |

### 3. ç®—æ³•ä¼˜åŒ–æŠ€å·§

```java
/**
 * ç®—æ³•ä¼˜åŒ–æŠ€å·§
 * @author erik.zhou
 */
public class OptimizationTips {
    // 1. ç©ºé—´æ¢æ—¶é—´ï¼šä½¿ç”¨å“ˆå¸Œè¡¨ç¼“å­˜
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        return new int[]{-1, -1};
    }
    
    // 2. å‰ªæä¼˜åŒ–ï¼šæå‰ç»ˆæ­¢
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % 2 != 0) {
            return false; // å‰ªæ
        }
        // ... ç»§ç»­å¤„ç†
        return true;
    }
    
    // 3. åŒæŒ‡é’ˆä¼˜åŒ–ï¼šå‡å°‘åµŒå¥—å¾ªç¯
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
    
    // 4. ä½è¿ç®—ä¼˜åŒ–ï¼šæé«˜è¿ç®—æ•ˆç‡
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}
```

### 4. å¸¸è§é™·é˜±ä¸æ³¨æ„äº‹é¡¹

```java
/**
 * å¸¸è§é™·é˜±ç¤ºä¾‹
 * @author erik.zhou
 */
public class CommonPitfalls {
    // 1. æ•´æ•°æº¢å‡º
    public int multiply(int a, int b) {
        // é”™è¯¯ï¼šå¯èƒ½æº¢å‡º
        // return a * b;
        
        // æ­£ç¡®ï¼šä½¿ç”¨long
        return (int)((long)a * b);
    }
    
    // 2. æ•°ç»„è¶Šç•Œ
    public int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            // é”™è¯¯ï¼šå¯èƒ½æº¢å‡º
            // int mid = (left + right) / 2;
            
            // æ­£ç¡®ï¼šé˜²æ­¢æº¢å‡º
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
    // 3. æµ®ç‚¹æ•°æ¯”è¾ƒ
    public boolean equals(double a, double b) {
        // é”™è¯¯ï¼šç›´æ¥æ¯”è¾ƒ
        // return a == b;
        
        // æ­£ç¡®ï¼šä½¿ç”¨ç²¾åº¦
        double epsilon = 1e-9;
        return Math.abs(a - b) < epsilon;
    }
    
    // 4. é€’å½’æ ˆæº¢å‡º
    public int fibonacci(int n) {
        // é”™è¯¯ï¼šå¯èƒ½æ ˆæº¢å‡º
        // if (n <= 1) return n;
        // return fibonacci(n - 1) + fibonacci(n - 2);
        
        // æ­£ç¡®ï¼šä½¿ç”¨è¿­ä»£æˆ–è®°å¿†åŒ–
        if (n <= 1) {
            return n;
        }
        int a = 0;
        int b = 1;
        for (int i = 2; i <= n; i++) {
            int temp = a + b;
            a = b;
            b = temp;
        }
        return b;
    }
}
```

## â“ å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„ï¼Ÿ
A: æ ¹æ®æ“ä½œé¢‘ç‡é€‰æ‹©ï¼š
- é¢‘ç¹æŸ¥æ‰¾ï¼šHashMapï¼ˆO(1)ï¼‰
- é¢‘ç¹æ’å…¥åˆ é™¤ï¼šLinkedListï¼ˆO(1)ï¼‰
- éœ€è¦æ’åºï¼šTreeMapï¼ˆO(log n)ï¼‰
- èŒƒå›´æŸ¥è¯¢ï¼šçº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„
- å‰ç¼€åŒ¹é…ï¼šTrieæ ‘

### Q2: é€’å½’å’Œè¿­ä»£å¦‚ä½•é€‰æ‹©ï¼Ÿ
A: 
- é€’å½’ï¼šä»£ç ç®€æ´ï¼Œé€‚åˆæ ‘ã€å›¾ç­‰é€’å½’ç»“æ„ï¼Œä½†å¯èƒ½æ ˆæº¢å‡º
- è¿­ä»£ï¼šæ€§èƒ½æ›´å¥½ï¼Œç©ºé—´å¤æ‚åº¦ä½ï¼Œé€‚åˆå¤§è§„æ¨¡æ•°æ®
- å»ºè®®ï¼šç®€å•é—®é¢˜ç”¨é€’å½’ï¼Œå¤æ‚é—®é¢˜æˆ–å¤§æ•°æ®ç”¨è¿­ä»£

### Q3: å¦‚ä½•ä¼˜åŒ–ç®—æ³•æ€§èƒ½ï¼Ÿ
A: 
1. å‡å°‘æ—¶é—´å¤æ‚åº¦ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•ï¼ˆå¦‚äºŒåˆ†æŸ¥æ‰¾ä»£æ›¿çº¿æ€§æŸ¥æ‰¾ï¼‰
2. å‡å°‘ç©ºé—´å¤æ‚åº¦ï¼šå¤ç”¨å˜é‡ï¼ŒåŸåœ°ä¿®æ”¹
3. ä½¿ç”¨ç¼“å­˜ï¼šåŠ¨æ€è§„åˆ’ã€è®°å¿†åŒ–æœç´¢
4. æå‰ç»ˆæ­¢ï¼šå‰ªæã€è¾¹ç•Œæ£€æŸ¥
5. ä½è¿ç®—ï¼šæ›¿ä»£ä¹˜é™¤æ³•è¿ç®—

### Q4: åŠ¨æ€è§„åˆ’çš„è§£é¢˜æ­¥éª¤æ˜¯ä»€ä¹ˆï¼Ÿ
A: 
1. å®šä¹‰çŠ¶æ€ï¼šç¡®å®šdpæ•°ç»„çš„å«ä¹‰
2. çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šæ‰¾å‡ºé€’æ¨å…³ç³»
3. åˆå§‹åŒ–ï¼šè®¾ç½®è¾¹ç•Œæ¡ä»¶
4. éå†é¡ºåºï¼šç¡®å®šè®¡ç®—é¡ºåº
5. è¿”å›ç»“æœï¼šæ ¹æ®é¢˜æ„è¿”å›

### Q5: å¦‚ä½•åˆ¤æ–­ä½¿ç”¨å“ªç§ç®—æ³•æ€æƒ³ï¼Ÿ
A: 
- è´ªå¿ƒï¼šå±€éƒ¨æœ€ä¼˜èƒ½å¯¼è‡´å…¨å±€æœ€ä¼˜
- åŠ¨æ€è§„åˆ’ï¼šæœ‰é‡å å­é—®é¢˜å’Œæœ€ä¼˜å­ç»“æ„
- å›æº¯ï¼šéœ€è¦æšä¸¾æ‰€æœ‰å¯èƒ½æ€§
- åˆ†æ²»ï¼šé—®é¢˜å¯ä»¥åˆ†è§£ä¸ºç‹¬ç«‹å­é—®é¢˜
- åŒæŒ‡é’ˆï¼šæœ‰åºæ•°ç»„æˆ–éœ€è¦ä¼˜åŒ–åµŒå¥—å¾ªç¯

### Q6: å¦‚ä½•é¿å…ç®—æ³•ä¸­çš„å¸¸è§é”™è¯¯ï¼Ÿ
A: 
1. æ•´æ•°æº¢å‡ºï¼šä½¿ç”¨longæˆ–æ£€æŸ¥è¾¹ç•Œ
2. æ•°ç»„è¶Šç•Œï¼šä»”ç»†æ£€æŸ¥ç´¢å¼•èŒƒå›´
3. ç©ºæŒ‡é’ˆï¼šæ·»åŠ nullæ£€æŸ¥
4. æ­»å¾ªç¯ï¼šç¡®ä¿å¾ªç¯æ¡ä»¶ä¼šæ”¹å˜
5. æ ˆæº¢å‡ºï¼šé™åˆ¶é€’å½’æ·±åº¦æˆ–æ”¹ç”¨è¿­ä»£

### Q7: LeetCodeåˆ·é¢˜æŠ€å·§ï¼Ÿ
A: 
1. æŒ‰æ ‡ç­¾åˆ†ç±»åˆ·é¢˜ï¼ˆæ•°ç»„ã€é“¾è¡¨ã€æ ‘ç­‰ï¼‰
2. å…ˆæ˜“åéš¾ï¼Œå¾ªåºæ¸è¿›
3. ä¸€é¢˜å¤šè§£ï¼Œå¯¹æ¯”ä¼˜åŠ£
4. å®šæœŸå¤ä¹ ï¼Œå·©å›ºè®°å¿†
5. å‚ä¸å‘¨èµ›ï¼Œæå‡é€Ÿåº¦
6. æ€»ç»“æ¨¡æ¿ï¼Œå½¢æˆå¥—è·¯

### Q8: å¦‚ä½•åˆ†æç®—æ³•å¤æ‚åº¦ï¼Ÿ
A: 
1. æ—¶é—´å¤æ‚åº¦ï¼š
   - å•å±‚å¾ªç¯ï¼šO(n)
   - åµŒå¥—å¾ªç¯ï¼šO(nÂ²)
   - äºŒåˆ†æŸ¥æ‰¾ï¼šO(log n)
   - é€’å½’ï¼šç”»é€’å½’æ ‘åˆ†æ
2. ç©ºé—´å¤æ‚åº¦ï¼š
   - é¢å¤–æ•°ç»„ï¼šO(n)
   - é€’å½’è°ƒç”¨æ ˆï¼šO(é€’å½’æ·±åº¦)
   - åŸåœ°ä¿®æ”¹ï¼šO(1)

## ğŸ”— ç›¸å…³èµ„æº

### ç»å…¸ä¹¦ç±
- [ã€Šç®—æ³•å¯¼è®ºã€‹](https://book.douban.com/subject/20432061/) - ç®—æ³•é¢†åŸŸçš„åœ£ç»
- [ã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹](https://book.douban.com/subject/1139426/) - Javaç‰ˆç»å…¸æ•™æ
- [ã€Šå‰‘æŒ‡Offerã€‹](https://book.douban.com/subject/27008702/) - é¢è¯•å¿…å¤‡
- [ã€Šç¼–ç¨‹ç ç‘ã€‹](https://book.douban.com/subject/3227098/) - ç®—æ³•æ€ç»´è®­ç»ƒ
- [ã€Šç®—æ³•å›¾è§£ã€‹](https://book.douban.com/subject/26979890/) - å›¾è§£å…¥é—¨ä¹¦ç±

### åœ¨çº¿å¹³å°
- [LeetCodeä¸­æ–‡](https://leetcode.cn/) - æœ€æµè¡Œçš„åˆ·é¢˜å¹³å°
- [ç‰›å®¢ç½‘](https://www.nowcoder.com/) - å›½å†…é¢è¯•é¢˜åº“
- [æ´›è°·](https://www.luogu.com.cn/) - ç®—æ³•ç«èµ›å¹³å°
- [Codeforces](https://codeforces.com/) - å›½é™…ç«èµ›å¹³å°
- [HackerRank](https://www.hackerrank.com/) - ç¼–ç¨‹æŒ‘æˆ˜å¹³å°

### å­¦ä¹ ç½‘ç«™
- [VisuAlgo](https://visualgo.net/zh) - ç®—æ³•å¯è§†åŒ–
- [GeeksforGeeks](https://www.geeksforgeeks.org/) - ç®—æ³•æ•™ç¨‹
- [ç®—æ³•å¯è§†åŒ–](https://algorithm-visualizer.org/) - åŠ¨ç”»æ¼”ç¤º
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/) - å¤æ‚åº¦é€ŸæŸ¥

### è§†é¢‘è¯¾ç¨‹
- [MITç®—æ³•å¯¼è®ºå…¬å¼€è¯¾](https://ocw.mit.edu/courses/introduction-to-algorithms/)
- [æ™®æ—æ–¯é¡¿ç®—æ³•è¯¾ç¨‹](https://www.coursera.org/learn/algorithms-part1)
- [ä¸­å›½å¤§å­¦MOOC - æ•°æ®ç»“æ„](https://www.icourse163.org/)

### GitHubèµ„æº
- [LeetCodeé¢˜è§£](https://github.com/azl397985856/leetcode)
- [ç®—æ³•æ¨¡æ¿](https://github.com/labuladong/fucking-algorithm)
- [Javaç®—æ³•å®ç°](https://github.com/TheAlgorithms/Java)

## ğŸ“ å­¦ä¹ æ£€æŸ¥æ¸…å•

### åŸºç¡€éƒ¨åˆ†ï¼ˆå¿…é¡»æŒæ¡ï¼‰
- [ ] ç†è§£æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
- [ ] æŒæ¡æ•°ç»„çš„åŸºæœ¬æ“ä½œ
- [ ] æŒæ¡é“¾è¡¨çš„å®ç°å’Œåè½¬
- [ ] æŒæ¡æ ˆå’Œé˜Ÿåˆ—çš„åº”ç”¨
- [ ] ç†è§£å“ˆå¸Œè¡¨çš„åŸç†å’Œåº”ç”¨
- [ ] æŒæ¡äºŒå‰æ ‘çš„éå†ï¼ˆå‰ä¸­ååºã€å±‚åºï¼‰
- [ ] æŒæ¡äºŒå‰æœç´¢æ ‘çš„æ“ä½œ
- [ ] ç†Ÿç»ƒä½¿ç”¨å†’æ³¡ã€é€‰æ‹©ã€æ’å…¥æ’åº
- [ ] ç†Ÿç»ƒä½¿ç”¨å¿«é€Ÿæ’åºå’Œå½’å¹¶æ’åº
- [ ] æŒæ¡äºŒåˆ†æŸ¥æ‰¾åŠå…¶å˜ä½“

### è¿›é˜¶éƒ¨åˆ†ï¼ˆé‡ç‚¹æŒæ¡ï¼‰
- [ ] ç†è§£å †çš„å®ç°å’Œåº”ç”¨
- [ ] æŒæ¡åŠ¨æ€è§„åˆ’çš„åŸºæœ¬æ€æƒ³
- [ ] æŒæ¡è´ªå¿ƒç®—æ³•çš„åº”ç”¨åœºæ™¯
- [ ] ç†è§£å›æº¯ç®—æ³•çš„æ¨¡æ¿
- [ ] æŒæ¡DFSå’ŒBFSçš„åº”ç”¨
- [ ] ç†è§£å›¾çš„åŸºæœ¬ç®—æ³•ï¼ˆæœ€çŸ­è·¯å¾„ã€æ‹“æ‰‘æ’åºï¼‰
- [ ] æŒæ¡å¹¶æŸ¥é›†çš„å®ç°
- [ ] ç†è§£æ»‘åŠ¨çª—å£ç®—æ³•
- [ ] æŒæ¡åŒæŒ‡é’ˆæŠ€å·§
- [ ] ç†è§£å•è°ƒæ ˆçš„åº”ç”¨

### é«˜çº§éƒ¨åˆ†ï¼ˆé€‰æ‹©æŒæ¡ï¼‰
- [ ] æŒæ¡Trieæ ‘çš„å®ç°
- [ ] ç†è§£çº¿æ®µæ ‘å’Œæ ‘çŠ¶æ•°ç»„
- [ ] æŒæ¡KMPå­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
- [ ] ç†è§£AVLæ ‘å’Œçº¢é»‘æ ‘
- [ ] æŒæ¡æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ï¼ˆPrimã€Kruskalï¼‰
- [ ] ç†è§£ç½‘ç»œæµç®—æ³•
- [ ] æŒæ¡ACè‡ªåŠ¨æœº
- [ ] ç†è§£åç¼€æ•°ç»„å’Œåç¼€æ ‘

### å®æˆ˜èƒ½åŠ›
- [ ] èƒ½å¤Ÿåˆ†æç®—æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
- [ ] èƒ½å¤Ÿé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„è§£å†³é—®é¢˜
- [ ] èƒ½å¤Ÿä¼˜åŒ–ç®—æ³•æ€§èƒ½
- [ ] èƒ½å¤Ÿç‹¬ç«‹å®ŒæˆLeetCodeä¸­ç­‰éš¾åº¦é¢˜ç›®
- [ ] èƒ½å¤Ÿåœ¨é¢è¯•ä¸­æ¸…æ™°è¡¨è¾¾ç®—æ³•æ€è·¯
- [ ] èƒ½å¤Ÿåœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨ç®—æ³•çŸ¥è¯†

### LeetCodeåˆ·é¢˜è¿›åº¦
- [ ] æ•°ç»„ç±»é¢˜ç›®ï¼š50é¢˜
- [ ] é“¾è¡¨ç±»é¢˜ç›®ï¼š30é¢˜
- [ ] æ ‘ç±»é¢˜ç›®ï¼š50é¢˜
- [ ] åŠ¨æ€è§„åˆ’ï¼š40é¢˜
- [ ] å›æº¯ç®—æ³•ï¼š20é¢˜
- [ ] å›¾ç®—æ³•ï¼š20é¢˜
- [ ] å­—ç¬¦ä¸²ï¼š30é¢˜
- [ ] å…¶ä»–ï¼š30é¢˜
- [ ] æ€»è®¡ï¼š270é¢˜+

---

**å­¦ä¹ å»ºè®®**ï¼š
1. å…ˆç†è§£æ•°æ®ç»“æ„ï¼Œå†å­¦ä¹ ç®—æ³•
2. å¤šåˆ·LeetCodeé¢˜ç›®ï¼ŒæŒ‰æ ‡ç­¾åˆ†ç±»åˆ·
3. ç†è§£ç®—æ³•æ€æƒ³æ¯”è®°ä½ä»£ç æ›´é‡è¦
4. å…³æ³¨æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦çš„åˆ†æ
5. åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨æ‰€å­¦çŸ¥è¯†
6. å®šæœŸå¤ä¹ ï¼Œå½¢æˆè‚Œè‚‰è®°å¿†
7. å‚ä¸ç®—æ³•ç«èµ›ï¼Œæå‡ç¼–ç é€Ÿåº¦
8. æ€»ç»“å¸¸è§æ¨¡æ¿å’Œå¥—è·¯

**å­¦ä¹ è·¯çº¿**ï¼š
1. ç¬¬1-2å‘¨ï¼šå¤æ‚åº¦åˆ†æ + æ•°ç»„ + é“¾è¡¨
2. ç¬¬3-4å‘¨ï¼šæ ˆ + é˜Ÿåˆ— + å“ˆå¸Œè¡¨
3. ç¬¬5-6å‘¨ï¼šæ ‘ + äºŒå‰æœç´¢æ ‘ + å †
4. ç¬¬7-8å‘¨ï¼šæ’åºç®—æ³• + æŸ¥æ‰¾ç®—æ³•
5. ç¬¬9-10å‘¨ï¼šé€’å½’ + åˆ†æ²» + å›æº¯
6. ç¬¬11-12å‘¨ï¼šåŠ¨æ€è§„åˆ’ï¼ˆé‡ç‚¹ï¼‰
7. ç¬¬13-14å‘¨ï¼šè´ªå¿ƒ + åŒæŒ‡é’ˆ + æ»‘åŠ¨çª—å£
8. ç¬¬15-16å‘¨ï¼šå›¾ç®—æ³• + é«˜çº§æ•°æ®ç»“æ„
9. ç¬¬17-18å‘¨ï¼šå­—ç¬¦ä¸²ç®—æ³• + ä½è¿ç®—
10. ç¬¬19-20å‘¨ï¼šç»¼åˆç»ƒä¹  + æ¨¡æ‹Ÿé¢è¯•

**æ¯æ—¥å­¦ä¹ è®¡åˆ’**ï¼š
- ç†è®ºå­¦ä¹ ï¼š30åˆ†é’Ÿï¼ˆçœ‹æ•™ç¨‹ã€è§†é¢‘ï¼‰
- ä»£ç å®ç°ï¼š30åˆ†é’Ÿï¼ˆæ‰‹å†™æ•°æ®ç»“æ„å’Œç®—æ³•ï¼‰
- åˆ·é¢˜ç»ƒä¹ ï¼š60åˆ†é’Ÿï¼ˆ2-3é“LeetCodeé¢˜ç›®ï¼‰
- å¤ä¹ æ€»ç»“ï¼š30åˆ†é’Ÿï¼ˆæ•´ç†ç¬”è®°ã€æ€»ç»“æ¨¡æ¿ï¼‰

**é¢è¯•å‡†å¤‡**ï¼š
- ç†Ÿç»ƒæŒæ¡å¸¸è§æ•°æ®ç»“æ„çš„å®ç°
- èƒ½å¤Ÿå¿«é€Ÿè¯†åˆ«é¢˜ç›®ç±»å‹
- æŒæ¡å¸¸è§ç®—æ³•æ¨¡æ¿
- ç»ƒä¹ ç™½æ¿ç¼–ç¨‹
- æå‡ä»£ç è§„èŒƒæ€§
- å­¦ä¼šåˆ†æè¾¹ç•Œæ¡ä»¶

---

**ä½œè€…**: erik.zhou  
**æœ€åæ›´æ–°**: 2024-01-04
