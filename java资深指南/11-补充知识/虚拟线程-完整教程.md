# Java è™šæ‹Ÿçº¿ç¨‹ (Virtual Threads) - å®Œæ•´æ•™ç¨‹

> ğŸ“š **ç‰ˆæœ¬**: Java 21+ (LTS), Java 24  
> ğŸ¯ **å­¦ä¹ éš¾åº¦**: â­â­â­â­  
> ğŸ”¥ **é‡è¦ç¨‹åº¦**: â­â­â­â­â­  
> â±ï¸ **é¢„è®¡å­¦ä¹ æ—¶é•¿**: 15-20å°æ—¶  
> ğŸ“… **æœ€åæ›´æ–°**: 2025-02-01  
> ğŸ‘¤ **ä½œè€…**: erik.zhou

---

## ğŸ“– ç›®å½•

- [æŠ€æœ¯æ¦‚è¿°](#æŠ€æœ¯æ¦‚è¿°)
- [å­¦ä¹ ç›®æ ‡](#å­¦ä¹ ç›®æ ‡)
- [å‰ç½®çŸ¥è¯†](#å‰ç½®çŸ¥è¯†)
- [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
- [åˆ›å»ºè™šæ‹Ÿçº¿ç¨‹](#åˆ›å»ºè™šæ‹Ÿçº¿ç¨‹)
- [è™šæ‹Ÿçº¿ç¨‹åŸç†](#è™šæ‹Ÿçº¿ç¨‹åŸç†)
- [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
- [Spring Booté›†æˆ](#spring-booté›†æˆ)
- [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
- [å­¦ä¹ æ£€æŸ¥æ¸…å•](#å­¦ä¹ æ£€æŸ¥æ¸…å•)

---

## ğŸ“š æŠ€æœ¯æ¦‚è¿°

### ä»€ä¹ˆæ˜¯è™šæ‹Ÿçº¿ç¨‹ï¼Ÿ

è™šæ‹Ÿçº¿ç¨‹ï¼ˆVirtual Threadsï¼‰æ˜¯Java 21å¼•å…¥çš„è½»é‡çº§çº¿ç¨‹å®ç°ï¼Œå®ƒæ˜¯Project Loomçš„æ ¸å¿ƒæˆæœã€‚è™šæ‹Ÿçº¿ç¨‹å…è®¸å¼€å‘è€…ç¼–å†™é«˜ååé‡çš„å¹¶å‘åº”ç”¨ï¼Œè€Œæ— éœ€æ”¹å˜ä¼ ç»Ÿçš„åŒæ­¥ç¼–ç¨‹æ¨¡å‹ã€‚

### ç‰ˆæœ¬ä¿¡æ¯

- **é¦–æ¬¡å¼•å…¥**: Java 19 (é¢„è§ˆ)
- **æ­£å¼å‘å¸ƒ**: Java 21 (LTS)
- **å¢å¼ºç‰ˆæœ¬**: Java 24
- **JEPç¼–å·**: JEP 444

### æ ¸å¿ƒç‰¹ç‚¹

| ç‰¹æ€§ | å¹³å°çº¿ç¨‹ | è™šæ‹Ÿçº¿ç¨‹ |
|------|---------|---------|
| åˆ›å»ºæˆæœ¬ | é«˜ï¼ˆ~2MBæ ˆç©ºé—´ï¼‰ | ä½ï¼ˆ~1KBï¼‰ |
| æ•°é‡é™åˆ¶ | æ•°åƒä¸ª | æ•°ç™¾ä¸‡ä¸ª |
| è°ƒåº¦æ–¹å¼ | OSè°ƒåº¦ | JVMè°ƒåº¦ |
| é˜»å¡æˆæœ¬ | é«˜ | ä½ |
| é€‚ç”¨åœºæ™¯ | CPUå¯†é›†å‹ | I/Oå¯†é›†å‹ |

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å­¦å®Œæœ¬æ•™ç¨‹åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… ç†è§£è™šæ‹Ÿçº¿ç¨‹çš„å·¥ä½œåŸç†å’Œä¼˜åŠ¿
- âœ… æŒæ¡åˆ›å»ºå’Œä½¿ç”¨è™šæ‹Ÿçº¿ç¨‹çš„å¤šç§æ–¹å¼
- âœ… ç†è§£è™šæ‹Ÿçº¿ç¨‹çš„è°ƒåº¦æœºåˆ¶
- âœ… è¯†åˆ«è™šæ‹Ÿçº¿ç¨‹çš„é€‚ç”¨åœºæ™¯
- âœ… é¿å…è™šæ‹Ÿçº¿ç¨‹çš„å¸¸è§é™·é˜±
- âœ… åœ¨Spring Bootä¸­é›†æˆè™šæ‹Ÿçº¿ç¨‹
- âœ… ä¼˜åŒ–é«˜å¹¶å‘åº”ç”¨çš„æ€§èƒ½

---

## ğŸ“– å‰ç½®çŸ¥è¯†

åœ¨å­¦ä¹ æœ¬æ•™ç¨‹å‰ï¼Œä½ éœ€è¦æŒæ¡ï¼š

- âœ… Javaå¤šçº¿ç¨‹åŸºç¡€ï¼ˆThreadã€Runnableã€ExecutorServiceï¼‰
- âœ… å¹¶å‘ç¼–ç¨‹æ¦‚å¿µï¼ˆåŒæ­¥ã€é”ã€çº¿ç¨‹æ± ï¼‰
- âœ… Lambdaè¡¨è¾¾å¼å’Œå‡½æ•°å¼æ¥å£
- âœ… CompletableFutureçš„ä½¿ç”¨
- âœ… I/Oæ“ä½œå’Œé˜»å¡æ¦‚å¿µ

---

## ğŸ”¥ æ ¸å¿ƒæ¦‚å¿µ

### 1. å¹³å°çº¿ç¨‹ vs è™šæ‹Ÿçº¿ç¨‹

#### å¹³å°çº¿ç¨‹ï¼ˆä¼ ç»Ÿçº¿ç¨‹ï¼‰

```java
public class PlatformThreadExample {
    
    public static void main(String[] args) {
        // åˆ›å»ºå¹³å°çº¿ç¨‹
        Thread platformThread = new Thread(() -> {
            System.out.println("Running in platform thread: " + 
                Thread.currentThread());
        });
        platformThread.start();
        
        // å¹³å°çº¿ç¨‹ç‰¹ç‚¹ï¼š
        // 1. 1:1æ˜ å°„åˆ°OSçº¿ç¨‹
        // 2. åˆ›å»ºæˆæœ¬é«˜ï¼ˆ~2MBæ ˆç©ºé—´ï¼‰
        // 3. æ•°é‡å—é™ï¼ˆé€šå¸¸å‡ åƒä¸ªï¼‰
        // 4. é˜»å¡æ—¶å ç”¨OSçº¿ç¨‹èµ„æº
    }
}
```

#### è™šæ‹Ÿçº¿ç¨‹

```java
public class VirtualThreadExample {
    
    public static void main(String[] args) {
        // åˆ›å»ºè™šæ‹Ÿçº¿ç¨‹
        Thread virtualThread = Thread.ofVirtual().start(() -> {
            System.out.println("Running in virtual thread: " + 
                Thread.currentThread());
        });
        
        // è™šæ‹Ÿçº¿ç¨‹ç‰¹ç‚¹ï¼š
        // 1. M:Næ˜ å°„åˆ°å¹³å°çº¿ç¨‹ï¼ˆè½½ä½“çº¿ç¨‹ï¼‰
        // 2. åˆ›å»ºæˆæœ¬ä½ï¼ˆ~1KBï¼‰
        // 3. å¯åˆ›å»ºæ•°ç™¾ä¸‡ä¸ª
        // 4. é˜»å¡æ—¶è‡ªåŠ¨å¸è½½ï¼Œä¸å ç”¨è½½ä½“çº¿ç¨‹
    }
}
```

### 2. è™šæ‹Ÿçº¿ç¨‹çš„å·¥ä½œåŸç†

âš ï¸ **éš¾ç‚¹**: ç†è§£è™šæ‹Ÿçº¿ç¨‹çš„è°ƒåº¦æœºåˆ¶

```java
/**
 * è™šæ‹Ÿçº¿ç¨‹è°ƒåº¦åŸç†ç¤ºæ„
 * 
 * å¹³å°çº¿ç¨‹ï¼ˆè½½ä½“çº¿ç¨‹ï¼‰æ± ï¼š
 * [PT1] [PT2] [PT3] [PT4] ... [PTn]
 *   â†‘     â†‘     â†‘     â†‘
 *   |     |     |     |
 * [VT1] [VT2] [VT3] [VT4] ... [VTm]  (m >> n)
 * 
 * å½“è™šæ‹Ÿçº¿ç¨‹é˜»å¡æ—¶ï¼š
 * 1. è™šæ‹Ÿçº¿ç¨‹ä»è½½ä½“çº¿ç¨‹å¸è½½ï¼ˆunmountï¼‰
 * 2. è½½ä½“çº¿ç¨‹å¯ä»¥è¿è¡Œå…¶ä»–è™šæ‹Ÿçº¿ç¨‹
 * 3. é˜»å¡ç»“æŸåï¼Œè™šæ‹Ÿçº¿ç¨‹é‡æ–°æŒ‚è½½ï¼ˆmountï¼‰åˆ°è½½ä½“çº¿ç¨‹
 */
public class VirtualThreadScheduling {
    
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»º100ä¸‡ä¸ªè™šæ‹Ÿçº¿ç¨‹
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 1_000_000; i++) {
                int taskId = i;
                executor.submit(() -> {
                    // æ¨¡æ‹ŸI/Oæ“ä½œï¼ˆé˜»å¡ï¼‰
                    Thread.sleep(Duration.ofSeconds(1));
                    System.out.println("Task " + taskId + " completed");
                    return taskId;
                });
            }
        }
        // è™šæ‹Ÿçº¿ç¨‹åœ¨é˜»å¡æ—¶è‡ªåŠ¨å¸è½½ï¼Œä¸ä¼šå ç”¨è½½ä½“çº¿ç¨‹
        // å®é™…åªéœ€è¦å°‘é‡è½½ä½“çº¿ç¨‹ï¼ˆé€šå¸¸ç­‰äºCPUæ ¸å¿ƒæ•°ï¼‰
    }
}
```

---

## ğŸ”¥ åˆ›å»ºè™šæ‹Ÿçº¿ç¨‹

### 1. ä½¿ç”¨ Thread.ofVirtual()

```java
public class CreateVirtualThread {
    
    public static void main(String[] args) throws InterruptedException {
        // æ–¹å¼1: åˆ›å»ºå¹¶å¯åŠ¨
        Thread vt1 = Thread.ofVirtual().start(() -> {
            System.out.println("Virtual thread 1");
        });
        
        // æ–¹å¼2: åˆ›å»ºä½†ä¸å¯åŠ¨
        Thread vt2 = Thread.ofVirtual().unstarted(() -> {
            System.out.println("Virtual thread 2");
        });
        vt2.start();
        
        // æ–¹å¼3: è®¾ç½®çº¿ç¨‹åç§°
        Thread vt3 = Thread.ofVirtual()
            .name("my-virtual-thread")
            .start(() -> {
                System.out.println("Thread name: " + 
                    Thread.currentThread().getName());
            });
        
        // æ–¹å¼4: ä½¿ç”¨å·¥å‚æ¨¡å¼
        ThreadFactory factory = Thread.ofVirtual().factory();
        Thread vt4 = factory.newThread(() -> {
            System.out.println("Virtual thread from factory");
        });
        vt4.start();
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        vt1.join();
        vt2.join();
        vt3.join();
        vt4.join();
    }
}
```

### 2. ä½¿ç”¨ Thread.startVirtualThread()

```java
public class StartVirtualThread {
    
    public static void main(String[] args) {
        // å¿«é€Ÿåˆ›å»ºå¹¶å¯åŠ¨è™šæ‹Ÿçº¿ç¨‹
        Thread vt = Thread.startVirtualThread(() -> {
            System.out.println("Quick virtual thread");
        });
        
        // ç­‰ä»·äºï¼š
        // Thread.ofVirtual().start(() -> { ... });
    }
}
```

### 3. ä½¿ç”¨ ExecutorService

ğŸ”¥ **é‡ç‚¹**: æ¨èåœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ExecutorService

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

public class VirtualThreadExecutor {
    
    public static void main(String[] args) throws Exception {
        // åˆ›å»ºè™šæ‹Ÿçº¿ç¨‹æ‰§è¡Œå™¨
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // æäº¤ä»»åŠ¡
            Future<String> future = executor.submit(() -> {
                Thread.sleep(1000);
                return "Task completed";
            });
            
            // è·å–ç»“æœ
            String result = future.get();
            System.out.println(result);
            
            // æ‰¹é‡æäº¤ä»»åŠ¡
            List<Future<Integer>> futures = new ArrayList<>();
            for (int i = 0; i < 10000; i++) {
                int taskId = i;
                Future<Integer> f = executor.submit(() -> {
                    Thread.sleep(100);
                    return taskId;
                });
                futures.add(f);
            }
            
            // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            for (Future<Integer> f : futures) {
                f.get();
            }
        }
        // try-with-resourcesè‡ªåŠ¨å…³é—­executor
    }
}
```

---

## ğŸ”¥ æ€§èƒ½å¯¹æ¯”

### 1. ååé‡å¯¹æ¯”

```java
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.Executors;

public class PerformanceComparison {
    
    private static final int TASK_COUNT = 10000;
    private static final Duration SLEEP_DURATION = Duration.ofMillis(100);
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("Testing with " + TASK_COUNT + " tasks...\n");
        
        testPlatformThreads();
        testVirtualThreads();
    }
    
    static void testPlatformThreads() throws InterruptedException {
        System.out.println("=== Platform Threads ===");
        Instant start = Instant.now();
        
        // ä½¿ç”¨å›ºå®šå¤§å°çš„çº¿ç¨‹æ± 
        try (var executor = Executors.newFixedThreadPool(200)) {
            for (int i = 0; i < TASK_COUNT; i++) {
                executor.submit(() -> {
                    try {
                        Thread.sleep(SLEEP_DURATION);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            }
        }
        
        Duration duration = Duration.between(start, Instant.now());
        System.out.println("Time: " + duration.toMillis() + "ms");
        System.out.println("Throughput: " + 
            (TASK_COUNT * 1000.0 / duration.toMillis()) + " tasks/sec\n");
    }
    
    static void testVirtualThreads() throws InterruptedException {
        System.out.println("=== Virtual Threads ===");
        Instant start = Instant.now();
        
        // ä½¿ç”¨è™šæ‹Ÿçº¿ç¨‹æ‰§è¡Œå™¨
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < TASK_COUNT; i++) {
                executor.submit(() -> {
                    try {
                        Thread.sleep(SLEEP_DURATION);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            }
        }
        
        Duration duration = Duration.between(start, Instant.now());
        System.out.println("Time: " + duration.toMillis() + "ms");
        System.out.println("Throughput: " + 
            (TASK_COUNT * 1000.0 / duration.toMillis()) + " tasks/sec\n");
    }
}

/**
 * å…¸å‹è¾“å‡ºï¼š
 * 
 * === Platform Threads ===
 * Time: 5000ms
 * Throughput: 2000 tasks/sec
 * 
 * === Virtual Threads ===
 * Time: 150ms
 * Throughput: 66666 tasks/sec
 * 
 * è™šæ‹Ÿçº¿ç¨‹ååé‡æå‡çº¦33å€ï¼
 */
```

### 2. å†…å­˜å ç”¨å¯¹æ¯”

```java
public class MemoryComparison {
    
    public static void main(String[] args) throws InterruptedException {
        Runtime runtime = Runtime.getRuntime();
        
        // æµ‹è¯•å¹³å°çº¿ç¨‹å†…å­˜å ç”¨
        System.out.println("=== Platform Threads ===");
        long beforePlatform = runtime.totalMemory() - runtime.freeMemory();
        
        List<Thread> platformThreads = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            Thread t = new Thread(() -> {
                try {
                    Thread.sleep(Duration.ofMinutes(1));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
            t.start();
            platformThreads.add(t);
        }
        
        Thread.sleep(1000); // ç­‰å¾…çº¿ç¨‹å¯åŠ¨
        long afterPlatform = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used: " + 
            (afterPlatform - beforePlatform) / 1024 / 1024 + " MB");
        
        // æ¸…ç†
        platformThreads.forEach(Thread::interrupt);
        
        // æµ‹è¯•è™šæ‹Ÿçº¿ç¨‹å†…å­˜å ç”¨
        System.out.println("\n=== Virtual Threads ===");
        long beforeVirtual = runtime.totalMemory() - runtime.freeMemory();
        
        List<Thread> virtualThreads = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            Thread t = Thread.ofVirtual().start(() -> {
                try {
                    Thread.sleep(Duration.ofMinutes(1));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
            virtualThreads.add(t);
        }
        
        Thread.sleep(1000); // ç­‰å¾…çº¿ç¨‹å¯åŠ¨
        long afterVirtual = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used: " + 
            (afterVirtual - beforeVirtual) / 1024 / 1024 + " MB");
        
        // æ¸…ç†
        virtualThreads.forEach(Thread::interrupt);
    }
}

/**
 * å…¸å‹è¾“å‡ºï¼š
 * 
 * === Platform Threads ===
 * Memory used: ~2000 MB (æ¯ä¸ªçº¿ç¨‹~2MB)
 * 
 * === Virtual Threads ===
 * Memory used: ~1 MB (æ¯ä¸ªçº¿ç¨‹~1KB)
 * 
 * è™šæ‹Ÿçº¿ç¨‹å†…å­˜å ç”¨é™ä½çº¦2000å€ï¼
 */
```

---

## âœ¨ æœ€ä½³å®è·µ

### 1. é€‚ç”¨åœºæ™¯

```java
public class UseCases {
    
    // âœ… æ¨è: I/Oå¯†é›†å‹ä»»åŠ¡
    static void ioIntensiveTasks() {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            // æ•°æ®åº“æŸ¥è¯¢
            executor.submit(() -> queryDatabase());
            
            // HTTPè¯·æ±‚
            executor.submit(() -> callExternalApi());
            
            // æ–‡ä»¶è¯»å†™
            executor.submit(() -> readFile());
            
            // ç½‘ç»œé€šä¿¡
            executor.submit(() -> sendNetworkRequest());
        }
    }
    
    // âŒ ä¸æ¨è: CPUå¯†é›†å‹ä»»åŠ¡
    static void cpuIntensiveTasks() {
        // CPUå¯†é›†å‹ä»»åŠ¡åº”ä½¿ç”¨å¹³å°çº¿ç¨‹
        int cores = Runtime.getRuntime().availableProcessors();
        try (var executor = Executors.newFixedThreadPool(cores)) {
            // å›¾åƒå¤„ç†
            executor.submit(() -> processImage());
            
            // åŠ å¯†è§£å¯†
            executor.submit(() -> encryptData());
            
            // å¤æ‚è®¡ç®—
            executor.submit(() -> performCalculation());
        }
    }
}
```

### 2. é¿å…å›ºå®šï¼ˆPinningï¼‰

âš ï¸ **éš¾ç‚¹**: ç†è§£è™šæ‹Ÿçº¿ç¨‹å›ºå®šé—®é¢˜

```java
import java.util.concurrent.locks.ReentrantLock;

public class AvoidPinning {
    
    private static final Object lock = new Object();
    private static final ReentrantLock reentrantLock = new ReentrantLock();
    
    // âŒ ä¸æ¨è: synchronizedä¼šå¯¼è‡´è™šæ‹Ÿçº¿ç¨‹å›ºå®š
    static void badExample() {
        Thread.ofVirtual().start(() -> {
            synchronized (lock) {
                // é•¿æ—¶é—´æ“ä½œä¼šå›ºå®šè™šæ‹Ÿçº¿ç¨‹åˆ°è½½ä½“çº¿ç¨‹
                // å¤±å»è™šæ‹Ÿçº¿ç¨‹çš„ä¼˜åŠ¿
                try {
                    Thread.sleep(Duration.ofSeconds(10));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
    }
    
    // âœ… æ¨è: ä½¿ç”¨ReentrantLock
    static void goodExample() {
        Thread.ofVirtual().start(() -> {
            reentrantLock.lock();
            try {
                // é•¿æ—¶é—´æ“ä½œä¸ä¼šå›ºå®šè™šæ‹Ÿçº¿ç¨‹
                Thread.sleep(Duration.ofSeconds(10));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                reentrantLock.unlock();
            }
        });
    }
    
    // âœ… æ¨è: ä½¿ç”¨synchronizedä½†æ“ä½œå¾ˆå¿«
    static void acceptableExample() {
        Thread.ofVirtual().start(() -> {
            synchronized (lock) {
                // å¿«é€Ÿæ“ä½œå¯ä»¥æ¥å—
                counter++;
            }
        });
    }
}
```

### 3. çº¿ç¨‹æ± é…ç½®

```java
public class ThreadPoolConfiguration {
    
    // âœ… æ¨è: è™šæ‹Ÿçº¿ç¨‹ä¸éœ€è¦é™åˆ¶æ•°é‡
    static ExecutorService createVirtualThreadExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
        // æ¯ä¸ªä»»åŠ¡ä¸€ä¸ªè™šæ‹Ÿçº¿ç¨‹ï¼Œæ— éœ€æ‹…å¿ƒèµ„æºè€—å°½
    }
    
    // âœ… æ¨è: ä¸ºCPUå¯†é›†å‹ä»»åŠ¡åˆ›å»ºå¹³å°çº¿ç¨‹æ± 
    static ExecutorService createPlatformThreadExecutor() {
        int cores = Runtime.getRuntime().availableProcessors();
        return Executors.newFixedThreadPool(cores);
    }
    
    // âœ… æ¨è: æ··åˆä½¿ç”¨
    static class HybridExecutor {
        private final ExecutorService ioExecutor = 
            Executors.newVirtualThreadPerTaskExecutor();
        private final ExecutorService cpuExecutor = 
            Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors()
            );
        
        public void submitIoTask(Runnable task) {
            ioExecutor.submit(task);
        }
        
        public void submitCpuTask(Runnable task) {
            cpuExecutor.submit(task);
        }
        
        public void shutdown() {
            ioExecutor.shutdown();
            cpuExecutor.shutdown();
        }
    }
}
```

---

## âš ï¸ å¸¸è§é™·é˜±

### 1. ThreadLocalä½¿ç”¨

```java
public class ThreadLocalPitfall {
    
    private static final ThreadLocal<String> threadLocal = new ThreadLocal<>();
    
    // âš ï¸ æ³¨æ„: è™šæ‹Ÿçº¿ç¨‹æ•°é‡å·¨å¤§ï¼ŒThreadLocalå¯èƒ½å¯¼è‡´å†…å­˜é—®é¢˜
    static void problematicUsage() {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 1_000_000; i++) {
                executor.submit(() -> {
                    // æ¯ä¸ªè™šæ‹Ÿçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„ThreadLocalå‰¯æœ¬
                    threadLocal.set("Large data: " + new byte[1024]);
                    // å¦‚æœå¿˜è®°æ¸…ç†ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼
                    doWork();
                    // threadLocal.remove(); // å¿…é¡»æ¸…ç†ï¼
                });
            }
        }
    }
    
    // âœ… æ¨è: ä½¿ç”¨ScopedValueï¼ˆJava 21+ï¼‰
    private static final ScopedValue<String> scopedValue = 
        ScopedValue.newInstance();
    
    static void betterApproach() {
        ScopedValue.where(scopedValue, "data").run(() -> {
            // ä½œç”¨åŸŸç»“æŸè‡ªåŠ¨æ¸…ç†
            doWork();
        });
    }
}
```

### 2. ç›‘æ§å’Œè°ƒè¯•

```java
public class MonitoringAndDebugging {
    
    public static void main(String[] args) {
        // æ£€æŸ¥å½“å‰çº¿ç¨‹æ˜¯å¦ä¸ºè™šæ‹Ÿçº¿ç¨‹
        boolean isVirtual = Thread.currentThread().isVirtual();
        System.out.println("Is virtual thread: " + isVirtual);
        
        // è·å–è™šæ‹Ÿçº¿ç¨‹ä¿¡æ¯
        Thread vt = Thread.ofVirtual().start(() -> {
            System.out.println("Thread: " + Thread.currentThread());
            System.out.println("Is virtual: " + Thread.currentThread().isVirtual());
            System.out.println("Thread ID: " + Thread.currentThread().threadId());
        });
        
        // å¯ç”¨è™šæ‹Ÿçº¿ç¨‹è°ƒè¯•
        // JVMå‚æ•°: -Djdk.tracePinnedThreads=full
        // å¯ä»¥è¿½è¸ªè™šæ‹Ÿçº¿ç¨‹å›ºå®šé—®é¢˜
    }
}
```

---

## ğŸ”¥ Spring Booté›†æˆ

### 1. å¯ç”¨è™šæ‹Ÿçº¿ç¨‹

```yaml
# application.yml
spring:
  threads:
    virtual:
      enabled: true  # Spring Boot 4.0+
```

```java
@SpringBootApplication
public class VirtualThreadApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(VirtualThreadApplication.class, args);
    }
    
    // Spring Boot 3.xéœ€è¦æ‰‹åŠ¨é…ç½®
    @Bean
    public AsyncTaskExecutor applicationTaskExecutor() {
        SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
        executor.setVirtualThreads(true);
        return executor;
    }
}
```

### 2. Webè¯·æ±‚å¤„ç†

```java
@RestController
@RequestMapping("/api")
public class VirtualThreadController {
    
    @Autowired
    private UserService userService;
    
    // æ¯ä¸ªè¯·æ±‚è‡ªåŠ¨åœ¨è™šæ‹Ÿçº¿ç¨‹ä¸­å¤„ç†
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        // é˜»å¡è°ƒç”¨ä¸ä¼šé˜»å¡è½½ä½“çº¿ç¨‹
        return userService.findById(id);
    }
    
    @GetMapping("/users")
    public List<User> getAllUsers() {
        // å¯ä»¥å¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚
        return userService.findAll();
    }
}
```

### 3. å¼‚æ­¥ä»»åŠ¡

```java
@Service
public class AsyncService {
    
    @Async  // è‡ªåŠ¨ä½¿ç”¨è™šæ‹Ÿçº¿ç¨‹
    public CompletableFuture<String> asyncTask() {
        // é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
        Thread.sleep(Duration.ofSeconds(5));
        return CompletableFuture.completedFuture("Done");
    }
    
    @Async
    public void fireAndForget() {
        // ä¸éœ€è¦è¿”å›å€¼çš„å¼‚æ­¥ä»»åŠ¡
        processData();
    }
}
```

---

## ğŸ’» å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: é«˜å¹¶å‘APIç½‘å…³

```java
@RestController
public class ApiGateway {
    
    private final RestTemplate restTemplate = new RestTemplate();
    
    @GetMapping("/aggregate")
    public Map<String, Object> aggregateData(@RequestParam String userId) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // å¹¶å‘è°ƒç”¨å¤šä¸ªå¾®æœåŠ¡
            Future<User> userFuture = executor.submit(() -> 
                restTemplate.getForObject(
                    "http://user-service/users/" + userId, 
                    User.class
                )
            );
            
            Future<List<Order>> ordersFuture = executor.submit(() ->
                restTemplate.exchange(
                    "http://order-service/orders?userId=" + userId,
                    HttpMethod.GET,
                    null,
                    new ParameterizedTypeReference<List<Order>>() {}
                ).getBody()
            );
            
            Future<Account> accountFuture = executor.submit(() ->
                restTemplate.getForObject(
                    "http://account-service/accounts/" + userId,
                    Account.class
                )
            );
            
            // ç­‰å¾…æ‰€æœ‰ç»“æœ
            return Map.of(
                "user", userFuture.get(),
                "orders", ordersFuture.get(),
                "account", accountFuture.get()
            );
        } catch (Exception e) {
            throw new RuntimeException("Failed to aggregate data", e);
        }
    }
}
```

### æ¡ˆä¾‹2: æ‰¹é‡æ•°æ®å¤„ç†

```java
@Service
public class BatchProcessor {
    
    @Autowired
    private DataRepository repository;
    
    public void processBatch(List<Long> ids) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            List<Future<Void>> futures = ids.stream()
                .map(id -> executor.submit(() -> {
                    // æ¯ä¸ªIDåœ¨ç‹¬ç«‹çš„è™šæ‹Ÿçº¿ç¨‹ä¸­å¤„ç†
                    Data data = repository.findById(id);
                    processData(data);
                    repository.save(data);
                    return null;
                }))
                .toList();
            
            // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            for (Future<Void> future : futures) {
                future.get();
            }
        } catch (Exception e) {
            throw new RuntimeException("Batch processing failed", e);
        }
    }
    
    private void processData(Data data) {
        // æ•°æ®å¤„ç†é€»è¾‘
    }
}
```

---

## â“ å¸¸è§é—®é¢˜

### Q1: è™šæ‹Ÿçº¿ç¨‹é€‚åˆæ‰€æœ‰åœºæ™¯å—ï¼Ÿ
A: ä¸æ˜¯ã€‚è™šæ‹Ÿçº¿ç¨‹é€‚åˆI/Oå¯†é›†å‹ä»»åŠ¡ï¼Œå¯¹äºCPUå¯†é›†å‹ä»»åŠ¡ï¼Œä¼ ç»Ÿå¹³å°çº¿ç¨‹ä»ç„¶æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚

### Q2: è™šæ‹Ÿçº¿ç¨‹ä¼šæ›¿ä»£å¹³å°çº¿ç¨‹å—ï¼Ÿ
A: ä¸ä¼šå®Œå…¨æ›¿ä»£ã€‚è™šæ‹Ÿçº¿ç¨‹å’Œå¹³å°çº¿ç¨‹å„æœ‰ä¼˜åŠ¿ï¼Œåº”æ ¹æ®åœºæ™¯é€‰æ‹©ä½¿ç”¨ã€‚

### Q3: å¦‚ä½•ç›‘æ§è™šæ‹Ÿçº¿ç¨‹ï¼Ÿ
A: ä½¿ç”¨JVMå‚æ•°`-Djdk.tracePinnedThreads=full`è¿½è¸ªå›ºå®šé—®é¢˜ï¼Œä½¿ç”¨JFRï¼ˆJava Flight Recorderï¼‰ç›‘æ§æ€§èƒ½ã€‚

### Q4: è™šæ‹Ÿçº¿ç¨‹æœ‰æ€§èƒ½å¼€é”€å—ï¼Ÿ
A: æœ‰ï¼Œä½†å¾ˆå°ã€‚è™šæ‹Ÿçº¿ç¨‹çš„åˆ›å»ºå’Œè°ƒåº¦å¼€é”€è¿œå°äºå¹³å°çº¿ç¨‹ã€‚

---

## ğŸ”— ç›¸å…³èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [JEP 444: Virtual Threads](https://openjdk.org/jeps/444)
- [Virtual Threads Guide](https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html)

### æ¨èé˜…è¯»
- [Project Loom](https://openjdk.org/projects/loom/)
- [Virtual Threads Best Practices](https://inside.java/tag/virtual-threads)

---

## ğŸ“ å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£è™šæ‹Ÿçº¿ç¨‹çš„å·¥ä½œåŸç†
- [ ] æŒæ¡åˆ›å»ºè™šæ‹Ÿçº¿ç¨‹çš„å¤šç§æ–¹å¼
- [ ] ç†è§£è™šæ‹Ÿçº¿ç¨‹çš„é€‚ç”¨åœºæ™¯
- [ ] èƒ½å¤Ÿè¯†åˆ«å’Œé¿å…è™šæ‹Ÿçº¿ç¨‹å›ºå®šé—®é¢˜
- [ ] æŒæ¡è™šæ‹Ÿçº¿ç¨‹çš„æœ€ä½³å®è·µ
- [ ] èƒ½å¤Ÿåœ¨Spring Bootä¸­é›†æˆè™šæ‹Ÿçº¿ç¨‹
- [ ] å®Œæˆè‡³å°‘2ä¸ªå®æˆ˜æ¡ˆä¾‹

---

**æ­å–œä½ å®Œæˆäº†è™šæ‹Ÿçº¿ç¨‹çš„å­¦ä¹ ï¼** ğŸ‰

---

> ğŸ‘¤ **ä½œè€…**: erik.zhou  
> ğŸ“… **æœ€åæ›´æ–°**: 2025-02-01

