# ä¸šåŠ¡åœºæ™¯ç–‘éš¾æ‚ç—‡ - å®Œæ•´è§£æ

> çœŸå®ä¸šåŠ¡åœºæ™¯ä¸­çš„é—®é¢˜è¯Šæ–­å’Œè§£å†³
> 
> @author erik.zhou

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£æ”¶é›†äº†çœŸå®ä¸šåŠ¡åœºæ™¯ä¸­é‡åˆ°çš„å„ç§é—®é¢˜ï¼ŒåŒ…æ‹¬ï¼š
- æ¥å£é‡å¤æäº¤
- æ•°æ®ä¸ä¸€è‡´
- å®šæ—¶ä»»åŠ¡é‡å¤æ‰§è¡Œ
- æ–‡ä»¶ä¸Šä¼ é—®é¢˜
- ç™»å½•æ€å¤±æ•ˆ

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- [ ] èƒ½å¤Ÿé˜²æ­¢æ¥å£é‡å¤æäº¤
- [ ] èƒ½å¤Ÿä¿è¯æ•°æ®ä¸€è‡´æ€§
- [ ] èƒ½å¤Ÿå¤„ç†å®šæ—¶ä»»åŠ¡é—®é¢˜
- [ ] èƒ½å¤Ÿè§£å†³æ–‡ä»¶ä¸Šä¼ é—®é¢˜
- [ ] èƒ½å¤Ÿå¤„ç†ç™»å½•æ€é—®é¢˜

---

## 1. æ¥å£é‡å¤æäº¤ ğŸ”¥

### 1.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šç”¨æˆ·å¿«é€Ÿç‚¹å‡»æäº¤æŒ‰é’®ï¼Œåˆ›å»ºäº†å¤šä¸ªè®¢å•

**é—®é¢˜æè¿°**ï¼š
- ç”¨æˆ·ç‚¹å‡»"æäº¤è®¢å•"æŒ‰é’®
- ç½‘ç»œå»¶è¿Ÿï¼Œé¡µé¢æ— å“åº”
- ç”¨æˆ·å†æ¬¡ç‚¹å‡»æŒ‰é’®
- åˆ›å»ºäº† 2 ä¸ªç›¸åŒçš„è®¢å•

**å½±å“**ï¼š
- ç”¨æˆ·è¢«æ‰£æ¬¾ 2 æ¬¡
- åº“å­˜è¢«æ‰£å‡ 2 æ¬¡
- ç”¨æˆ·æŠ•è¯‰

### 1.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šå‰ç«¯é˜²é‡ï¼ˆåŸºç¡€ï¼‰**

```javascript
// æŒ‰é’®ç‚¹å‡»åç¦ç”¨
const submitBtn = document.getElementById('submitBtn');
submitBtn.addEventListener('click', async function() {
    // ç¦ç”¨æŒ‰é’®
    this.disabled = true;
    this.innerText = 'æäº¤ä¸­...';
    
    try {
        await submitOrder();
        alert('æäº¤æˆåŠŸ');
    } catch (error) {
        alert('æäº¤å¤±è´¥: ' + error.message);
    } finally {
        // æ¢å¤æŒ‰é’®
        this.disabled = false;
        this.innerText = 'æäº¤è®¢å•';
    }
});
```

**æ–¹æ¡ˆ 2ï¼šToken æœºåˆ¶ï¼ˆæ¨èï¼‰**

```java
// 1. è·å– Token æ¥å£
@RestController
@RequestMapping("/api")
public class TokenController {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @GetMapping("/token")
    public Result<String> getToken() {
        String token = UUID.randomUUID().toString();
        String key = "submit:token:" + token;
        
        // Token æœ‰æ•ˆæœŸ 5 åˆ†é’Ÿ
        redisTemplate.opsForValue().set(key, "1", 5, TimeUnit.MINUTES);
        
        return Result.success(token);
    }
}

// 2. é˜²é‡å¤æäº¤æ³¨è§£
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PreventRepeatSubmit {
    // Token å‚æ•°å
    String tokenParam() default "token";
}

// 3. é˜²é‡å¤æäº¤åˆ‡é¢
@Aspect
@Component
public class PreventRepeatSubmitAspect {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Around("@annotation(preventRepeatSubmit)")
    public Object around(ProceedingJoinPoint joinPoint, PreventRepeatSubmit preventRepeatSubmit) 
            throws Throwable {
        // è·å– Token
        HttpServletRequest request = ((ServletRequestAttributes) 
            RequestContextHolder.getRequestAttributes()).getRequest();
        String token = request.getParameter(preventRepeatSubmit.tokenParam());
        
        if (StringUtils.isEmpty(token)) {
            throw new RuntimeException("Token ä¸èƒ½ä¸ºç©º");
        }
        
        String key = "submit:token:" + token;
        
        // åˆ é™¤ Tokenï¼ˆåŸå­æ“ä½œï¼‰
        Boolean deleted = redisTemplate.delete(key);
        
        if (!Boolean.TRUE.equals(deleted)) {
            throw new RuntimeException("è¯·å‹¿é‡å¤æäº¤");
        }
        
        // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        return joinPoint.proceed();
    }
}

// 4. ä½¿ç”¨ç¤ºä¾‹
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @PostMapping
    @PreventRepeatSubmit
    public Result<Order> createOrder(@RequestBody OrderDTO orderDTO) {
        Order order = orderService.createOrder(orderDTO);
        return Result.success(order);
    }
}
```

**æ–¹æ¡ˆ 3ï¼šå¹‚ç­‰æ€§è®¾è®¡ï¼ˆæ¨èï¼‰**

```java
@Service
public class OrderService {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Transactional
    public Order createOrder(OrderDTO orderDTO) {
        // 1. ç”Ÿæˆå¹‚ç­‰ Keyï¼ˆç”¨æˆ· ID + å•†å“ ID + é‡‘é¢ + æ—¶é—´çª—å£ï¼‰
        String idempotentKey = generateIdempotentKey(orderDTO);
        String lockKey = "order:idempotent:" + idempotentKey;
        
        // 2. æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
        String existingOrderId = redisTemplate.opsForValue().get(lockKey);
        if (existingOrderId != null) {
            // å·²å¤„ç†ï¼Œè¿”å›å·²æœ‰è®¢å•
            return orderRepository.findById(Long.parseLong(existingOrderId));
        }
        
        // 3. åŠ é”
        Boolean locked = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "processing", 10, TimeUnit.SECONDS);
        
        if (!Boolean.TRUE.equals(locked)) {
            throw new RuntimeException("è®¢å•æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å");
        }
        
        try {
            // 4. åˆ›å»ºè®¢å•
            Order order = new Order();
            order.setUserId(orderDTO.getUserId());
            order.setProductId(orderDTO.getProductId());
            order.setAmount(orderDTO.getAmount());
            orderRepository.save(order);
            
            // 5. æ›´æ–°å¹‚ç­‰ Key
            redisTemplate.opsForValue().set(lockKey, order.getId().toString(), 24, TimeUnit.HOURS);
            
            return order;
        } catch (Exception e) {
            // å¤±è´¥ï¼Œåˆ é™¤é”
            redisTemplate.delete(lockKey);
            throw e;
        }
    }
    
    private String generateIdempotentKey(OrderDTO orderDTO) {
        // ä½¿ç”¨ç”¨æˆ· ID + å•†å“ ID + é‡‘é¢ + æ—¶é—´çª—å£ï¼ˆåˆ†é’Ÿçº§ï¼‰
        String timeWindow = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmm"));
        String raw = orderDTO.getUserId() + ":" + orderDTO.getProductId() + ":" + 
                     orderDTO.getAmount() + ":" + timeWindow;
        return DigestUtils.md5DigestAsHex(raw.getBytes());
    }
}
```

---

## 2. å®šæ—¶ä»»åŠ¡é‡å¤æ‰§è¡Œ ğŸ”¥

### 2.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šå¤šå®ä¾‹éƒ¨ç½²ï¼Œå®šæ—¶ä»»åŠ¡é‡å¤æ‰§è¡Œ

**é—®é¢˜æè¿°**ï¼š
- åº”ç”¨éƒ¨ç½²äº† 3 ä¸ªå®ä¾‹
- æ¯å¤©å‡Œæ™¨æ‰§è¡Œå¯¹è´¦ä»»åŠ¡
- 3 ä¸ªå®ä¾‹åŒæ—¶æ‰§è¡Œï¼Œå¯¼è‡´æ•°æ®é‡å¤å¤„ç†
- å¯¹è´¦ç»“æœé”™è¯¯

### 2.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šåˆ†å¸ƒå¼é”**

```java
@Component
public class ReconciliationTask {
    
    @Autowired
    private RedissonClient redissonClient;
    
    @Scheduled(cron = "0 0 2 * * ?")  // æ¯å¤©å‡Œæ™¨ 2 ç‚¹æ‰§è¡Œ
    public void reconcile() {
        String lockKey = "task:reconciliation:" + LocalDate.now();
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            // å°è¯•è·å–é”ï¼Œä¸ç­‰å¾…
            if (lock.tryLock(0, 2, TimeUnit.HOURS)) {
                log.info("è·å–é”æˆåŠŸï¼Œå¼€å§‹æ‰§è¡Œå¯¹è´¦ä»»åŠ¡");
                
                // æ‰§è¡Œå¯¹è´¦é€»è¾‘
                doReconciliation();
                
                log.info("å¯¹è´¦ä»»åŠ¡æ‰§è¡Œå®Œæˆ");
            } else {
                log.info("å…¶ä»–å®ä¾‹æ­£åœ¨æ‰§è¡Œå¯¹è´¦ä»»åŠ¡ï¼Œè·³è¿‡");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("è·å–é”è¢«ä¸­æ–­", e);
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
    
    private void doReconciliation() {
        // å¯¹è´¦é€»è¾‘
    }
}
```

**æ–¹æ¡ˆ 2ï¼šä½¿ç”¨ XXL-Jobï¼ˆæ¨èï¼‰**

```java
// 1. é…ç½® XXL-Job
@Configuration
public class XxlJobConfig {
    
    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;
    
    @Value("${xxl.job.executor.appname}")
    private String appname;
    
    @Bean
    public XxlJobSpringExecutor xxlJobExecutor() {
        XxlJobSpringExecutor executor = new XxlJobSpringExecutor();
        executor.setAdminAddresses(adminAddresses);
        executor.setAppname(appname);
        return executor;
    }
}

// 2. å®šä¹‰ä»»åŠ¡
@Component
public class ReconciliationJobHandler {
    
    @XxlJob("reconciliationJob")
    public void reconcile() {
        log.info("å¼€å§‹æ‰§è¡Œå¯¹è´¦ä»»åŠ¡");
        
        // è·å–ä»»åŠ¡å‚æ•°
        String param = XxlJobHelper.getJobParam();
        
        try {
            // æ‰§è¡Œå¯¹è´¦é€»è¾‘
            doReconciliation();
            
            XxlJobHelper.handleSuccess("å¯¹è´¦å®Œæˆ");
        } catch (Exception e) {
            log.error("å¯¹è´¦å¤±è´¥", e);
            XxlJobHelper.handleFail("å¯¹è´¦å¤±è´¥: " + e.getMessage());
        }
    }
    
    private void doReconciliation() {
        // å¯¹è´¦é€»è¾‘
    }
}
```

**æ–¹æ¡ˆ 3ï¼šæ•°æ®åº“é”**

```java
@Component
public class ReconciliationTask {
    
    @Autowired
    private TaskLockRepository taskLockRepository;
    
    @Scheduled(cron = "0 0 2 * * ?")
    @Transactional
    public void reconcile() {
        String taskName = "reconciliation";
        String taskDate = LocalDate.now().toString();
        
        // å°è¯•è·å–é”ï¼ˆåˆ©ç”¨æ•°æ®åº“å”¯ä¸€çº¦æŸï¼‰
        try {
            TaskLock lock = new TaskLock();
            lock.setTaskName(taskName);
            lock.setTaskDate(taskDate);
            lock.setLockTime(LocalDateTime.now());
            lock.setInstanceId(getInstanceId());
            taskLockRepository.save(lock);
            
            log.info("è·å–é”æˆåŠŸï¼Œå¼€å§‹æ‰§è¡Œå¯¹è´¦ä»»åŠ¡");
            
            // æ‰§è¡Œå¯¹è´¦é€»è¾‘
            doReconciliation();
            
            // æ›´æ–°çŠ¶æ€
            lock.setStatus(TaskStatus.COMPLETED);
            lock.setCompleteTime(LocalDateTime.now());
            taskLockRepository.save(lock);
            
        } catch (DataIntegrityViolationException e) {
            log.info("å…¶ä»–å®ä¾‹æ­£åœ¨æ‰§è¡Œå¯¹è´¦ä»»åŠ¡ï¼Œè·³è¿‡");
        }
    }
}

// ä»»åŠ¡é”è¡¨
@Entity
@Table(uniqueConstraints = @UniqueConstraint(columnNames = {"taskName", "taskDate"}))
public class TaskLock {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String taskName;
    private String taskDate;
    private String instanceId;
    private LocalDateTime lockTime;
    private LocalDateTime completeTime;
    private TaskStatus status;
}
```

---

## 3. åˆ†å¸ƒå¼ Session é—®é¢˜ ğŸ”¥

### 3.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šå¤šå®ä¾‹éƒ¨ç½²ï¼Œç”¨æˆ·ç™»å½•æ€ä¸¢å¤±

**é—®é¢˜æè¿°**ï¼š
- åº”ç”¨éƒ¨ç½²äº† 3 ä¸ªå®ä¾‹
- ç”¨æˆ·ç™»å½•åï¼Œè¯·æ±‚è¢«è´Ÿè½½å‡è¡¡åˆ°ä¸åŒå®ä¾‹
- éƒ¨åˆ†è¯·æ±‚æç¤º"æœªç™»å½•"
- ç”¨æˆ·ä½“éªŒå·®

### 3.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šSpring Session + Redisï¼ˆæ¨èï¼‰**

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

```yaml
# application.yml
spring:
  session:
    store-type: redis
    timeout: 1800  # 30 åˆ†é’Ÿ
    redis:
      namespace: session
```

```java
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)
public class SessionConfig {
    
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("SESSION");
        serializer.setCookiePath("/");
        serializer.setDomainNamePattern("^.+?\\.(\\w+\\.[a-z]+)$");
        return serializer;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
@RestController
@RequestMapping("/api")
public class UserController {
    
    @PostMapping("/login")
    public Result<UserVO> login(@RequestBody LoginRequest request, HttpSession session) {
        // éªŒè¯ç”¨æˆ·
        User user = userService.login(request.getUsername(), request.getPassword());
        
        // ä¿å­˜åˆ° Session
        session.setAttribute("user", user);
        
        return Result.success(convertToVO(user));
    }
    
    @GetMapping("/user/info")
    public Result<UserVO> getUserInfo(HttpSession session) {
        User user = (User) session.getAttribute("user");
        
        if (user == null) {
            return Result.fail("æœªç™»å½•");
        }
        
        return Result.success(convertToVO(user));
    }
}
```

**æ–¹æ¡ˆ 2ï¼šJWT Tokenï¼ˆæ¨èï¼‰**

```java
@Configuration
public class JwtConfig {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    @Bean
    public JwtUtil jwtUtil() {
        return new JwtUtil(secret, expiration);
    }
}

@Component
public class JwtUtil {
    
    private final String secret;
    private final Long expiration;
    
    public JwtUtil(String secret, Long expiration) {
        this.secret = secret;
        this.expiration = expiration;
    }
    
    public String generateToken(User user) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        
        return Jwts.builder()
            .setSubject(user.getId().toString())
            .claim("username", user.getUsername())
            .claim("roles", user.getRoles())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(secret)
            .parseClaimsJws(token)
            .getBody();
        
        return Long.parseLong(claims.getSubject());
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}

// ç™»å½•æ¥å£
@RestController
@RequestMapping("/api")
public class AuthController {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @PostMapping("/login")
    public Result<LoginResponse> login(@RequestBody LoginRequest request) {
        User user = userService.login(request.getUsername(), request.getPassword());
        
        String token = jwtUtil.generateToken(user);
        
        LoginResponse response = new LoginResponse();
        response.setToken(token);
        response.setUser(convertToVO(user));
        
        return Result.success(response);
    }
}

// JWT è¿‡æ»¤å™¨
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
            FilterChain filterChain) throws ServletException, IOException {
        
        String token = getTokenFromRequest(request);
        
        if (StringUtils.hasText(token) && jwtUtil.validateToken(token)) {
            Long userId = jwtUtil.getUserIdFromToken(token);
            
            // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ°ä¸Šä¸‹æ–‡
            UserContext.setUserId(userId);
        }
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            UserContext.clear();
        }
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

---

## 4. æ–‡ä»¶ä¸Šä¼ é—®é¢˜ ğŸ”¥

### 4.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šå¤§æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼Œå†…å­˜æº¢å‡º

**é—®é¢˜æè¿°**ï¼š
- ç”¨æˆ·ä¸Šä¼  500MB çš„è§†é¢‘æ–‡ä»¶
- åº”ç”¨å†…å­˜é£™å‡
- ä¸Šä¼ å¤±è´¥ï¼ŒOOM

### 4.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šåˆ†ç‰‡ä¸Šä¼ **

```java
@RestController
@RequestMapping("/api/upload")
public class FileUploadController {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private MinioClient minioClient;
    
    /**
     * åˆå§‹åŒ–åˆ†ç‰‡ä¸Šä¼ 
     */
    @PostMapping("/init")
    public Result<InitUploadResponse> initUpload(@RequestBody InitUploadRequest request) {
        String uploadId = UUID.randomUUID().toString();
        String fileName = request.getFileName();
        long fileSize = request.getFileSize();
        int chunkSize = 5 * 1024 * 1024;  // 5MB
        int chunkCount = (int) Math.ceil((double) fileSize / chunkSize);
        
        // ä¿å­˜ä¸Šä¼ ä¿¡æ¯åˆ° Redis
        UploadInfo uploadInfo = new UploadInfo();
        uploadInfo.setUploadId(uploadId);
        uploadInfo.setFileName(fileName);
        uploadInfo.setFileSize(fileSize);
        uploadInfo.setChunkSize(chunkSize);
        uploadInfo.setChunkCount(chunkCount);
        uploadInfo.setUploadedChunks(new HashSet<>());
        
        String key = "upload:" + uploadId;
        redisTemplate.opsForValue().set(key, JSON.toJSONString(uploadInfo), 24, TimeUnit.HOURS);
        
        InitUploadResponse response = new InitUploadResponse();
        response.setUploadId(uploadId);
        response.setChunkSize(chunkSize);
        response.setChunkCount(chunkCount);
        
        return Result.success(response);
    }
    
    /**
     * ä¸Šä¼ åˆ†ç‰‡
     */
    @PostMapping("/chunk")
    public Result<Void> uploadChunk(
            @RequestParam("uploadId") String uploadId,
            @RequestParam("chunkIndex") int chunkIndex,
            @RequestParam("file") MultipartFile file) throws Exception {
        
        // è·å–ä¸Šä¼ ä¿¡æ¯
        String key = "upload:" + uploadId;
        String json = redisTemplate.opsForValue().get(key);
        if (json == null) {
            return Result.fail("ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨");
        }
        
        UploadInfo uploadInfo = JSON.parseObject(json, UploadInfo.class);
        
        // ä¿å­˜åˆ†ç‰‡åˆ°ä¸´æ—¶ç›®å½•
        String chunkPath = "chunks/" + uploadId + "/" + chunkIndex;
        minioClient.putObject(
            PutObjectArgs.builder()
                .bucket("temp")
                .object(chunkPath)
                .stream(file.getInputStream(), file.getSize(), -1)
                .build()
        );
        
        // æ›´æ–°å·²ä¸Šä¼ åˆ†ç‰‡
        uploadInfo.getUploadedChunks().add(chunkIndex);
        redisTemplate.opsForValue().set(key, JSON.toJSONString(uploadInfo), 24, TimeUnit.HOURS);
        
        return Result.success();
    }
    
    /**
     * åˆå¹¶åˆ†ç‰‡
     */
    @PostMapping("/merge")
    public Result<String> mergeChunks(@RequestParam("uploadId") String uploadId) throws Exception {
        // è·å–ä¸Šä¼ ä¿¡æ¯
        String key = "upload:" + uploadId;
        String json = redisTemplate.opsForValue().get(key);
        if (json == null) {
            return Result.fail("ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨");
        }
        
        UploadInfo uploadInfo = JSON.parseObject(json, UploadInfo.class);
        
        // æ£€æŸ¥æ‰€æœ‰åˆ†ç‰‡æ˜¯å¦å·²ä¸Šä¼ 
        if (uploadInfo.getUploadedChunks().size() != uploadInfo.getChunkCount()) {
            return Result.fail("åˆ†ç‰‡æœªä¸Šä¼ å®Œæˆ");
        }
        
        // åˆå¹¶åˆ†ç‰‡
        List<ComposeSource> sources = new ArrayList<>();
        for (int i = 0; i < uploadInfo.getChunkCount(); i++) {
            String chunkPath = "chunks/" + uploadId + "/" + i;
            sources.add(ComposeSource.builder()
                .bucket("temp")
                .object(chunkPath)
                .build());
        }
        
        String targetPath = "files/" + uploadInfo.getFileName();
        minioClient.composeObject(
            ComposeObjectArgs.builder()
                .bucket("files")
                .object(targetPath)
                .sources(sources)
                .build()
        );
        
        // åˆ é™¤ä¸´æ—¶åˆ†ç‰‡
        for (int i = 0; i < uploadInfo.getChunkCount(); i++) {
            String chunkPath = "chunks/" + uploadId + "/" + i;
            minioClient.removeObject(
                RemoveObjectArgs.builder()
                    .bucket("temp")
                    .object(chunkPath)
                    .build()
            );
        }
        
        // åˆ é™¤ Redis è®°å½•
        redisTemplate.delete(key);
        
        // è¿”å›æ–‡ä»¶ URL
        String fileUrl = minioClient.getPresignedObjectUrl(
            GetPresignedObjectUrlArgs.builder()
                .bucket("files")
                .object(targetPath)
                .expiry(7, TimeUnit.DAYS)
                .method(Method.GET)
                .build()
        );
        
        return Result.success(fileUrl);
    }
}

@Data
class UploadInfo {
    private String uploadId;
    private String fileName;
    private long fileSize;
    private int chunkSize;
    private int chunkCount;
    private Set<Integer> uploadedChunks;
}
```

**æ–¹æ¡ˆ 2ï¼šæ–­ç‚¹ç»­ä¼ **

```java
/**
 * æŸ¥è¯¢å·²ä¸Šä¼ çš„åˆ†ç‰‡
 */
@GetMapping("/progress")
public Result<UploadProgressResponse> getUploadProgress(@RequestParam("uploadId") String uploadId) {
    String key = "upload:" + uploadId;
    String json = redisTemplate.opsForValue().get(key);
    
    if (json == null) {
        return Result.fail("ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨");
    }
    
    UploadInfo uploadInfo = JSON.parseObject(json, UploadInfo.class);
    
    UploadProgressResponse response = new UploadProgressResponse();
    response.setUploadId(uploadId);
    response.setChunkCount(uploadInfo.getChunkCount());
    response.setUploadedChunks(uploadInfo.getUploadedChunks());
    
    return Result.success(response);
}
```

---

## 5. æ•°æ®ä¸€è‡´æ€§é—®é¢˜ ğŸ”¥

### 5.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šè®¢å•çŠ¶æ€ä¸æ”¯ä»˜çŠ¶æ€ä¸ä¸€è‡´

**é—®é¢˜æè¿°**ï¼š
- ç”¨æˆ·æ”¯ä»˜æˆåŠŸ
- æ”¯ä»˜å›è°ƒå¤„ç†å¤±è´¥
- è®¢å•çŠ¶æ€ä»ä¸º"å¾…æ”¯ä»˜"
- ç”¨æˆ·æŠ•è¯‰å·²ä»˜æ¬¾ä½†è®¢å•æœªå¤„ç†

**ç›‘æ§æ•°æ®**ï¼š
```
è®¢å•è¡¨çŠ¶æ€: PENDING_PAYMENT
æ”¯ä»˜æµæ°´çŠ¶æ€: SUCCESS
ç”¨æˆ·ä½™é¢: å·²æ‰£å‡
```

### 5.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šæœ¬åœ°æ¶ˆæ¯è¡¨**

```java
@Service
public class PaymentCallbackService {
    
    @Autowired
    private LocalMessageRepository messageRepository;
    
    @Autowired
    private OrderService orderService;
    
    /**
     * æ”¯ä»˜å›è°ƒå¤„ç†
     */
    @Transactional
    public void handlePaymentCallback(PaymentCallback callback) {
        // 1. ä¿å­˜æœ¬åœ°æ¶ˆæ¯ï¼ˆä¸ä¸šåŠ¡åœ¨åŒä¸€äº‹åŠ¡ï¼‰
        LocalMessage message = new LocalMessage();
        message.setMessageId(UUID.randomUUID().toString());
        message.setBusinessType("PAYMENT_CALLBACK");
        message.setBusinessId(callback.getOrderNo());
        message.setPayload(JSON.toJSONString(callback));
        message.setStatus(MessageStatus.PENDING);
        message.setRetryCount(0);
        message.setCreateTime(LocalDateTime.now());
        messageRepository.save(message);
        
        // 2. æ›´æ–°è®¢å•çŠ¶æ€
        orderService.updateOrderStatus(callback.getOrderNo(), OrderStatus.PAID);
        
        // 3. æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
        message.setStatus(MessageStatus.PROCESSED);
        message.setProcessTime(LocalDateTime.now());
        messageRepository.save(message);
    }
}

// æ¶ˆæ¯è¡¥å¿ä»»åŠ¡
@Component
public class MessageCompensationTask {
    
    @Autowired
    private LocalMessageRepository messageRepository;
    
    @Scheduled(fixedDelay = 60000)  // æ¯åˆ†é’Ÿæ‰§è¡Œ
    public void compensate() {
        // æŸ¥è¯¢å¾…å¤„ç†çš„æ¶ˆæ¯
        List<LocalMessage> pendingMessages = messageRepository
            .findByStatusAndRetryCountLessThan(MessageStatus.PENDING, 5);
        
        for (LocalMessage message : pendingMessages) {
            try {
                // é‡æ–°å¤„ç†
                processMessage(message);
                
                message.setStatus(MessageStatus.PROCESSED);
                message.setProcessTime(LocalDateTime.now());
            } catch (Exception e) {
                message.setRetryCount(message.getRetryCount() + 1);
                message.setLastError(e.getMessage());
                
                if (message.getRetryCount() >= 5) {
                    message.setStatus(MessageStatus.FAILED);
                    // å‘é€å‘Šè­¦
                    alertService.sendAlert("æ¶ˆæ¯å¤„ç†å¤±è´¥: " + message.getMessageId());
                }
            }
            messageRepository.save(message);
        }
    }
}
```

**æ–¹æ¡ˆ 2ï¼šå¯¹è´¦æœºåˆ¶**

```java
@Component
public class ReconciliationTask {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Scheduled(cron = "0 0 1 * * ?")  // æ¯å¤©å‡Œæ™¨ 1 ç‚¹
    public void reconcile() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        // 1. æŸ¥è¯¢å¾…æ”¯ä»˜è®¢å•
        List<Order> pendingOrders = orderRepository
            .findByStatusAndCreateDateBetween(
                OrderStatus.PENDING_PAYMENT,
                yesterday.atStartOfDay(),
                yesterday.plusDays(1).atStartOfDay()
            );
        
        for (Order order : pendingOrders) {
            // 2. æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
            PaymentResult result = paymentService.queryPaymentStatus(order.getOrderNo());
            
            if (result.isSuccess()) {
                // 3. æ”¯ä»˜æˆåŠŸä½†è®¢å•æœªæ›´æ–°ï¼Œè¿›è¡Œè¡¥å¿
                log.warn("å‘ç°ä¸ä¸€è‡´è®¢å•: {}, æ”¯ä»˜çŠ¶æ€: SUCCESS, è®¢å•çŠ¶æ€: PENDING", 
                    order.getOrderNo());
                
                orderService.updateOrderStatus(order.getOrderNo(), OrderStatus.PAID);
                
                // 4. è®°å½•å¯¹è´¦ç»“æœ
                ReconciliationRecord record = new ReconciliationRecord();
                record.setOrderNo(order.getOrderNo());
                record.setType(ReconciliationType.ORDER_STATUS_MISMATCH);
                record.setAction("UPDATE_ORDER_STATUS");
                record.setCreateTime(LocalDateTime.now());
                reconciliationRecordRepository.save(record);
            }
        }
    }
}
```

---

## 6. åˆ†å¸ƒå¼ ID ç”Ÿæˆé—®é¢˜ ğŸ”¥

### 6.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šé«˜å¹¶å‘ä¸‹ ID é‡å¤

**é—®é¢˜æè¿°**ï¼š
- ä½¿ç”¨æ•°æ®åº“è‡ªå¢ ID
- åˆ†åº“åˆ†è¡¨å ID é‡å¤
- è®¢å•å·å†²çª

### 6.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šSnowflake ç®—æ³•**

```java
@Component
public class SnowflakeIdGenerator {
    
    // èµ·å§‹æ—¶é—´æˆ³ (2024-01-01)
    private static final long START_TIMESTAMP = 1704067200000L;
    
    // å„éƒ¨åˆ†ä½æ•°
    private static final long WORKER_ID_BITS = 5L;
    private static final long DATACENTER_ID_BITS = 5L;
    private static final long SEQUENCE_BITS = 12L;
    
    // æœ€å¤§å€¼
    private static final long MAX_WORKER_ID = ~(-1L << WORKER_ID_BITS);
    private static final long MAX_DATACENTER_ID = ~(-1L << DATACENTER_ID_BITS);
    private static final long MAX_SEQUENCE = ~(-1L << SEQUENCE_BITS);
    
    // ä½ç§»
    private static final long WORKER_ID_SHIFT = SEQUENCE_BITS;
    private static final long DATACENTER_ID_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS;
    private static final long TIMESTAMP_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS + DATACENTER_ID_BITS;
    
    private final long workerId;
    private final long datacenterId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    
    public SnowflakeIdGenerator(
            @Value("${snowflake.worker-id:1}") long workerId,
            @Value("${snowflake.datacenter-id:1}") long datacenterId) {
        
        if (workerId > MAX_WORKER_ID || workerId < 0) {
            throw new IllegalArgumentException("Worker ID è¶…å‡ºèŒƒå›´");
        }
        if (datacenterId > MAX_DATACENTER_ID || datacenterId < 0) {
            throw new IllegalArgumentException("Datacenter ID è¶…å‡ºèŒƒå›´");
        }
        
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }
    
    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        
        if (timestamp < lastTimestamp) {
            throw new RuntimeException("æ—¶é’Ÿå›æ‹¨ï¼Œæ‹’ç»ç”Ÿæˆ ID");
        }
        
        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & MAX_SEQUENCE;
            if (sequence == 0) {
                // åºåˆ—å·ç”¨å°½ï¼Œç­‰å¾…ä¸‹ä¸€æ¯«ç§’
                timestamp = waitNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        
        lastTimestamp = timestamp;
        
        return ((timestamp - START_TIMESTAMP) << TIMESTAMP_SHIFT)
                | (datacenterId << DATACENTER_ID_SHIFT)
                | (workerId << WORKER_ID_SHIFT)
                | sequence;
    }
    
    private long waitNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}
```

**æ–¹æ¡ˆ 2ï¼šå·æ®µæ¨¡å¼ï¼ˆç¾å›¢ Leafï¼‰**

```java
@Service
public class SegmentIdGenerator {
    
    @Autowired
    private SegmentRepository segmentRepository;
    
    private final Map<String, SegmentBuffer> bufferMap = new ConcurrentHashMap<>();
    
    public long nextId(String bizTag) {
        SegmentBuffer buffer = bufferMap.computeIfAbsent(bizTag, 
            k -> new SegmentBuffer(bizTag));
        
        return buffer.nextId();
    }
    
    private class SegmentBuffer {
        private final String bizTag;
        private volatile Segment current;
        private volatile Segment next;
        private volatile boolean nextReady = false;
        private final ReentrantLock lock = new ReentrantLock();
        
        public SegmentBuffer(String bizTag) {
            this.bizTag = bizTag;
            this.current = loadSegment();
        }
        
        public long nextId() {
            while (true) {
                lock.lock();
                try {
                    long id = current.incrementAndGet();
                    
                    if (id <= current.getMax()) {
                        // å½“å‰å·æ®µæœªç”¨å®Œ
                        if (!nextReady && id > current.getMax() * 0.9) {
                            // å¼‚æ­¥åŠ è½½ä¸‹ä¸€ä¸ªå·æ®µ
                            loadNextSegmentAsync();
                        }
                        return id;
                    }
                    
                    // å½“å‰å·æ®µç”¨å®Œï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª
                    if (nextReady) {
                        current = next;
                        next = null;
                        nextReady = false;
                    } else {
                        // åŒæ­¥åŠ è½½
                        current = loadSegment();
                    }
                } finally {
                    lock.unlock();
                }
            }
        }
        
        private Segment loadSegment() {
            // ä»æ•°æ®åº“è·å–å·æ®µ
            SegmentAlloc alloc = segmentRepository.updateAndGet(bizTag);
            return new Segment(alloc.getMaxId() - alloc.getStep(), alloc.getMaxId());
        }
        
        private void loadNextSegmentAsync() {
            CompletableFuture.runAsync(() -> {
                next = loadSegment();
                nextReady = true;
            });
        }
    }
}

// å·æ®µè¡¨
@Entity
@Table(name = "segment_alloc")
public class SegmentAlloc {
    @Id
    private String bizTag;
    private Long maxId;
    private Integer step;
    private LocalDateTime updateTime;
}
```

---

## 7. çƒ­ç‚¹æ•°æ®é—®é¢˜ ğŸ”¥

### 7.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šç§’æ€å•†å“ç¼“å­˜å‡»ç©¿

**é—®é¢˜æè¿°**ï¼š
- ç§’æ€æ´»åŠ¨å¼€å§‹
- å¤§é‡è¯·æ±‚åŒæ—¶è®¿é—®åŒä¸€å•†å“
- ç¼“å­˜è¿‡æœŸç¬é—´ï¼Œè¯·æ±‚å…¨éƒ¨æ‰“åˆ°æ•°æ®åº“
- æ•°æ®åº“å‹åŠ›è¿‡å¤§ï¼Œå“åº”å˜æ…¢

### 7.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šæœ¬åœ°ç¼“å­˜ + åˆ†å¸ƒå¼ç¼“å­˜**

```java
@Service
public class HotProductService {
    
    // æœ¬åœ°ç¼“å­˜
    private final Cache<Long, Product> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(10, TimeUnit.SECONDS)
        .build();
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private ProductRepository productRepository;
    
    public Product getProduct(Long productId) {
        // 1. æŸ¥æœ¬åœ°ç¼“å­˜
        Product product = localCache.getIfPresent(productId);
        if (product != null) {
            return product;
        }
        
        // 2. æŸ¥ Redis
        String key = "product:" + productId;
        String json = redisTemplate.opsForValue().get(key);
        if (json != null) {
            product = JSON.parseObject(json, Product.class);
            localCache.put(productId, product);
            return product;
        }
        
        // 3. æŸ¥æ•°æ®åº“ï¼ˆåŠ é”é˜²æ­¢ç¼“å­˜å‡»ç©¿ï¼‰
        String lockKey = "lock:product:" + productId;
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            if (lock.tryLock(3, 10, TimeUnit.SECONDS)) {
                // åŒé‡æ£€æŸ¥
                json = redisTemplate.opsForValue().get(key);
                if (json != null) {
                    product = JSON.parseObject(json, Product.class);
                } else {
                    product = productRepository.findById(productId).orElse(null);
                    if (product != null) {
                        // éšæœºè¿‡æœŸæ—¶é—´ï¼Œé˜²æ­¢ç¼“å­˜é›ªå´©
                        int expireTime = 300 + new Random().nextInt(60);
                        redisTemplate.opsForValue().set(key, 
                            JSON.toJSONString(product), expireTime, TimeUnit.SECONDS);
                    }
                }
                
                if (product != null) {
                    localCache.put(productId, product);
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
        
        return product;
    }
}
```

**æ–¹æ¡ˆ 2ï¼šç¼“å­˜é¢„çƒ­ + æ°¸ä¸è¿‡æœŸ**

```java
@Component
public class HotProductCacheWarmer {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private ProductRepository productRepository;
    
    /**
     * ç§’æ€æ´»åŠ¨å¼€å§‹å‰é¢„çƒ­ç¼“å­˜
     */
    @Scheduled(cron = "0 55 9 * * ?")  // æ´»åŠ¨å‰ 5 åˆ†é’Ÿ
    public void warmUpCache() {
        // è·å–å³å°†å¼€å§‹çš„ç§’æ€å•†å“
        List<SeckillProduct> products = seckillProductRepository
            .findByStartTimeBetween(
                LocalDateTime.now(),
                LocalDateTime.now().plusMinutes(10)
            );
        
        for (SeckillProduct sp : products) {
            Product product = productRepository.findById(sp.getProductId()).orElse(null);
            if (product != null) {
                String key = "product:" + product.getId();
                // è®¾ç½®è¾ƒé•¿çš„è¿‡æœŸæ—¶é—´
                redisTemplate.opsForValue().set(key, 
                    JSON.toJSONString(product), 2, TimeUnit.HOURS);
                
                log.info("é¢„çƒ­å•†å“ç¼“å­˜: {}", product.getId());
            }
        }
    }
    
    /**
     * åå°çº¿ç¨‹å®šæœŸåˆ·æ–°çƒ­ç‚¹æ•°æ®
     */
    @Scheduled(fixedDelay = 30000)  // æ¯ 30 ç§’
    public void refreshHotData() {
        // è·å–çƒ­ç‚¹å•†å“åˆ—è¡¨
        Set<String> hotProducts = redisTemplate.opsForZSet()
            .reverseRange("hot:products", 0, 99);
        
        if (hotProducts != null) {
            for (String productId : hotProducts) {
                Product product = productRepository.findById(Long.parseLong(productId))
                    .orElse(null);
                if (product != null) {
                    String key = "product:" + productId;
                    redisTemplate.opsForValue().set(key, 
                        JSON.toJSONString(product), 5, TimeUnit.MINUTES);
                }
            }
        }
    }
}
```

---

## 8. å¼‚æ­¥å¤„ç†å¤±è´¥é—®é¢˜ ğŸ”¥

### 8.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šå¼‚æ­¥å‘é€çŸ­ä¿¡å¤±è´¥ï¼Œç”¨æˆ·æœªæ”¶åˆ°éªŒè¯ç 

**é—®é¢˜æè¿°**ï¼š
- ç”¨æˆ·æ³¨å†Œï¼Œå¼‚æ­¥å‘é€éªŒè¯ç çŸ­ä¿¡
- çŸ­ä¿¡æœåŠ¡å¼‚å¸¸
- ç”¨æˆ·æœªæ”¶åˆ°éªŒè¯ç 
- æ— æ³•å®Œæˆæ³¨å†Œ

### 8.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 1ï¼šå¯é æ¶ˆæ¯é˜Ÿåˆ—**

```java
@Service
public class SmsService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Autowired
    private SmsRecordRepository smsRecordRepository;
    
    /**
     * å‘é€çŸ­ä¿¡ï¼ˆå¯é æŠ•é€’ï¼‰
     */
    @Transactional
    public void sendSms(String phone, String content) {
        // 1. ä¿å­˜å‘é€è®°å½•
        SmsRecord record = new SmsRecord();
        record.setPhone(phone);
        record.setContent(content);
        record.setStatus(SmsStatus.PENDING);
        record.setRetryCount(0);
        record.setCreateTime(LocalDateTime.now());
        smsRecordRepository.save(record);
        
        // 2. å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
        SmsMessage message = new SmsMessage();
        message.setRecordId(record.getId());
        message.setPhone(phone);
        message.setContent(content);
        
        rabbitTemplate.convertAndSend("sms.exchange", "sms.send", message);
    }
}

// æ¶ˆè´¹è€…
@Component
public class SmsConsumer {
    
    @Autowired
    private SmsProvider smsProvider;
    
    @Autowired
    private SmsRecordRepository smsRecordRepository;
    
    @RabbitListener(queues = "sms.queue")
    public void handleSms(SmsMessage message, Channel channel, 
            @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) throws IOException {
        
        SmsRecord record = smsRecordRepository.findById(message.getRecordId()).orElse(null);
        if (record == null) {
            channel.basicAck(deliveryTag, false);
            return;
        }
        
        try {
            // è°ƒç”¨çŸ­ä¿¡æœåŠ¡å•†
            smsProvider.send(message.getPhone(), message.getContent());
            
            // æ›´æ–°çŠ¶æ€
            record.setStatus(SmsStatus.SUCCESS);
            record.setSendTime(LocalDateTime.now());
            smsRecordRepository.save(record);
            
            channel.basicAck(deliveryTag, false);
            
        } catch (Exception e) {
            log.error("çŸ­ä¿¡å‘é€å¤±è´¥: {}", message.getPhone(), e);
            
            record.setRetryCount(record.getRetryCount() + 1);
            record.setLastError(e.getMessage());
            
            if (record.getRetryCount() >= 3) {
                // è¶…è¿‡é‡è¯•æ¬¡æ•°ï¼Œæ ‡è®°å¤±è´¥
                record.setStatus(SmsStatus.FAILED);
                smsRecordRepository.save(record);
                channel.basicAck(deliveryTag, false);
                
                // å‘é€å‘Šè­¦
                alertService.sendAlert("çŸ­ä¿¡å‘é€å¤±è´¥: " + message.getPhone());
            } else {
                smsRecordRepository.save(record);
                // æ‹’ç»æ¶ˆæ¯ï¼Œé‡æ–°å…¥é˜Ÿ
                channel.basicNack(deliveryTag, false, true);
            }
        }
    }
}

// è¡¥å¿ä»»åŠ¡
@Component
public class SmsCompensationTask {
    
    @Scheduled(fixedDelay = 300000)  // æ¯ 5 åˆ†é’Ÿ
    public void compensate() {
        // æŸ¥è¯¢å¾…å¤„ç†çš„è®°å½•
        List<SmsRecord> pendingRecords = smsRecordRepository
            .findByStatusAndCreateTimeBefore(
                SmsStatus.PENDING,
                LocalDateTime.now().minusMinutes(5)
            );
        
        for (SmsRecord record : pendingRecords) {
            // é‡æ–°å‘é€åˆ°é˜Ÿåˆ—
            SmsMessage message = new SmsMessage();
            message.setRecordId(record.getId());
            message.setPhone(record.getPhone());
            message.setContent(record.getContent());
            
            rabbitTemplate.convertAndSend("sms.exchange", "sms.send", message);
        }
    }
}
```

---

## 9. æ•°æ®è¿ç§»é—®é¢˜ ğŸ”¥

### 9.1 é—®é¢˜ç°è±¡

**çœŸå®åœºæ™¯**ï¼šå¤§è¡¨æ•°æ®è¿ç§»å¯¼è‡´æœåŠ¡ä¸å¯ç”¨

**é—®é¢˜æè¿°**ï¼š
- éœ€è¦è¿ç§» 1 äº¿æ¡è®¢å•æ•°æ®
- ç›´æ¥è¿ç§»å¯¼è‡´æ•°æ®åº“é”è¡¨
- æœåŠ¡å“åº”è¶…æ—¶
- ç”¨æˆ·æ— æ³•ä¸‹å•

### 9.2 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆï¼šåˆ†æ‰¹è¿ç§» + åŒå†™**

```java
@Service
public class DataMigrationService {
    
    @Autowired
    private JdbcTemplate sourceJdbcTemplate;
    
    @Autowired
    private JdbcTemplate targetJdbcTemplate;
    
    /**
     * åˆ†æ‰¹è¿ç§»æ•°æ®
     */
    public void migrateOrders() {
        long lastId = 0;
        int batchSize = 1000;
        int totalMigrated = 0;
        
        while (true) {
            // 1. åˆ†æ‰¹æŸ¥è¯¢
            List<Order> orders = sourceJdbcTemplate.query(
                "SELECT * FROM orders WHERE id > ? ORDER BY id LIMIT ?",
                new Object[]{lastId, batchSize},
                new OrderRowMapper()
            );
            
            if (orders.isEmpty()) {
                break;
            }
            
            // 2. æ‰¹é‡æ’å…¥
            String insertSql = "INSERT INTO orders_new (id, order_no, user_id, amount, status, create_time) " +
                              "VALUES (?, ?, ?, ?, ?, ?) " +
                              "ON DUPLICATE KEY UPDATE order_no = VALUES(order_no)";
            
            targetJdbcTemplate.batchUpdate(insertSql, new BatchPreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps, int i) throws SQLException {
                    Order order = orders.get(i);
                    ps.setLong(1, order.getId());
                    ps.setString(2, order.getOrderNo());
                    ps.setLong(3, order.getUserId());
                    ps.setBigDecimal(4, order.getAmount());
                    ps.setString(5, order.getStatus().name());
                    ps.setTimestamp(6, Timestamp.valueOf(order.getCreateTime()));
                }
                
                @Override
                public int getBatchSize() {
                    return orders.size();
                }
            });
            
            lastId = orders.get(orders.size() - 1).getId();
            totalMigrated += orders.size();
            
            log.info("å·²è¿ç§» {} æ¡æ•°æ®ï¼Œå½“å‰ ID: {}", totalMigrated, lastId);
            
            // 3. æ§åˆ¶è¿ç§»é€Ÿåº¦ï¼Œé¿å…å½±å“çº¿ä¸ŠæœåŠ¡
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        log.info("æ•°æ®è¿ç§»å®Œæˆï¼Œå…±è¿ç§» {} æ¡æ•°æ®", totalMigrated);
    }
}

// åŒå†™æœåŠ¡
@Service
public class OrderService {
    
    @Value("${migration.double-write.enabled:false}")
    private boolean doubleWriteEnabled;
    
    @Transactional
    public Order createOrder(OrderDTO orderDTO) {
        Order order = new Order();
        // ... è®¾ç½®è®¢å•å±æ€§
        
        // å†™å…¥åŸè¡¨
        orderRepository.save(order);
        
        // åŒå†™åˆ°æ–°è¡¨
        if (doubleWriteEnabled) {
            try {
                orderNewRepository.save(order);
            } catch (Exception e) {
                log.error("åŒå†™å¤±è´¥", e);
                // ä¸å½±å“ä¸»æµç¨‹
            }
        }
        
        return order;
    }
}
```

---

## ğŸ“ å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] èƒ½å¤Ÿé˜²æ­¢æ¥å£é‡å¤æäº¤
- [ ] èƒ½å¤Ÿå¤„ç†å®šæ—¶ä»»åŠ¡é‡å¤æ‰§è¡Œ
- [ ] èƒ½å¤Ÿå®ç°åˆ†å¸ƒå¼ Session
- [ ] èƒ½å¤Ÿå®ç°å¤§æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ 
- [ ] èƒ½å¤Ÿå®ç°æ–­ç‚¹ç»­ä¼ 
- [ ] èƒ½å¤Ÿä¿è¯æ•°æ®ä¸€è‡´æ€§
- [ ] èƒ½å¤Ÿå®ç°åˆ†å¸ƒå¼ ID ç”Ÿæˆ
- [ ] èƒ½å¤Ÿå¤„ç†çƒ­ç‚¹æ•°æ®é—®é¢˜
- [ ] èƒ½å¤Ÿå®ç°å¯é å¼‚æ­¥å¤„ç†
- [ ] èƒ½å¤Ÿè¿›è¡Œå¤§æ•°æ®é‡è¿ç§»

---

**@author erik.zhou**

