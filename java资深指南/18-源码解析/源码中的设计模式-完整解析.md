# æºç ä¸­çš„è®¾è®¡æ¨¡å¼ - å®Œæ•´è§£æ

> æ·±å…¥ç†è§£ Springã€MyBatisã€Dubboã€Netty æºç ä¸­çš„è®¾è®¡æ¨¡å¼åº”ç”¨ä¸æ‰©å±•
> 
> @author erik.zhou

## ğŸ“š æ¦‚è¿°

ä¼˜ç§€çš„å¼€æºæ¡†æ¶éƒ½æ˜¯è®¾è®¡æ¨¡å¼çš„æœ€ä½³å®è·µã€‚é€šè¿‡å­¦ä¹ è¿™äº›æ¡†æ¶ä¸­çš„è®¾è®¡æ¨¡å¼åº”ç”¨ï¼Œä½ å°†ï¼š
- ç†è§£è®¾è®¡æ¨¡å¼åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨åœºæ™¯
- å­¦ä¹ å¦‚ä½•ä¼˜é›…åœ°è§£å†³å¤æ‚é—®é¢˜
- æå‡æ¶æ„è®¾è®¡èƒ½åŠ›
- æŒæ¡æ¡†æ¶æ‰©å±•çš„æ­£ç¡®å§¿åŠ¿

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- [ ] æŒæ¡ Spring ä¸­çš„ 10+ ç§è®¾è®¡æ¨¡å¼
- [ ] ç†è§£ MyBatis ä¸­çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼
- [ ] å­¦ä¹  Dubbo çš„æ‰©å±•æœºåˆ¶è®¾è®¡
- [ ] æ·±å…¥ Netty çš„è´£ä»»é“¾æ¨¡å¼
- [ ] èƒ½å¤Ÿåœ¨è‡ªå·±çš„é¡¹ç›®ä¸­åº”ç”¨è¿™äº›æ¨¡å¼
- [ ] æŒæ¡æ¡†æ¶æ‰©å±•çš„æœ€ä½³å®è·µ

## ğŸ“– ç›®å½•

1. [Spring ä¸­çš„è®¾è®¡æ¨¡å¼](#1-spring-ä¸­çš„è®¾è®¡æ¨¡å¼)
2. [MyBatis ä¸­çš„è®¾è®¡æ¨¡å¼](#2-mybatis-ä¸­çš„è®¾è®¡æ¨¡å¼)
3. [Dubbo ä¸­çš„è®¾è®¡æ¨¡å¼](#3-dubbo-ä¸­çš„è®¾è®¡æ¨¡å¼)
4. [Netty ä¸­çš„è®¾è®¡æ¨¡å¼](#4-netty-ä¸­çš„è®¾è®¡æ¨¡å¼)
5. [è®¾è®¡æ¨¡å¼å¯¹æ¯”ä¸é€‰æ‹©](#5-è®¾è®¡æ¨¡å¼å¯¹æ¯”ä¸é€‰æ‹©)
6. [æ¡†æ¶æ‰©å±•æœ€ä½³å®è·µ](#6-æ¡†æ¶æ‰©å±•æœ€ä½³å®è·µ)

---

## 1. Spring ä¸­çš„è®¾è®¡æ¨¡å¼

### 1.1 å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šBeanFactory å’Œ ApplicationContext

```java
// BeanFactory - ç®€å•å·¥å‚
public interface BeanFactory {
    Object getBean(String name) throws BeansException;
    <T> T getBean(String name, Class<T> requiredType) throws BeansException;
    <T> T getBean(Class<T> requiredType) throws BeansException;
}

// FactoryBean - å·¥å‚æ–¹æ³•
public interface FactoryBean<T> {
    T getObject() throws Exception;
    Class<?> getObjectType();
    default boolean isSingleton() {
        return true;
    }
}
```


**å®é™…åº”ç”¨ç¤ºä¾‹**ï¼š

```java
// è‡ªå®šä¹‰ FactoryBean
@Component
public class UserFactoryBean implements FactoryBean<User> {
    
    @Override
    public User getObject() throws Exception {
        // å¤æ‚çš„å¯¹è±¡åˆ›å»ºé€»è¾‘
        User user = new User();
        user.setId(1L);
        user.setName("å¼ ä¸‰");
        // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œå¤æ‚çš„åˆå§‹åŒ–
        return user;
    }
    
    @Override
    public Class<?> getObjectType() {
        return User.class;
    }
    
    @Override
    public boolean isSingleton() {
        return true;
    }
}

// ä½¿ç”¨
@Autowired
private User user;  // æ³¨å…¥çš„æ˜¯ getObject() è¿”å›çš„å¯¹è±¡

@Autowired
private UserFactoryBean userFactoryBean;  // æ³¨å…¥ FactoryBean æœ¬èº«ï¼ˆåŠ  & å‰ç¼€ï¼‰
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. å®ç° FactoryBean æ¥å£
// 2. ç”¨äºåˆ›å»ºå¤æ‚å¯¹è±¡
// 3. å¯ä»¥åœ¨ getObject() ä¸­å®ç°è‡ªå®šä¹‰é€»è¾‘
// 4. å…¸å‹åº”ç”¨ï¼šMyBatis çš„ SqlSessionFactoryBean
```

---

### 1.2 å•ä¾‹æ¨¡å¼ï¼ˆSingleton Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šSpring Bean é»˜è®¤ä½œç”¨åŸŸ

```java
// DefaultSingletonBeanRegistry - å•ä¾‹æ³¨å†Œè¡¨
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry 
        implements SingletonBeanRegistry {
    
    // ä¸€çº§ç¼“å­˜ï¼šå®Œæ•´çš„å•ä¾‹å¯¹è±¡
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
    
    // äºŒçº§ç¼“å­˜ï¼šæ—©æœŸçš„å•ä¾‹å¯¹è±¡
    private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);
    
    // ä¸‰çº§ç¼“å­˜ï¼šå•ä¾‹å·¥å‚
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
    
    // è·å–å•ä¾‹
    public Object getSingleton(String beanName) {
        return getSingleton(beanName, true);
    }
    
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        // ä»ç¼“å­˜è·å–
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                synchronized (this.singletonObjects) {
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        singletonObject = this.earlySingletonObjects.get(beanName);
                        if (singletonObject == null) {
                            ObjectFactory<?> singletonFactory = 
                                this.singletonFactories.get(beanName);
                            if (singletonFactory != null) {
                                singletonObject = singletonFactory.getObject();
                                this.earlySingletonObjects.put(beanName, singletonObject);
                                this.singletonFactories.remove(beanName);
                            }
                        }
                    }
                }
            }
        }
        return singletonObject;
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. ä½¿ç”¨ @Scope æ³¨è§£æ”¹å˜ä½œç”¨åŸŸ
@Component
@Scope("prototype")  // åŸå‹æ¨¡å¼
public class PrototypeBean {
}

@Component
@Scope("request")  // è¯·æ±‚ä½œç”¨åŸŸ
public class RequestBean {
}

@Component
@Scope("session")  // ä¼šè¯ä½œç”¨åŸŸ
public class SessionBean {
}

// 2. è‡ªå®šä¹‰ä½œç”¨åŸŸ
public class ThreadLocalScope implements Scope {
    private final ThreadLocal<Map<String, Object>> threadLocal = 
        ThreadLocal.withInitial(HashMap::new);
    
    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Map<String, Object> scope = threadLocal.get();
        Object object = scope.get(name);
        if (object == null) {
            object = objectFactory.getObject();
            scope.put(name, object);
        }
        return object;
    }
    
    @Override
    public Object remove(String name) {
        Map<String, Object> scope = threadLocal.get();
        return scope.remove(name);
    }
    
    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
    }
    
    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }
    
    @Override
    public String getConversationId() {
        return Thread.currentThread().getName();
    }
}

// æ³¨å†Œè‡ªå®šä¹‰ä½œç”¨åŸŸ
@Configuration
public class ScopeConfig {
    @Bean
    public CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer configurer = new CustomScopeConfigurer();
        configurer.addScope("thread", new ThreadLocalScope());
        return configurer;
    }
}
```

---

### 1.3 ä»£ç†æ¨¡å¼ï¼ˆProxy Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šAOP å®ç°

```java
// JDK åŠ¨æ€ä»£ç†
public class JdkDynamicAopProxy implements AopProxy, InvocationHandler {
    
    private final AdvisedSupport advised;
    
    public JdkDynamicAopProxy(AdvisedSupport config) {
        this.advised = config;
    }
    
    @Override
    public Object getProxy() {
        return getProxy(ClassUtils.getDefaultClassLoader());
    }
    
    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) {
        Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(
            this.advised, true);
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object target = this.advised.getTargetSource().getTarget();
        Class<?> targetClass = target.getClass();
        
        // è·å–æ‹¦æˆªå™¨é“¾
        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(
            method, targetClass);
        
        if (chain.isEmpty()) {
            // æ²¡æœ‰æ‹¦æˆªå™¨ï¼Œç›´æ¥è°ƒç”¨ç›®æ ‡æ–¹æ³•
            return AopUtils.invokeJoinpointUsingReflection(target, method, args);
        } else {
            // åˆ›å»ºæ–¹æ³•è°ƒç”¨
            MethodInvocation invocation = new ReflectiveMethodInvocation(
                proxy, target, method, args, targetClass, chain);
            // æ‰§è¡Œæ‹¦æˆªå™¨é“¾
            return invocation.proceed();
        }
    }
}

// CGLIB ä»£ç†
public class CglibAopProxy implements AopProxy {
    
    @Override
    public Object getProxy() {
        return getProxy(null);
    }
    
    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) {
        Class<?> rootClass = this.advised.getTargetClass();
        
        // åˆ›å»º Enhancer
        Enhancer enhancer = createEnhancer();
        if (classLoader != null) {
            enhancer.setClassLoader(classLoader);
        }
        enhancer.setSuperclass(rootClass);
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
        enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));
        
        // è®¾ç½®å›è°ƒ
        Callback[] callbacks = getCallbacks(rootClass);
        enhancer.setCallbacks(callbacks);
        
        // åˆ›å»ºä»£ç†å¯¹è±¡
        return enhancer.create();
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰åˆ‡é¢
@Aspect
@Component
public class CustomAspect {
    
    // è‡ªå®šä¹‰åˆ‡ç‚¹
    @Pointcut("@annotation(com.example.annotation.Log)")
    public void logPointcut() {}
    
    // ç¯ç»•é€šçŸ¥
    @Around("logPointcut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        long start = System.currentTimeMillis();
        try {
            Object result = pjp.proceed();
            long end = System.currentTimeMillis();
            System.out.println("æ–¹æ³•æ‰§è¡Œæ—¶é—´ï¼š" + (end - start) + "ms");
            return result;
        } catch (Throwable e) {
            System.out.println("æ–¹æ³•æ‰§è¡Œå¼‚å¸¸ï¼š" + e.getMessage());
            throw e;
        }
    }
}

// 2. è‡ªå®šä¹‰æ³¨è§£
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    String value() default "";
}

// 3. ä½¿ç”¨
@Service
public class UserService {
    
    @Log("æŸ¥è¯¢ç”¨æˆ·")
    public User getUser(Long id) {
        return new User(id, "å¼ ä¸‰");
    }
}
```

---

### 1.4 æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Method Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šAbstractApplicationContext.refresh()

```java
public abstract class AbstractApplicationContext extends DefaultResourceLoader
        implements ConfigurableApplicationContext {
    
    @Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // 1. å‡†å¤‡åˆ·æ–°ï¼ˆé’©å­æ–¹æ³•ï¼‰
            prepareRefresh();
            
            // 2. è·å– BeanFactoryï¼ˆæŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°ï¼‰
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
            
            // 3. å‡†å¤‡ BeanFactory
            prepareBeanFactory(beanFactory);
            
            try {
                // 4. åç½®å¤„ç† BeanFactoryï¼ˆé’©å­æ–¹æ³•ï¼‰
                postProcessBeanFactory(beanFactory);
                
                // 5. è°ƒç”¨ BeanFactory åç½®å¤„ç†å™¨
                invokeBeanFactoryPostProcessors(beanFactory);
                
                // 6. æ³¨å†Œ Bean åç½®å¤„ç†å™¨
                registerBeanPostProcessors(beanFactory);
                
                // 7. åˆå§‹åŒ–æ¶ˆæ¯æº
                initMessageSource();
                
                // 8. åˆå§‹åŒ–äº‹ä»¶å¹¿æ’­å™¨
                initApplicationEventMulticaster();
                
                // 9. åˆ·æ–°ï¼ˆé’©å­æ–¹æ³•ï¼Œå­ç±»å®ç°ï¼‰
                onRefresh();
                
                // 10. æ³¨å†Œç›‘å¬å™¨
                registerListeners();
                
                // 11. å®ä¾‹åŒ–æ‰€æœ‰éæ‡’åŠ è½½çš„å•ä¾‹ Bean
                finishBeanFactoryInitialization(beanFactory);
                
                // 12. å®Œæˆåˆ·æ–°
                finishRefresh();
            } catch (BeansException ex) {
                destroyBeans();
                cancelRefresh(ex);
                throw ex;
            }
        }
    }
    
    // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å¿…é¡»å®ç°
    protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;
    
    // é’©å­æ–¹æ³•ï¼Œå­ç±»å¯ä»¥è¦†ç›–
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    }
    
    // é’©å­æ–¹æ³•ï¼Œå­ç±»å¯ä»¥è¦†ç›–
    protected void onRefresh() throws BeansException {
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. ç»§æ‰¿ AbstractApplicationContext
public class CustomApplicationContext extends AbstractApplicationContext {
    
    @Override
    protected void refreshBeanFactory() throws BeansException {
        // è‡ªå®šä¹‰ BeanFactory åˆ·æ–°é€»è¾‘
    }
    
    @Override
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // è‡ªå®šä¹‰ BeanFactory åç½®å¤„ç†
        beanFactory.addBeanPostProcessor(new CustomBeanPostProcessor());
    }
    
    @Override
    protected void onRefresh() {
        // è‡ªå®šä¹‰åˆ·æ–°é€»è¾‘
        System.out.println("è‡ªå®šä¹‰åˆ·æ–°é€»è¾‘");
    }
}

// 2. ä½¿ç”¨ JdbcTemplateï¼ˆæ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„å…¸å‹åº”ç”¨ï¼‰
public class UserDao {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findById(Long id) {
        return jdbcTemplate.queryForObject(
            "SELECT * FROM user WHERE id = ?",
            new Object[]{id},
            (rs, rowNum) -> {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setName(rs.getString("name"));
                return user;
            }
        );
    }
}

// 3. è‡ªå®šä¹‰æ¨¡æ¿ç±»
public abstract class AbstractService<T> {
    
    // æ¨¡æ¿æ–¹æ³•
    public final T execute() {
        // 1. å‰ç½®å¤„ç†
        before();
        
        // 2. æ ¸å¿ƒé€»è¾‘ï¼ˆæŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°ï¼‰
        T result = doExecute();
        
        // 3. åç½®å¤„ç†
        after();
        
        return result;
    }
    
    // é’©å­æ–¹æ³•
    protected void before() {
        System.out.println("å‰ç½®å¤„ç†");
    }
    
    // æŠ½è±¡æ–¹æ³•
    protected abstract T doExecute();
    
    // é’©å­æ–¹æ³•
    protected void after() {
        System.out.println("åç½®å¤„ç†");
    }
}

// ä½¿ç”¨
public class UserService extends AbstractService<User> {
    
    @Override
    protected User doExecute() {
        return new User(1L, "å¼ ä¸‰");
    }
}
```

---

### 1.5 è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šSpring äº‹ä»¶æœºåˆ¶

```java
// 1. äº‹ä»¶ï¼ˆEventï¼‰
public abstract class ApplicationEvent extends EventObject {
    private final long timestamp;
    
    public ApplicationEvent(Object source) {
        super(source);
        this.timestamp = System.currentTimeMillis();
    }
}

// 2. ç›‘å¬å™¨ï¼ˆListenerï¼‰
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {
    void onApplicationEvent(E event);
}

// 3. äº‹ä»¶å‘å¸ƒå™¨ï¼ˆPublisherï¼‰
public interface ApplicationEventPublisher {
    default void publishEvent(ApplicationEvent event) {
        publishEvent((Object) event);
    }
    
    void publishEvent(Object event);
}

// 4. äº‹ä»¶å¹¿æ’­å™¨ï¼ˆMulticasterï¼‰
public interface ApplicationEventMulticaster {
    void addApplicationListener(ApplicationListener<?> listener);
    void removeApplicationListener(ApplicationListener<?> listener);
    void multicastEvent(ApplicationEvent event);
}
```

**å®é™…åº”ç”¨ç¤ºä¾‹**ï¼š

```java
// 1. è‡ªå®šä¹‰äº‹ä»¶
public class UserRegisterEvent extends ApplicationEvent {
    private final User user;
    
    public UserRegisterEvent(Object source, User user) {
        super(source);
        this.user = user;
    }
    
    public User getUser() {
        return user;
    }
}

// 2. äº‹ä»¶ç›‘å¬å™¨
@Component
public class UserRegisterListener implements ApplicationListener<UserRegisterEvent> {
    
    @Override
    public void onApplicationEvent(UserRegisterEvent event) {
        User user = event.getUser();
        System.out.println("ç”¨æˆ·æ³¨å†ŒæˆåŠŸï¼š" + user.getName());
        // å‘é€æ¬¢è¿é‚®ä»¶
        // å‘é€ä¼˜æƒ åˆ¸
    }
}

// æˆ–ä½¿ç”¨ @EventListener æ³¨è§£
@Component
public class UserEventHandler {
    
    @EventListener
    public void handleUserRegister(UserRegisterEvent event) {
        User user = event.getUser();
        System.out.println("ç”¨æˆ·æ³¨å†ŒæˆåŠŸï¼š" + user.getName());
    }
    
    @EventListener
    @Async  // å¼‚æ­¥å¤„ç†
    public void sendWelcomeEmail(UserRegisterEvent event) {
        // å‘é€æ¬¢è¿é‚®ä»¶
    }
}

// 3. å‘å¸ƒäº‹ä»¶
@Service
public class UserService {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void register(User user) {
        // æ³¨å†Œé€»è¾‘
        // ...
        
        // å‘å¸ƒäº‹ä»¶
        eventPublisher.publishEvent(new UserRegisterEvent(this, user));
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰äº‹ä»¶å¹¿æ’­å™¨
@Configuration
public class EventConfig {
    
    @Bean
    public ApplicationEventMulticaster applicationEventMulticaster() {
        SimpleApplicationEventMulticaster multicaster = 
            new SimpleApplicationEventMulticaster();
        
        // è®¾ç½®çº¿ç¨‹æ± ï¼Œå¼‚æ­¥å¤„ç†äº‹ä»¶
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("event-");
        executor.initialize();
        
        multicaster.setTaskExecutor(executor);
        return multicaster;
    }
}

// 2. æ¡ä»¶ç›‘å¬
@Component
public class ConditionalListener {
    
    @EventListener(condition = "#event.user.age >= 18")
    public void handleAdultUser(UserRegisterEvent event) {
        System.out.println("æˆå¹´ç”¨æˆ·æ³¨å†Œ");
    }
    
    @EventListener(condition = "#event.user.age < 18")
    public void handleMinorUser(UserRegisterEvent event) {
        System.out.println("æœªæˆå¹´ç”¨æˆ·æ³¨å†Œ");
    }
}

// 3. äº‹ä»¶é¡ºåº
@Component
public class OrderedListener {
    
    @EventListener
    @Order(1)
    public void first(UserRegisterEvent event) {
        System.out.println("ç¬¬ä¸€ä¸ªæ‰§è¡Œ");
    }
    
    @EventListener
    @Order(2)
    public void second(UserRegisterEvent event) {
        System.out.println("ç¬¬äºŒä¸ªæ‰§è¡Œ");
    }
}
```


### 1.6 ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šResource èµ„æºåŠ è½½

```java
// ç­–ç•¥æ¥å£
public interface Resource extends InputStreamSource {
    boolean exists();
    URL getURL() throws IOException;
    URI getURI() throws IOException;
    File getFile() throws IOException;
    long contentLength() throws IOException;
    long lastModified() throws IOException;
    Resource createRelative(String relativePath) throws IOException;
    String getFilename();
    String getDescription();
}

// å…·ä½“ç­–ç•¥
public class ClassPathResource extends AbstractFileResolvingResource {
    // ä» classpath åŠ è½½èµ„æº
}

public class FileSystemResource extends AbstractResource {
    // ä»æ–‡ä»¶ç³»ç»ŸåŠ è½½èµ„æº
}

public class UrlResource extends AbstractFileResolvingResource {
    // ä» URL åŠ è½½èµ„æº
}

// ç­–ç•¥ä¸Šä¸‹æ–‡
public interface ResourceLoader {
    Resource getResource(String location);
}

public class DefaultResourceLoader implements ResourceLoader {
    
    @Override
    public Resource getResource(String location) {
        if (location.startsWith("/")) {
            return getResourceByPath(location);
        } else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
            return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()));
        } else {
            try {
                URL url = new URL(location);
                return new UrlResource(url);
            } catch (MalformedURLException ex) {
                return getResourceByPath(location);
            }
        }
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰èµ„æºåŠ è½½ç­–ç•¥
public class CustomResource extends AbstractResource {
    
    private final String location;
    
    public CustomResource(String location) {
        this.location = location;
    }
    
    @Override
    public InputStream getInputStream() throws IOException {
        // è‡ªå®šä¹‰èµ„æºåŠ è½½é€»è¾‘
        // ä¾‹å¦‚ï¼šä»æ•°æ®åº“ã€Redisã€OSS ç­‰åŠ è½½
        return null;
    }
    
    @Override
    public String getDescription() {
        return "Custom resource: " + location;
    }
}

// 2. ä¸šåŠ¡ä¸­çš„ç­–ç•¥æ¨¡å¼
public interface PaymentStrategy {
    void pay(BigDecimal amount);
}

@Component("alipay")
public class AlipayStrategy implements PaymentStrategy {
    @Override
    public void pay(BigDecimal amount) {
        System.out.println("æ”¯ä»˜å®æ”¯ä»˜ï¼š" + amount);
    }
}

@Component("wechat")
public class WechatPayStrategy implements PaymentStrategy {
    @Override
    public void pay(BigDecimal amount) {
        System.out.println("å¾®ä¿¡æ”¯ä»˜ï¼š" + amount);
    }
}

@Service
public class PaymentService {
    
    @Autowired
    private Map<String, PaymentStrategy> strategyMap;
    
    public void pay(String type, BigDecimal amount) {
        PaymentStrategy strategy = strategyMap.get(type);
        if (strategy == null) {
            throw new IllegalArgumentException("ä¸æ”¯æŒçš„æ”¯ä»˜æ–¹å¼ï¼š" + type);
        }
        strategy.pay(amount);
    }
}
```

---

### 1.7 è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šBeanWrapper

```java
// ç»„ä»¶æ¥å£
public interface BeanWrapper extends ConfigurablePropertyAccessor {
    Object getWrappedInstance();
    Class<?> getWrappedClass();
}

// å…·ä½“ç»„ä»¶
public class BeanWrapperImpl extends AbstractNestablePropertyAccessor 
        implements BeanWrapper {
    
    private Object wrappedObject;
    
    public BeanWrapperImpl(Object object) {
        this.wrappedObject = object;
    }
    
    @Override
    public Object getWrappedInstance() {
        return this.wrappedObject;
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰è£…é¥°å™¨
public class LoggingBeanWrapper implements BeanWrapper {
    
    private final BeanWrapper delegate;
    
    public LoggingBeanWrapper(BeanWrapper delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public void setPropertyValue(String propertyName, Object value) {
        System.out.println("è®¾ç½®å±æ€§ï¼š" + propertyName + " = " + value);
        delegate.setPropertyValue(propertyName, value);
    }
    
    @Override
    public Object getPropertyValue(String propertyName) {
        Object value = delegate.getPropertyValue(propertyName);
        System.out.println("è·å–å±æ€§ï¼š" + propertyName + " = " + value);
        return value;
    }
    
    // å§”æ‰˜å…¶ä»–æ–¹æ³•...
}

// 2. ä¸šåŠ¡ä¸­çš„è£…é¥°å™¨æ¨¡å¼
public interface UserService {
    User getUser(Long id);
}

@Service
public class UserServiceImpl implements UserService {
    @Override
    public User getUser(Long id) {
        return new User(id, "å¼ ä¸‰");
    }
}

// ç¼“å­˜è£…é¥°å™¨
public class CachedUserService implements UserService {
    
    private final UserService delegate;
    private final Map<Long, User> cache = new ConcurrentHashMap<>();
    
    public CachedUserService(UserService delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public User getUser(Long id) {
        return cache.computeIfAbsent(id, delegate::getUser);
    }
}

// æ—¥å¿—è£…é¥°å™¨
public class LoggingUserService implements UserService {
    
    private final UserService delegate;
    
    public LoggingUserService(UserService delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public User getUser(Long id) {
        System.out.println("æŸ¥è¯¢ç”¨æˆ·ï¼š" + id);
        User user = delegate.getUser(id);
        System.out.println("æŸ¥è¯¢ç»“æœï¼š" + user);
        return user;
    }
}
```

---

### 1.8 é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šSpring MVC HandlerAdapter

```java
// ç›®æ ‡æ¥å£
public interface HandlerAdapter {
    boolean supports(Object handler);
    ModelAndView handle(HttpServletRequest request, 
                       HttpServletResponse response, 
                       Object handler) throws Exception;
}

// é€‚é…å™¨å®ç°
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter 
        implements BeanFactoryAware, InitializingBean {
    
    @Override
    public boolean supports(Object handler) {
        return handler instanceof HandlerMethod;
    }
    
    @Override
    protected ModelAndView handleInternal(HttpServletRequest request,
                                         HttpServletResponse response,
                                         HandlerMethod handlerMethod) throws Exception {
        // é€‚é… HandlerMethod åˆ° ModelAndView
        return invokeHandlerMethod(request, response, handlerMethod);
    }
}

public class SimpleControllerHandlerAdapter implements HandlerAdapter {
    
    @Override
    public boolean supports(Object handler) {
        return (handler instanceof Controller);
    }
    
    @Override
    public ModelAndView handle(HttpServletRequest request, 
                              HttpServletResponse response, 
                              Object handler) throws Exception {
        // é€‚é… Controller åˆ° ModelAndView
        return ((Controller) handler).handleRequest(request, response);
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰ HandlerAdapter
public class CustomHandlerAdapter implements HandlerAdapter {
    
    @Override
    public boolean supports(Object handler) {
        return handler instanceof CustomHandler;
    }
    
    @Override
    public ModelAndView handle(HttpServletRequest request,
                              HttpServletResponse response,
                              Object handler) throws Exception {
        CustomHandler customHandler = (CustomHandler) handler;
        // è‡ªå®šä¹‰å¤„ç†é€»è¾‘
        Object result = customHandler.handle(request, response);
        // è½¬æ¢ä¸º ModelAndView
        return new ModelAndView("view", "data", result);
    }
}

// 2. ä¸šåŠ¡ä¸­çš„é€‚é…å™¨æ¨¡å¼
// æ—§æ¥å£
public interface OldPaymentService {
    void pay(String orderId, double amount);
}

// æ–°æ¥å£
public interface NewPaymentService {
    PaymentResult pay(PaymentRequest request);
}

// é€‚é…å™¨
@Service
public class PaymentAdapter implements NewPaymentService {
    
    @Autowired
    private OldPaymentService oldPaymentService;
    
    @Override
    public PaymentResult pay(PaymentRequest request) {
        // é€‚é…æ–°æ¥å£åˆ°æ—§æ¥å£
        oldPaymentService.pay(request.getOrderId(), 
                             request.getAmount().doubleValue());
        return new PaymentResult(true, "æ”¯ä»˜æˆåŠŸ");
    }
}
```

---

### 1.9 è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibility Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šFilter è¿‡æ»¤å™¨é“¾

```java
// è¿‡æ»¤å™¨æ¥å£
public interface Filter {
    void doFilter(ServletRequest request, ServletResponse response, 
                 FilterChain chain) throws IOException, ServletException;
}

// è¿‡æ»¤å™¨é“¾
public interface FilterChain {
    void doFilter(ServletRequest request, ServletResponse response) 
        throws IOException, ServletException;
}

// è¿‡æ»¤å™¨é“¾å®ç°
public class ApplicationFilterChain implements FilterChain {
    
    private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];
    private int pos = 0;
    private int n = 0;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response) 
            throws IOException, ServletException {
        if (pos < n) {
            ApplicationFilterConfig filterConfig = filters[pos++];
            Filter filter = filterConfig.getFilter();
            filter.doFilter(request, response, this);
        } else {
            // æ‰§è¡Œ Servlet
            servlet.service(request, response);
        }
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰è¿‡æ»¤å™¨
@Component
public class LoggingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        System.out.println("è¯·æ±‚ URLï¼š" + req.getRequestURI());
        
        long start = System.currentTimeMillis();
        chain.doFilter(request, response);
        long end = System.currentTimeMillis();
        
        System.out.println("è¯·æ±‚è€—æ—¶ï¼š" + (end - start) + "ms");
    }
}

// 2. ä¸šåŠ¡ä¸­çš„è´£ä»»é“¾æ¨¡å¼
public abstract class AbstractHandler {
    
    protected AbstractHandler next;
    
    public void setNext(AbstractHandler next) {
        this.next = next;
    }
    
    public abstract void handle(Request request);
}

// å‚æ•°æ ¡éªŒå¤„ç†å™¨
public class ValidationHandler extends AbstractHandler {
    
    @Override
    public void handle(Request request) {
        if (request.getParams() == null) {
            throw new IllegalArgumentException("å‚æ•°ä¸èƒ½ä¸ºç©º");
        }
        if (next != null) {
            next.handle(request);
        }
    }
}

// æƒé™æ ¡éªŒå¤„ç†å™¨
public class AuthHandler extends AbstractHandler {
    
    @Override
    public void handle(Request request) {
        if (request.getToken() == null) {
            throw new SecurityException("æœªç™»å½•");
        }
        if (next != null) {
            next.handle(request);
        }
    }
}

// ä¸šåŠ¡å¤„ç†å™¨
public class BusinessHandler extends AbstractHandler {
    
    @Override
    public void handle(Request request) {
        System.out.println("æ‰§è¡Œä¸šåŠ¡é€»è¾‘");
    }
}

// ä½¿ç”¨
public class HandlerChain {
    
    public static void main(String[] args) {
        AbstractHandler validation = new ValidationHandler();
        AbstractHandler auth = new AuthHandler();
        AbstractHandler business = new BusinessHandler();
        
        validation.setNext(auth);
        auth.setNext(business);
        
        Request request = new Request();
        validation.handle(request);
    }
}
```

---

### 1.10 å»ºé€ è€…æ¨¡å¼ï¼ˆBuilder Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šBeanDefinitionBuilder

```java
// å»ºé€ è€…
public class BeanDefinitionBuilder {
    
    private AbstractBeanDefinition beanDefinition;
    
    public static BeanDefinitionBuilder genericBeanDefinition() {
        return new BeanDefinitionBuilder(new GenericBeanDefinition());
    }
    
    public static BeanDefinitionBuilder genericBeanDefinition(Class<?> beanClass) {
        BeanDefinitionBuilder builder = new BeanDefinitionBuilder(
            new GenericBeanDefinition());
        builder.beanDefinition.setBeanClass(beanClass);
        return builder;
    }
    
    public BeanDefinitionBuilder setScope(String scope) {
        this.beanDefinition.setScope(scope);
        return this;
    }
    
    public BeanDefinitionBuilder setLazyInit(boolean lazyInit) {
        this.beanDefinition.setLazyInit(lazyInit);
        return this;
    }
    
    public BeanDefinitionBuilder addPropertyValue(String name, Object value) {
        this.beanDefinition.getPropertyValues().add(name, value);
        return this;
    }
    
    public AbstractBeanDefinition getBeanDefinition() {
        return this.beanDefinition;
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. ä½¿ç”¨ BeanDefinitionBuilder
@Configuration
public class BeanConfig {
    
    @Bean
    public BeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor() {
        return registry -> {
            // ä½¿ç”¨å»ºé€ è€…æ¨¡å¼åˆ›å»º BeanDefinition
            BeanDefinition beanDefinition = BeanDefinitionBuilder
                .genericBeanDefinition(User.class)
                .setScope("prototype")
                .setLazyInit(true)
                .addPropertyValue("id", 1L)
                .addPropertyValue("name", "å¼ ä¸‰")
                .getBeanDefinition();
            
            registry.registerBeanDefinition("user", beanDefinition);
        };
    }
}

// 2. ä¸šåŠ¡ä¸­çš„å»ºé€ è€…æ¨¡å¼
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
    private String phone;
    
    // ç§æœ‰æ„é€ å™¨
    private User(Builder builder) {
        this.id = builder.id;
        this.name = builder.name;
        this.age = builder.age;
        this.email = builder.email;
        this.phone = builder.phone;
    }
    
    // å»ºé€ è€…
    public static class Builder {
        private Long id;
        private String name;
        private Integer age;
        private String email;
        private String phone;
        
        public Builder id(Long id) {
            this.id = id;
            return this;
        }
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder age(Integer age) {
            this.age = age;
            return this;
        }
        
        public Builder email(String email) {
            this.email = email;
            return this;
        }
        
        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// ä½¿ç”¨
User user = new User.Builder()
    .id(1L)
    .name("å¼ ä¸‰")
    .age(25)
    .email("zhangsan@example.com")
    .phone("13800138000")
    .build();
```

---

## 2. MyBatis ä¸­çš„è®¾è®¡æ¨¡å¼

### 2.1 å»ºé€ è€…æ¨¡å¼ï¼ˆBuilder Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šSqlSessionFactoryBuilder

```java
// SqlSessionFactoryBuilder
public class SqlSessionFactoryBuilder {
    
    public SqlSessionFactory build(Reader reader) {
        return build(reader, null, null);
    }
    
    public SqlSessionFactory build(Reader reader, String environment) {
        return build(reader, environment, null);
    }
    
    public SqlSessionFactory build(Reader reader, Properties properties) {
        return build(reader, null, properties);
    }
    
    public SqlSessionFactory build(Reader reader, String environment, 
                                   Properties properties) {
        try {
            XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
            return build(parser.parse());
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error building SqlSession.", e);
        } finally {
            ErrorContext.instance().reset();
            try {
                reader.close();
            } catch (IOException e) {
                // Intentionally ignore. Prefer previous error.
            }
        }
    }
    
    public SqlSessionFactory build(Configuration config) {
        return new DefaultSqlSessionFactory(config);
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰ SqlSessionFactory
public class CustomSqlSessionFactory extends DefaultSqlSessionFactory {
    
    public CustomSqlSessionFactory(Configuration configuration) {
        super(configuration);
    }
    
    @Override
    public SqlSession openSession() {
        // è‡ªå®šä¹‰ SqlSession åˆ›å»ºé€»è¾‘
        return new CustomSqlSession(getConfiguration());
    }
}

// 2. ä½¿ç”¨å»ºé€ è€…åˆ›å»º
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()
    .build(inputStream, "development", properties);
```

---

### 2.2 å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šSqlSessionFactory

```java
// å·¥å‚æ¥å£
public interface SqlSessionFactory {
    SqlSession openSession();
    SqlSession openSession(boolean autoCommit);
    SqlSession openSession(Connection connection);
    SqlSession openSession(TransactionIsolationLevel level);
    SqlSession openSession(ExecutorType execType);
    Configuration getConfiguration();
}

// å·¥å‚å®ç°
public class DefaultSqlSessionFactory implements SqlSessionFactory {
    
    private final Configuration configuration;
    
    public DefaultSqlSessionFactory(Configuration configuration) {
        this.configuration = configuration;
    }
    
    @Override
    public SqlSession openSession() {
        return openSessionFromDataSource(configuration.getDefaultExecutorType(), 
                                        null, false);
    }
    
    private SqlSession openSessionFromDataSource(ExecutorType execType, 
                                                TransactionIsolationLevel level, 
                                                boolean autoCommit) {
        Transaction tx = null;
        try {
            final Environment environment = configuration.getEnvironment();
            final TransactionFactory transactionFactory = 
                getTransactionFactoryFromEnvironment(environment);
            tx = transactionFactory.newTransaction(environment.getDataSource(), 
                                                  level, autoCommit);
            final Executor executor = configuration.newExecutor(tx, execType);
            return new DefaultSqlSession(configuration, executor, autoCommit);
        } catch (Exception e) {
            closeTransaction(tx);
            throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
        } finally {
            ErrorContext.instance().reset();
        }
    }
}
```


### 2.3 ä»£ç†æ¨¡å¼ï¼ˆProxy Patternï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šMapper æ¥å£ä»£ç†

```java
// MapperProxyFactory - ä»£ç†å·¥å‚
public class MapperProxyFactory<T> {
    
    private final Class<T> mapperInterface;
    private final Map<Method, MapperMethodInvoker> methodCache = new ConcurrentHashMap<>();
    
    public MapperProxyFactory(Class<T> mapperInterface) {
        this.mapperInterface = mapperInterface;
    }
    
    public T newInstance(SqlSession sqlSession) {
        final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, 
                                                             mapperInterface, 
                                                             methodCache);
        return newInstance(mapperProxy);
    }
    
    protected T newInstance(MapperProxy<T> mapperProxy) {
        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), 
                                         new Class[] { mapperInterface }, 
                                         mapperProxy);
    }
}

// MapperProxy - ä»£ç†å¤„ç†å™¨
public class MapperProxy<T> implements InvocationHandler, Serializable {
    
    private final SqlSession sqlSession;
    private final Class<T> mapperInterface;
    private final Map<Method, MapperMethodInvoker> methodCache;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (Object.class.equals(method.getDeclaringClass())) {
                return method.invoke(this, args);
            } else {
                return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
            }
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
    }
    
    private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {
        return methodCache.computeIfAbsent(method, m -> {
            if (m.isDefault()) {
                // Java 8+ é»˜è®¤æ–¹æ³•
                return new DefaultMethodInvoker(getMethodHandleJava8(method));
            } else {
                return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, 
                                                              sqlSession.getConfiguration()));
            }
        });
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰ Mapper ä»£ç†
public class CustomMapperProxy<T> implements InvocationHandler {
    
    private final SqlSession sqlSession;
    private final Class<T> mapperInterface;
    
    public CustomMapperProxy(SqlSession sqlSession, Class<T> mapperInterface) {
        this.sqlSession = sqlSession;
        this.mapperInterface = mapperInterface;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // è‡ªå®šä¹‰ä»£ç†é€»è¾‘
        System.out.println("æ‰§è¡Œæ–¹æ³•ï¼š" + method.getName());
        
        // è°ƒç”¨åŸå§‹æ–¹æ³•
        MapperMethod mapperMethod = new MapperMethod(mapperInterface, method, 
                                                    sqlSession.getConfiguration());
        return mapperMethod.execute(sqlSession, args);
    }
}

// 2. ä½¿ç”¨ MyBatis-Plus çš„ä»£ç†å¢å¼º
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // ç»§æ‰¿ BaseMapperï¼Œè‡ªåŠ¨è·å¾— CRUD æ–¹æ³•
}
```

---

### 2.4 æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Method Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šBaseExecutor

```java
// æŠ½è±¡æ¨¡æ¿ç±»
public abstract class BaseExecutor implements Executor {
    
    protected Transaction transaction;
    protected Executor wrapper;
    protected ConcurrentLinkedQueue<DeferredLoad> deferredLoads;
    protected PerpetualCache localCache;
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, 
                            RowBounds rowBounds, ResultHandler resultHandler) 
            throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameter);
        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
        return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, 
                            RowBounds rowBounds, ResultHandler resultHandler, 
                            CacheKey key, BoundSql boundSql) throws SQLException {
        // 1. æ£€æŸ¥ç¼“å­˜
        List<E> list = resultHandler == null ? 
            (List<E>) localCache.getObject(key) : null;
        if (list != null) {
            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
        } else {
            // 2. ä»æ•°æ®åº“æŸ¥è¯¢ï¼ˆæŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°ï¼‰
            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, 
                                    key, boundSql);
        }
        return list;
    }
    
    private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, 
                                          RowBounds rowBounds, ResultHandler resultHandler, 
                                          CacheKey key, BoundSql boundSql) 
            throws SQLException {
        List<E> list;
        localCache.putObject(key, EXECUTION_PLACEHOLDER);
        try {
            // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°
            list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
        } finally {
            localCache.removeObject(key);
        }
        localCache.putObject(key, list);
        return list;
    }
    
    // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å¿…é¡»å®ç°
    protected abstract <E> List<E> doQuery(MappedStatement ms, Object parameter, 
                                          RowBounds rowBounds, ResultHandler resultHandler, 
                                          BoundSql boundSql) throws SQLException;
    
    protected abstract int doUpdate(MappedStatement ms, Object parameter) 
        throws SQLException;
}

// å…·ä½“å®ç°ç±»
public class SimpleExecutor extends BaseExecutor {
    
    @Override
    public <E> List<E> doQuery(MappedStatement ms, Object parameter, 
                              RowBounds rowBounds, ResultHandler resultHandler, 
                              BoundSql boundSql) throws SQLException {
        Statement stmt = null;
        try {
            Configuration configuration = ms.getConfiguration();
            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, 
                                                                         parameter, rowBounds, 
                                                                         resultHandler, boundSql);
            stmt = prepareStatement(handler, ms.getStatementLog());
            return handler.query(stmt, resultHandler);
        } finally {
            closeStatement(stmt);
        }
    }
}
```

---

### 2.5 è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šExecutor è£…é¥°å™¨

```java
// ç¼“å­˜è£…é¥°å™¨
public class CachingExecutor implements Executor {
    
    private final Executor delegate;
    private final TransactionalCacheManager tcm = new TransactionalCacheManager();
    
    public CachingExecutor(Executor delegate) {
        this.delegate = delegate;
        delegate.setExecutorWrapper(this);
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameterObject, 
                            RowBounds rowBounds, ResultHandler resultHandler) 
            throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameterObject);
        CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
        return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameterObject, 
                            RowBounds rowBounds, ResultHandler resultHandler, 
                            CacheKey key, BoundSql boundSql) throws SQLException {
        Cache cache = ms.getCache();
        if (cache != null) {
            flushCacheIfRequired(ms);
            if (ms.isUseCache() && resultHandler == null) {
                // ä»äºŒçº§ç¼“å­˜è·å–
                List<E> list = (List<E>) tcm.getObject(cache, key);
                if (list == null) {
                    // å§”æ‰˜ç»™è¢«è£…é¥°çš„ Executor
                    list = delegate.query(ms, parameterObject, rowBounds, 
                                         resultHandler, key, boundSql);
                    // æ”¾å…¥äºŒçº§ç¼“å­˜
                    tcm.putObject(cache, key, list);
                }
                return list;
            }
        }
        return delegate.query(ms, parameterObject, rowBounds, resultHandler, 
                             key, boundSql);
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰ Executor è£…é¥°å™¨
public class LoggingExecutor implements Executor {
    
    private final Executor delegate;
    
    public LoggingExecutor(Executor delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, 
                            RowBounds rowBounds, ResultHandler resultHandler) 
            throws SQLException {
        System.out.println("æ‰§è¡ŒæŸ¥è¯¢ï¼š" + ms.getId());
        long start = System.currentTimeMillis();
        List<E> result = delegate.query(ms, parameter, rowBounds, resultHandler);
        long end = System.currentTimeMillis();
        System.out.println("æŸ¥è¯¢è€—æ—¶ï¼š" + (end - start) + "ms");
        return result;
    }
    
    // å§”æ‰˜å…¶ä»–æ–¹æ³•...
}

// 2. æ³¨å†Œè‡ªå®šä¹‰ Executor
@Configuration
public class MyBatisConfig {
    
    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> {
            // è‡ªå®šä¹‰ Executor åˆ›å»ºé€»è¾‘
            configuration.setDefaultExecutorType(ExecutorType.SIMPLE);
        };
    }
}
```

---

### 2.6 è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibility Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šInterceptor æ’ä»¶æœºåˆ¶

```java
// æ‹¦æˆªå™¨æ¥å£
public interface Interceptor {
    Object intercept(Invocation invocation) throws Throwable;
    default Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
    default void setProperties(Properties properties) {
    }
}

// æ’ä»¶ä»£ç†
public class Plugin implements InvocationHandler {
    
    private final Object target;
    private final Interceptor interceptor;
    private final Map<Class<?>, Set<Method>> signatureMap;
    
    public static Object wrap(Object target, Interceptor interceptor) {
        Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
        Class<?> type = target.getClass();
        Class<?>[] interfaces = getAllInterfaces(type, signatureMap);
        if (interfaces.length > 0) {
            return Proxy.newProxyInstance(
                type.getClassLoader(),
                interfaces,
                new Plugin(target, interceptor, signatureMap));
        }
        return target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            Set<Method> methods = signatureMap.get(method.getDeclaringClass());
            if (methods != null && methods.contains(method)) {
                // æ‹¦æˆªæ–¹æ³•ï¼Œæ‰§è¡Œæ’ä»¶é€»è¾‘
                return interceptor.intercept(new Invocation(target, method, args));
            }
            // ä¸æ‹¦æˆªï¼Œç›´æ¥æ‰§è¡Œ
            return method.invoke(target, args);
        } catch (Exception e) {
            throw ExceptionUtil.unwrapThrowable(e);
        }
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. è‡ªå®šä¹‰æ’ä»¶
@Intercepts({
    @Signature(type = Executor.class, method = "query", 
               args = {MappedStatement.class, Object.class, RowBounds.class, 
                      ResultHandler.class})
})
public class SqlLogInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];
        Object parameter = invocation.getArgs()[1];
        
        // è·å– SQL
        BoundSql boundSql = mappedStatement.getBoundSql(parameter);
        String sql = boundSql.getSql();
        
        // æ‰“å° SQL
        System.out.println("æ‰§è¡Œ SQLï¼š" + sql);
        System.out.println("å‚æ•°ï¼š" + parameter);
        
        // æ‰§è¡ŒåŸæ–¹æ³•
        long start = System.currentTimeMillis();
        Object result = invocation.proceed();
        long end = System.currentTimeMillis();
        
        System.out.println("æ‰§è¡Œè€—æ—¶ï¼š" + (end - start) + "ms");
        return result;
    }
}

// 2. åˆ†é¡µæ’ä»¶
@Intercepts({
    @Signature(type = Executor.class, method = "query", 
               args = {MappedStatement.class, Object.class, RowBounds.class, 
                      ResultHandler.class})
})
public class PageInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Object[] args = invocation.getArgs();
        MappedStatement ms = (MappedStatement) args[0];
        Object parameter = args[1];
        RowBounds rowBounds = (RowBounds) args[2];
        
        if (rowBounds != RowBounds.DEFAULT) {
            // éœ€è¦åˆ†é¡µ
            BoundSql boundSql = ms.getBoundSql(parameter);
            String sql = boundSql.getSql();
            
            // æ„å»ºåˆ†é¡µ SQL
            String pageSql = sql + " LIMIT " + rowBounds.getOffset() + 
                           ", " + rowBounds.getLimit();
            
            // ä¿®æ”¹ SQL
            // ...
        }
        
        return invocation.proceed();
    }
}

// 3. æ³¨å†Œæ’ä»¶
@Configuration
public class MyBatisConfig {
    
    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> {
            configuration.addInterceptor(new SqlLogInterceptor());
            configuration.addInterceptor(new PageInterceptor());
        };
    }
}
```

---

## 3. Dubbo ä¸­çš„è®¾è®¡æ¨¡å¼

### 3.1 SPI æ‰©å±•æœºåˆ¶ï¼ˆç­–ç•¥æ¨¡å¼ + å·¥å‚æ¨¡å¼ï¼‰ğŸ”¥

**åº”ç”¨åœºæ™¯**ï¼šDubbo çš„æ ¸å¿ƒæ‰©å±•æœºåˆ¶

```java
// ExtensionLoader - æ‰©å±•åŠ è½½å™¨
public class ExtensionLoader<T> {
    
    private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = 
        new ConcurrentHashMap<>();
    
    private final Class<?> type;
    private final ExtensionFactory objectFactory;
    private final ConcurrentMap<String, Holder<Object>> cachedInstances = 
        new ConcurrentHashMap<>();
    
    // è·å–æ‰©å±•åŠ è½½å™¨
    public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
        ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
        if (loader == null) {
            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));
            loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
        }
        return loader;
    }
    
    // è·å–æ‰©å±•å®ä¾‹
    public T getExtension(String name) {
        if (StringUtils.isEmpty(name)) {
            throw new IllegalArgumentException("Extension name == null");
        }
        if ("true".equals(name)) {
            return getDefaultExtension();
        }
        
        Holder<Object> holder = cachedInstances.get(name);
        if (holder == null) {
            cachedInstances.putIfAbsent(name, new Holder<>());
            holder = cachedInstances.get(name);
        }
        
        Object instance = holder.get();
        if (instance == null) {
            synchronized (holder) {
                instance = holder.get();
                if (instance == null) {
                    instance = createExtension(name);
                    holder.set(instance);
                }
            }
        }
        return (T) instance;
    }
    
    private T createExtension(String name) {
        Class<?> clazz = getExtensionClasses().get(name);
        if (clazz == null) {
            throw new IllegalStateException("No such extension " + type.getName() + 
                                          " by name " + name);
        }
        
        try {
            T instance = (T) EXTENSION_INSTANCES.get(clazz);
            if (instance == null) {
                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
                instance = (T) EXTENSION_INSTANCES.get(clazz);
            }
            injectExtension(instance);
            return instance;
        } catch (Throwable t) {
            throw new IllegalStateException("Extension instance error", t);
        }
    }
}
```

**æ‰©å±•æ–¹å¼**ï¼š

```java
// 1. å®šä¹‰æ‰©å±•æ¥å£
@SPI("dubbo")
public interface Protocol {
    @Adaptive
    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;
    
    @Adaptive
    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;
}

// 2. å®ç°æ‰©å±•
public class CustomProtocol implements Protocol {
    
    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        // è‡ªå®šä¹‰åè®®æš´éœ²é€»è¾‘
        return null;
    }
    
    @Override
    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
        // è‡ªå®šä¹‰åè®®å¼•ç”¨é€»è¾‘
        return null;
    }
}

// 3. é…ç½®æ‰©å±•
// åœ¨ META-INF/dubbo/org.apache.dubbo.rpc.Protocol æ–‡ä»¶ä¸­æ·»åŠ ï¼š
// custom=com.example.CustomProtocol

// 4. ä½¿ç”¨æ‰©å±•
@DubboService(protocol = "custom")
public class UserServiceImpl implements UserService {
    // ...
}
```

---

### 3.2 è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰

**åº”ç”¨åœºæ™¯**ï¼šProtocol åŒ…è£…

```java
// ProtocolFilterWrapper - è¿‡æ»¤å™¨åŒ…è£…
public class ProtocolFilterWrapper implements Protocol {
    
    private final Protocol protocol;
    
    public ProtocolFilterWrapper(Protocol protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException("protocol == null");
        }
        this.protocol = protocol;
    }
    
    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        if (UrlUtils.isRegistry(invoker.getUrl())) {
            return protocol.export(invoker);
        }
        // æ„å»ºè¿‡æ»¤å™¨é“¾
        return protocol.export(buildInvokerChain(invoker, 
                                                SERVICE_FILTER_KEY, 
                                                CommonConstants.PROVIDER));
    }
    
    @Override
    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
        if (UrlUtils.isRegistry(url)) {
            return protocol.refer(type, url);
        }
        // æ„å»ºè¿‡æ»¤å™¨é“¾
        return buildInvokerChain(protocol.refer(type, url), 
                                REFERENCE_FILTER_KEY, 
                                CommonConstants.CONSUMER);
    }
    
    private <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, 
                                             String key, String group) {
        Invoker<T> last = invoker;
        List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class)
            .getActivateExtension(invoker.getUrl(), key, group);
        
        if (!filters.isEmpty()) {
            for (int i = filters.size() - 1; i >= 0; i--) {
                final Filter filter = filters.get(i);
                final Invoker<T> next = last;
                last = new Invoker<T>() {
                    @Override
                    public Result invoke(Invocation invocation) throws RpcException {
                        return filter.invoke(next, invocation);
                    }
                    // ...
                };
            }
        }
        return last;
    }
}
```

